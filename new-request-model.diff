diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -319,16 +319,18 @@ TabChild::destroyWidget()
     if (baseWindow)
         baseWindow->Destroy();
 
     return true;
 }
 
 TabChild::~TabChild()
 {
+    // TODO Destroy our PContextWrapperChild, too!
+    // TODONT Just wait for cjones to address bug 540111.
     destroyWidget();
     nsCOMPtr<nsIWebBrowser> webBrowser = do_QueryInterface(mWebNav);
     if (webBrowser) {
       webBrowser->SetContainerWindow(nsnull);
     }
 }
 
 bool
diff --git a/js/src/ipc/ContextWrapperChild.h b/js/src/ipc/ContextWrapperChild.h
--- a/js/src/ipc/ContextWrapperChild.h
+++ b/js/src/ipc/ContextWrapperChild.h
@@ -3,26 +3,30 @@
 
 #include "mozilla/jsipc/PContextWrapperChild.h"
 #include "mozilla/jsipc/ObjectWrapperChild.h"
 
 #include "jsapi.h"
 #include "nsClassHashtable.h"
 #include "nsHashKeys.h"
 
+#include "nsContentUtils.h"
+#include "nsIJSContextStack.h"
+
 namespace mozilla {
 namespace jsipc {
 
 class ContextWrapperChild
     : public PContextWrapperChild
 {
 public:
 
     ContextWrapperChild(JSContext* cx)
         : mContext(cx)
+        , mContextStack(nsContentUtils::ThreadJSContextStack())
     {
         mResidentObjectTable.Init();
     }
 
     JSContext* GetContext() { return mContext; }
 
     PObjectWrapperChild* GetOrCreateWrapper(JSObject* obj,
                                             bool makeGlobal = false)
@@ -34,36 +38,59 @@ public:
             mResidentObjectTable.Put(obj, SendPObjectWrapperConstructor(AllocPObjectWrapper(obj),
                                                                         makeGlobal));
         return wrapper;
     }
     
     PObjectWrapperChild* GetOrCreateGlobalWrapper() {
         return GetOrCreateWrapper(JS_GetGlobalObject(mContext), true);
     }
+
+    void PushContext() {
+        nsresult rv = mContextStack->Push(mContext);
+        NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to push our context");
+    }
+
+    void PopContext() {
+        JSContext* popped;
+        nsresult rv = mContextStack->Pop(&popped);
+        NS_ASSERTION(NS_SUCCEEDED(rv) && mContext == popped,
+                     "Failed to pop our context");
+    }
     
 protected:
 
+    bool AnswerBeginRequest() {
+        JS_BeginRequest(mContext);
+        return true;
+    }
+
+    bool AnswerEndRequest() {
+        JS_EndRequest(mContext);
+        return true;
+    }
+
     PObjectWrapperChild* AllocPObjectWrapper(JSObject* obj) {
         return new ObjectWrapperChild(mContext, obj);
     }
     
     PObjectWrapperChild* AllocPObjectWrapper(const bool&) {
         return AllocPObjectWrapper(JS_GetGlobalObject(mContext));
     }
 
     bool DeallocPObjectWrapper(PObjectWrapperChild* actor) {
         ObjectWrapperChild* owc = static_cast<ObjectWrapperChild*>(actor);
         mResidentObjectTable.Remove(owc->GetJSObject());
         return true;
     }
 
 private:
-    
+
     JSContext* const mContext;
+    nsIThreadJSContextStack* const mContextStack;
 
     nsClassHashtable<nsPtrHashKey<JSObject>,
                      PObjectWrapperChild> mResidentObjectTable;
 
 };
 
 }}
 
diff --git a/js/src/ipc/ContextWrapperParent.h b/js/src/ipc/ContextWrapperParent.h
--- a/js/src/ipc/ContextWrapperParent.h
+++ b/js/src/ipc/ContextWrapperParent.h
@@ -1,43 +1,64 @@
 #ifndef mozilla_jsipc_ContextWrapperParent_h__
 #define mozilla_jsipc_ContextWrapperParent_h__
 
 #include "mozilla/jsipc/PContextWrapperParent.h"
 #include "mozilla/jsipc/ObjectWrapperParent.h"
+#include "mozilla/jsipc/CPOWTypes.h"
 
 #include "jsapi.h"
 #include "nsAutoJSValHolder.h"
 
 namespace mozilla {
 namespace jsipc {
     
 class ContextWrapperParent
     : public PContextWrapperParent
 {
 public:
 
-    ContextWrapperParent() : mGlobal(NULL) {}
+    ContextWrapperParent()
+        : mGlobal(NULL)
+        , mRequestDepth(0)
+    {}
 
     bool GetGlobalJSObject(JSContext* cx, JSObject** globalp) {
         if (!mGlobal)
             return false;
         mGlobalHolder.Hold(cx);
         mGlobalHolder = *globalp = mGlobal->GetJSObject(cx);
         return true;
     }
 
     ObjectWrapperParent* GetGlobalObjectWrapper() const {
         return mGlobal;
     }
 
+    bool CallBeginRequest() {
+        CPOW_LOG(("Calling BeginRequest (depth: %d -> %d)...",
+                  mRequestDepth, mRequestDepth + 1));
+        return (mRequestDepth++ > 0 ||
+                PContextWrapperParent::CallBeginRequest());
+    }
+
+    bool CallEndRequest() {
+        CPOW_LOG(("Calling EndRequest (depth: %d -> %d)...",
+                  mRequestDepth, mRequestDepth - 1));
+        NS_ASSERTION(mRequestDepth > 0,
+                     "Unbalanced ObjectWrapperParent::CallEndRequest");
+        return (--mRequestDepth > 0 ||
+                PContextWrapperParent::CallEndRequest());
+    }
+
 private:
 
     ObjectWrapperParent* mGlobal;
     nsAutoJSValHolder mGlobalHolder;
+    int mRequestDepth;
 
     PObjectWrapperParent* AllocPObjectWrapper(const bool&) {
         return new ObjectWrapperParent();
     }
 
     bool RecvPObjectWrapperConstructor(PObjectWrapperParent* actor,
                                        const bool& makeGlobal)
     {
diff --git a/js/src/ipc/ObjectWrapperChild.cpp b/js/src/ipc/ObjectWrapperChild.cpp
--- a/js/src/ipc/ObjectWrapperChild.cpp
+++ b/js/src/ipc/ObjectWrapperChild.cpp
@@ -2,16 +2,39 @@
 #include "mozilla/jsipc/ObjectWrapperChild.h"
 #include "mozilla/jsipc/CPOWTypes.h"
 
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace jsipc {
 
+namespace {
+
+    class AutoContextPusher {
+        ContextWrapperChild* mContextWrapper;
+        JS_DECL_USE_GUARD_OBJECT_NOTIFIER;
+    public:
+        AutoContextPusher(ContextWrapperChild* cwc
+                          JS_GUARD_OBJECT_NOTIFIER_PARAM)
+            : mContextWrapper(cwc)
+        {
+            JS_GUARD_OBJECT_NOTIFIER_INIT;
+            mContextWrapper->PushContext();
+        }
+        ~AutoContextPusher() {
+            mContextWrapper->PopContext();
+        }
+        JSContext* GetContext() const {
+            return mContextWrapper->GetContext();
+        }
+    };
+
+}
+    
 ObjectWrapperChild::ObjectWrapperChild(JSContext* cx, JSObject* obj)
     : mObj(obj)
 {
     JSAutoRequest request(cx);
     JS_AddNamedRoot(cx, (void*)&mObj,
                     "mozilla::jsipc::ObjectWrapperChild-rooted JSObject*");
 }
 
@@ -158,35 +181,36 @@ jsid_from_nsString(JSContext* cx, const 
 
 #if 0
 // The general schema for ObjectWrapperChild::Answer* methods:
 bool
 ObjectWrapperChild::AnswerSomething(/* in-parameters */
                                     /* out-parameters */)
 {
     // initialize out-parameters for failure
-    JSAutoRequest request(Manager()->GetContext());
+    JSAutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
     // validate in-parameters, else return false
     // successfully perform local JS operations, else return true
     // perform out-parameter conversions, else return false
     return true;
 }
 // There's an important subtlety here: though a local JS operation may
 // fail, leaving out-parameters uninitialized, we must initialize all
 // out-parameters when reporting success (returning true) to the IPC
 // messaging system.  See AnswerGetProperty for illustration.
 #endif
 
 bool
 ObjectWrapperChild::AnswerAddProperty(const nsString& id)
 {
     jsid interned_id;
 
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     if (!jsid_from_nsString(cx, id, &interned_id))
         return false;
     
     JS_DefinePropertyById(cx, mObj, interned_id, JSVAL_VOID, NULL, NULL, 0);
     return true;
 }
 
@@ -194,18 +218,18 @@ bool
 ObjectWrapperChild::AnswerGetProperty(const nsString& id,
                                       JSBool* ok, JSVariant* vp)
 {
     jsid interned_id;
     jsval val;
 
     *ok = JS_FALSE;
 
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     if (!jsid_from_nsString(cx, id, &interned_id))
         return false;
 
     *ok = JS_GetPropertyById(cx, mObj, interned_id, &val);
 
     // Since we fully expect this call to jsval_to_JSVariant to return
     // true, we can't just leave vp uninitialized when JS_GetPropertyById
@@ -220,18 +244,18 @@ ObjectWrapperChild::AnswerSetProperty(co
                                       JSBool* ok, JSVariant* vp)
 {
     jsid interned_id;
     jsval val;
 
     *ok = JS_FALSE;
     *vp = v;
 
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     if (!jsid_from_nsString(cx, id, &interned_id) ||
         !jsval_from_JSVariant(cx, v, &val))
         return false;
 
     *ok = JS_SetPropertyById(cx, mObj, interned_id, &val);
 
     return jsval_to_JSVariant(cx, *ok ? val : JSVAL_VOID, vp);
@@ -241,18 +265,18 @@ bool
 ObjectWrapperChild::AnswerDelProperty(const nsString& id,
                                       JSBool* ok, JSVariant* vp)
 {
     jsid interned_id;
     jsval val;
 
     *ok = JS_FALSE;
 
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     if (!jsid_from_nsString(cx, id, &interned_id))
         return false;
 
     *ok = JS_DeletePropertyById2(cx, mObj, interned_id, &val);
 
     return jsval_to_JSVariant(cx, *ok ? val : JSVAL_VOID, vp);
 }
@@ -283,18 +307,18 @@ static const JSClass sCPOW_NewEnumerateS
 
 bool
 ObjectWrapperChild::AnswerNewEnumerateInit(/* no in-parameters */
                                            JSBool* ok, JSVariant* statep, int* idp)
 {
     *ok = JS_FALSE;
     *idp = 0;
 
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     JSClass* clasp = const_cast<JSClass*>(&sCPOW_NewEnumerateState_JSClass);
     JSObject* state = JS_NewObjectWithGivenProto(cx, clasp, NULL, NULL);
     if (!state)
         return false;
     
     for (JSObject* proto = mObj;
          proto;
@@ -330,18 +354,18 @@ ObjectWrapperChild::AnswerNewEnumerateNe
     jsval v;
     JSIdArray* ids;
     JSString* str;
 
     *ok = JS_FALSE;
     *statep = in_state;
     *idp = EmptyString();
     
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     if (!JSObject_from_JSVariant(cx, in_state, &state) ||
         !JS_GetReservedSlot(cx, state, sIdArraySlot, &v) ||
         !(ids = static_cast<JSIdArray*>(JSVAL_TO_PRIVATE(v))) ||
         !JS_GetReservedSlot(cx, state, sNextIdIndexSlot, &v))
         return false;
 
     int i = JSVAL_TO_INT(v);
@@ -362,44 +386,44 @@ ObjectWrapperChild::AnswerNewEnumerateNe
                              INT_TO_JSVAL(i + 1));
     return true;
 }
     
 bool
 ObjectWrapperChild::RecvNewEnumerateDestroy(const JSVariant& in_state)
 {
     JSObject* state;
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
     return (JSObject_from_JSVariant(cx, in_state, &state) &&
             JS_SetReservedSlot(cx, state, sIdArraySlot, JSVAL_ZERO));
 }
 
 bool
 ObjectWrapperChild::AnswerIterator(/* no in-parameters */
                                    PObjectWrapperChild** iterator)
 {
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
     JSObject* iterObj = JS_NewPropertyIterator(cx, mObj);
     *iterator = Manager()->GetOrCreateWrapper(iterObj);
     return true;
 }
 
 bool
 ObjectWrapperChild::AnswerNewResolve(const nsString& id, const int& flags,
                                      JSBool* ok, PObjectWrapperChild** obj2)
 {
     jsid interned_id;
     
     *ok = JS_FALSE;
     *obj2 = NULL;
 
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     if (!jsid_from_nsString(cx, id, &interned_id))
         return false;
 
     CPOW_LOG(("new-resolving \"%s\"...",
               NS_ConvertUTF16toUTF8(id).get()));
 
     JSPropertyDescriptor desc;
@@ -414,30 +438,30 @@ ObjectWrapperChild::AnswerNewResolve(con
     return true;
 }
 
 bool
 ObjectWrapperChild::AnswerConvert(const JSType& type,
                                   JSBool* ok, JSVariant* vp)
 {
     jsval v;
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
     *ok = JS_ConvertValue(cx, OBJECT_TO_JSVAL(mObj), type, &v);
     return jsval_to_JSVariant(cx, *ok ? v : JSVAL_VOID, vp);
 }
 
 bool
 ObjectWrapperChild::AnswerCall(PObjectWrapperChild* receiver, const nsTArray<JSVariant>& argv,
                                JSBool* ok, JSVariant* rval)
 {
     *ok = JS_FALSE;
-    
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     JSObject* obj;
     if (!JSObject_from_PObjectWrapperChild(cx, receiver, &obj))
         return false;
 
     jsval rv, jsargs[argv.Length()];
     for (PRUint32 i = 0; i < argv.Length(); ++i)
         if (!jsval_from_JSVariant(cx, argv.ElementAt(i), jsargs + i))
@@ -448,18 +472,18 @@ ObjectWrapperChild::AnswerCall(PObjectWr
 
     return jsval_to_JSVariant(cx, *ok ? rv : JSVAL_VOID, rval);
 }
 
 bool
 ObjectWrapperChild::AnswerConstruct(const nsTArray<JSVariant>& argv,
                                     JSBool* ok, PObjectWrapperChild** rval)
 {
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
 
     JSClass* clasp = NULL;
     JSObject* pobj = JSVAL_NULL;
     {
         jsval pval;
         if (JS_GetProperty(cx, mObj, "prototype", &pval) &&
             JSVAL_IS_OBJECT(pval))
         {
@@ -484,17 +508,17 @@ ObjectWrapperChild::AnswerConstruct(cons
     return answer;
 }
 
 bool
 ObjectWrapperChild::AnswerHasInstance(const JSVariant& v,
                                       JSBool* ok, JSBool* bp)
 {
     jsval candidate;
-    JSContext* cx = Manager()->GetContext();
-    JSAutoRequest request(cx);
+    AutoContextPusher stack(Manager());
+    JSContext* cx = stack.GetContext();
     if (!jsval_from_JSVariant(cx, v, &candidate))
         return false;
     *ok = JS_HasInstance(cx, mObj, candidate, bp);
     return true;
 }
 
 }}
diff --git a/js/src/ipc/ObjectWrapperParent.cpp b/js/src/ipc/ObjectWrapperParent.cpp
--- a/js/src/ipc/ObjectWrapperParent.cpp
+++ b/js/src/ipc/ObjectWrapperParent.cpp
@@ -47,16 +47,30 @@ namespace {
                                  GetFlags(cx, obj) | CPOW_FLAG_RESOLVING))
         { JS_GUARD_OBJECT_NOTIFIER_INIT; }
         ~AutoResolveFlag() { SetFlags(mContext, mObj, mOldFlags); }
         static JSBool IsSet(JSContext* cx, JSObject* obj) {
             return GetFlags(cx, obj) & CPOW_FLAG_RESOLVING;
         }
     };
 
+    class AutoRequest {
+        ContextWrapperParent* mManager;
+        JS_DECL_USE_GUARD_OBJECT_NOTIFIER;
+    public:
+        AutoRequest(ContextWrapperParent* cwp
+                    JS_GUARD_OBJECT_NOTIFIER_PARAM)
+            : mManager(cwp)
+        {
+            JS_GUARD_OBJECT_NOTIFIER_INIT;
+            mManager->CallBeginRequest();
+        }
+        ~AutoRequest() { mManager->CallEndRequest(); }
+    };
+
 }
 
 const JSExtendedClass _::sCPOW_JSClass = {
     // JSClass (JSExtendedClass.base) initialization
     { "CrossProcessObjectWrapper",
       JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_IS_EXTENDED |
       JSCLASS_HAS_RESERVED_SLOTS(sNumSlots),
       _::CPOW_AddProperty,
@@ -87,17 +101,24 @@ const JSExtendedClass _::sCPOW_JSClass =
 };
 
 void
 ObjectWrapperParent::ActorDestroy(ActorDestroyReason)
 {
     // See GetJSObject, Unwrap.
     *mObjSlotContents = NULL;
 }
-    
+
+ContextWrapperParent*
+ObjectWrapperParent::Manager()
+{
+    PContextWrapperParent* pcwp = PObjectWrapperParent::Manager();
+    return static_cast<ContextWrapperParent*>(pcwp);
+}
+
 JSObject*
 ObjectWrapperParent::GetJSObject(JSContext* cx) const
 {
     JSClass* clasp = const_cast<JSClass*>(&_::sCPOW_JSClass.base);
     if (!mObj) {
         mObj = JS_NewObject(cx, clasp, NULL, NULL);
         *mObjSlotContents = this; // See ActorDestroy, Unwrap.
         JS_SetReservedSlot(cx, mObj, sWrappedObjSlot,
@@ -281,16 +302,18 @@ ObjectWrapperParent::CPOW_AddProperty(JS
     if (AutoResolveFlag::IsSet(cx, obj))
         return JS_TRUE;
     
     nsString in_id;
 
     if (!jsval_to_nsString(cx, id, &in_id))
         return JS_FALSE;
 
+    AutoRequest request(self->Manager());
+
     return self->CallAddProperty(in_id);
 }    
 
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_GetProperty(JSContext *cx, JSObject *obj, jsval id,
                                       jsval *vp)
 {
     CPOW_LOG(("Calling CPOW_GetProperty (%s)...",
@@ -303,16 +326,18 @@ ObjectWrapperParent::CPOW_GetProperty(JS
     nsString in_id;
 
     if (!jsval_to_nsString(cx, id, &in_id))
         return JS_FALSE;
 
     JSBool out_ok;
     JSVariant out_v;
     
+    AutoRequest request(self->Manager());
+
     return (self->CallGetProperty(in_id,
                                   &out_ok, &out_v) &&
             out_ok &&
             self->jsval_from_JSVariant(cx, out_v, vp));
 }
 
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_SetProperty(JSContext *cx, JSObject *obj, jsval id,
@@ -330,16 +355,18 @@ ObjectWrapperParent::CPOW_SetProperty(JS
 
     if (!jsval_to_nsString(cx, id, &in_id) ||
         !self->jsval_to_JSVariant(cx, *vp, &in_v))
         return JS_FALSE;
     
     JSBool out_ok;
     JSVariant out_v;
 
+    AutoRequest request(self->Manager());
+
     return (self->CallSetProperty(in_id, in_v,
                                   &out_ok, &out_v) &&
             out_ok &&
             self->jsval_from_JSVariant(cx, out_v, vp));
 }    
     
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_DelProperty(JSContext *cx, JSObject *obj, jsval id,
@@ -355,16 +382,18 @@ ObjectWrapperParent::CPOW_DelProperty(JS
     nsString in_id;
 
     if (!jsval_to_nsString(cx, id, &in_id))
         return JS_FALSE;
 
     JSBool out_ok;
     JSVariant out_v;
     
+    AutoRequest request(self->Manager());
+
     return (self->CallDelProperty(in_id,
                                   &out_ok, &out_v) &&
             out_ok &&
             jsval_from_JSVariant(cx, out_v, vp));
 }
 
 JSBool
 ObjectWrapperParent::NewEnumerateInit(JSContext* cx, jsval* statep, jsid* idp)
@@ -416,30 +445,38 @@ ObjectWrapperParent::NewEnumerateDestroy
 
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_NewEnumerate(JSContext *cx, JSObject *obj,
                                        JSIterateOp enum_op, jsval *statep,
                                        jsid *idp)
 {
     CPOW_LOG(("Calling CPOW_NewEnumerate..."));
 
+    JSBool ok = JS_FALSE;
+
     ObjectWrapperParent* self = Unwrap(cx, obj);
     if (!self)
-        return JS_FALSE;    
+        return ok;
 
     switch (enum_op) {
     case JSENUMERATE_INIT:
-        return self->NewEnumerateInit(cx, statep, idp);
+        self->Manager()->CallBeginRequest();
+        ok = self->NewEnumerateInit(cx, statep, idp);
+        break;
     case JSENUMERATE_NEXT:
-        return self->NewEnumerateNext(cx, statep, idp);
+        ok = self->NewEnumerateNext(cx, statep, idp);
+        if (*statep == JSVAL_NULL)
+            self->Manager()->CallEndRequest();
+        break;
     case JSENUMERATE_DESTROY:
-        return self->NewEnumerateDestroy(cx, *statep);
+        ok = self->NewEnumerateDestroy(cx, *statep);
+        self->Manager()->CallEndRequest();
+        break;
     }
-
-    return JS_FALSE;
+    return ok;
 }
 
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_NewResolve(JSContext *cx, JSObject *obj, jsval id,
                                      uintN flags, JSObject **objp)
 {
     CPOW_LOG(("Calling CPOW_NewResolve (%s)...",
               JSVAL_TO_CSTR(cx, id)));
@@ -450,23 +487,24 @@ ObjectWrapperParent::CPOW_NewResolve(JSC
 
     nsString in_id;
 
     if (!jsval_to_nsString(cx, id, &in_id))
         return JS_FALSE;
 
     JSBool out_ok;
     PObjectWrapperParent* out_pobj;
-
-    if (!self->CallNewResolve(in_id, flags,
-                              &out_ok, &out_pobj) ||
-        !out_ok ||
-        !JSObject_from_PObjectWrapperParent(cx, out_pobj, objp))
-        return JS_FALSE;
-
+    {
+        AutoRequest request(self->Manager());
+        if (!self->CallNewResolve(in_id, flags,
+                                  &out_ok, &out_pobj) ||
+            !out_ok ||
+            !JSObject_from_PObjectWrapperParent(cx, out_pobj, objp))
+            return JS_FALSE;
+    }
     jsid interned_id;
     if (*objp &&
         JS_ValueToId(cx, id, &interned_id)) {
         AutoResolveFlag arf(cx, *objp);
         JS_DefinePropertyById(cx, *objp, interned_id, JSVAL_VOID, NULL, NULL,
                               JSPROP_ENUMERATE);
     }
     return JS_TRUE;
@@ -521,16 +559,18 @@ ObjectWrapperParent::CPOW_Call(JSContext
     nsTArray<JSVariant> in_argv(argc);
     for (uintN i = 0; i < argc; i++)
         if (!jsval_to_JSVariant(cx, argv[i], in_argv.AppendElement()))
             return JS_FALSE;
     
     JSBool out_ok;
     JSVariant out_rval;
 
+    AutoRequest request(function->Manager());
+
     return (function->CallCall(receiver, in_argv,
                                &out_ok, &out_rval) &&
             out_ok &&
             jsval_from_JSVariant(cx, out_rval, rval));
 }
 
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_Construct(JSContext *cx, JSObject *obj, uintN argc,
@@ -546,16 +586,18 @@ ObjectWrapperParent::CPOW_Construct(JSCo
     nsTArray<JSVariant> in_argv(argc);
     for (uintN i = 0; i < argc; i++)
         if (!jsval_to_JSVariant(cx, argv[i], in_argv.AppendElement()))
             return JS_FALSE;
 
     JSBool out_ok;
     PObjectWrapperParent* out_powp;
 
+    AutoRequest request(constructor->Manager());
+
     return (constructor->CallConstruct(in_argv,
                                        &out_ok, &out_powp) &&
             out_ok &&
             jsval_from_PObjectWrapperParent(cx, out_powp, rval));
 }
 
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_HasInstance(JSContext *cx, JSObject *obj, jsval v,
@@ -571,16 +613,18 @@ ObjectWrapperParent::CPOW_HasInstance(JS
 
     JSVariant in_v;
 
     if (!jsval_to_JSVariant(cx, v, &in_v))
         return JS_FALSE;
 
     JSBool out_ok;
 
+    AutoRequest request(self->Manager());
+
     return (self->CallHasInstance(in_v,
                                   &out_ok, bp) &&
             out_ok);
 }
 
 /*static*/ JSBool
 ObjectWrapperParent::CPOW_Equality(JSContext *cx, JSObject *obj, jsval v,
                                    JSBool *bp)
diff --git a/js/src/ipc/ObjectWrapperParent.h b/js/src/ipc/ObjectWrapperParent.h
--- a/js/src/ipc/ObjectWrapperParent.h
+++ b/js/src/ipc/ObjectWrapperParent.h
@@ -3,16 +3,18 @@
 
 #include "mozilla/jsipc/PObjectWrapperParent.h"
 #include "jsapi.h"
 #include "nsAutoJSValHolder.h"
 
 namespace mozilla {
 namespace jsipc {
 
+class ContextWrapperParent;
+    
 class ObjectWrapperParent
     : public PObjectWrapperParent
 {
 public:
 
     ObjectWrapperParent()
         : mObj(NULL)
         , mObjSlotContents(new ObjectWrapperParent const*(NULL))
@@ -25,16 +27,18 @@ public:
     }
 
     static const JSExtendedClass sCPOW_JSClass;
 
 protected:
 
     void ActorDestroy(ActorDestroyReason why);
 
+    ContextWrapperParent* Manager();
+
 private:
 
     mutable JSObject* mObj;
     ObjectWrapperParent const** const mObjSlotContents;
 
     static JSBool
     CPOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
 
diff --git a/js/src/ipc/PContextWrapper.ipdl b/js/src/ipc/PContextWrapper.ipdl
--- a/js/src/ipc/PContextWrapper.ipdl
+++ b/js/src/ipc/PContextWrapper.ipdl
@@ -6,11 +6,16 @@ namespace jsipc {
 
 rpc protocol PContextWrapper
 {
     manager PContentProcess;
     manages PObjectWrapper;
 parent:
     __delete__();
     sync PObjectWrapper(bool makeGlobal);
+ child:
+    // Request depth managed locally, so only the first/last
+    // BeginRequest/EndRequest calls cause IPC traffic.
+    rpc BeginRequest();
+    rpc EndRequest();
 };
 
 }}
