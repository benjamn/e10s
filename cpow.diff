# HG changeset patch
# User Ben Newman <bnewman@mozilla.com>
# Date 1257540219 28800
# Node ID a82312ef8ffd49051c380264ad70c05b5948c643
# Parent  69674697dbce469745f1baaccb507cca27afd1e8
Bug 516522 - CPOW: Cross-Process Object Wrapper.

diff --git a/content/base/public/nsIFrameLoader.idl b/content/base/public/nsIFrameLoader.idl
--- a/content/base/public/nsIFrameLoader.idl
+++ b/content/base/public/nsIFrameLoader.idl
@@ -37,16 +37,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
 interface nsIDocShell;
 interface nsIURI;
 interface nsIFrame;
+interface nsIVariant;
 
 [scriptable, uuid(8f94788d-ec69-4220-971c-0fd68d47b80f)]
 interface nsIFrameLoader : nsISupports
 {
   /**
    * Get the docshell from the frame loader.
    */
   readonly attribute nsIDocShell docShell;
@@ -99,16 +100,22 @@ interface nsIFrameLoader : nsISupports
                                   in long aClickCount,
                                   in long aModifiers,
                                   [optional] in boolean aIgnoreRootScrollFrame);
 
   /**
    * Activate event forwarding from client (remote frame) to parent.
    */
   void activateFrameEvent(in AString aType, in boolean capture);
+
+  /**
+   * Define a property on |where| named |property| whose value is a JSObject
+   * corresponding to the global object of the child frame.
+   */
+  void attachChildGlobal(in nsIVariant where, in AString property);
 };
 
 native alreadyAddRefed_nsFrameLoader(already_AddRefed<nsFrameLoader>);
 
 [scriptable, uuid(8f3b12a0-35ae-4e0d-9152-8e0d7e49d446)]
 interface nsIFrameLoaderOwner : nsISupports
 {
   /**
diff --git a/content/base/src/nsFrameLoader.cpp b/content/base/src/nsFrameLoader.cpp
--- a/content/base/src/nsFrameLoader.cpp
+++ b/content/base/src/nsFrameLoader.cpp
@@ -110,16 +110,19 @@
 #ifdef MOZ_IPC
 #include "ContentProcessParent.h"
 #include "TabParent.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 #endif
 
+#include "nsIXPConnect.h"
+#include "nsIJSContextStack.h"
+
 class nsAsyncDocShellDestroyer : public nsRunnable
 {
 public:
   nsAsyncDocShellDestroyer(nsIDocShell* aDocShell)
     : mDocShell(aDocShell)
   {
   }
 
@@ -1520,16 +1523,42 @@ nsFrameLoader::ActivateFrameEvent(const 
   if (mChildProcess) {
     mChildProcess->SendactivateFrameEvent(nsString(aType), aCapture);
     return NS_OK;
   }
 #endif
   return NS_ERROR_FAILURE;
 }
 
+NS_IMETHODIMP
+nsFrameLoader::AttachChildGlobal(nsIVariant* where,
+                                 const nsAString& property)
+{
+  nsIXPConnect* xpc;
+  nsIThreadJSContextStack* stack;
+  JSContext* cx;
+  jsval v;
+  JSObject* obj;
+  JSString* str;
+  jsid interned_id;
+
+  if ((xpc = nsContentUtils::XPConnect()) &&
+      (stack = nsContentUtils::ThreadJSContextStack()) &&
+      NS_SUCCEEDED(stack->Peek(&cx)) && cx &&
+      NS_SUCCEEDED(xpc->VariantToJS(cx, JS_GetScopeChain(cx), where, &v)) &&
+      JS_ValueToObject(cx, v, &obj) &&
+      (str = JS_NewUCStringCopyN(cx, property.BeginReading(),
+                                 property.Length())) &&
+      JS_ValueToId(cx, STRING_TO_JSVAL(str), &interned_id) &&
+      mChildProcess->AttachGlobal(cx, obj, interned_id))
+    return NS_OK;
+
+  return NS_ERROR_FAILURE;
+}
+
 nsresult
 nsFrameLoader::CreateStaticClone(nsIFrameLoader* aDest)
 {
   nsFrameLoader* dest = static_cast<nsFrameLoader*>(aDest);
   dest->MaybeCreateDocShell();
   NS_ENSURE_STATE(dest->mDocShell);
 
   nsCOMPtr<nsIDOMDocument> dummy = do_GetInterface(dest->mDocShell);
diff --git a/dom/ipc/ContentProcessChild.cpp b/dom/ipc/ContentProcessChild.cpp
--- a/dom/ipc/ContentProcessChild.cpp
+++ b/dom/ipc/ContentProcessChild.cpp
@@ -44,16 +44,17 @@
 
 #include "nsXULAppAPI.h"
 
 #include "base/message_loop.h"
 #include "base/task.h"
 
 using namespace mozilla::ipc;
 using namespace mozilla::net;
+using namespace mozilla::jsipc;
 
 namespace mozilla {
 namespace dom {
 
 ContentProcessChild* ContentProcessChild::sSingleton;
 
 ContentProcessChild::ContentProcessChild()
     : mQuit(PR_FALSE)
@@ -123,16 +124,29 @@ ContentProcessChild::AllocPNecko()
 
 bool 
 ContentProcessChild::DeallocPNecko(PNeckoChild* necko)
 {
     delete necko;
     return true;
 }
 
+PObjectWrapperLiaisonChild*
+ContentProcessChild::AllocPObjectWrapperLiaison(const JSRuntimeOwner&)
+{
+    return NULL;
+}
+
+bool
+ContentProcessChild::DeallocPObjectWrapperLiaison(PObjectWrapperLiaisonChild* actor)
+{
+    delete actor;
+    return true;
+}
+    
 void
 ContentProcessChild::Quit()
 {
     NS_ASSERTION(mQuit, "Exiting uncleanly!");
     mIFrames.Clear();
     mTestShells.Clear();
 }
 
diff --git a/dom/ipc/ContentProcessChild.h b/dom/ipc/ContentProcessChild.h
--- a/dom/ipc/ContentProcessChild.h
+++ b/dom/ipc/ContentProcessChild.h
@@ -40,16 +40,21 @@
 #define mozilla_dom_ContentProcessChild_h
 
 #include "mozilla/dom/PContentProcessChild.h"
 
 #include "nsTArray.h"
 #include "nsAutoPtr.h"
 
 namespace mozilla {
+
+namespace jsipc {
+class PObjectWrapperLiaisonChild;
+}
+
 namespace dom {
 
 class ContentProcessChild : public PContentProcessChild
 {
 public:
     ContentProcessChild();
     virtual ~ContentProcessChild();
 
@@ -66,16 +71,20 @@ public:
     virtual bool DeallocPIFrameEmbedding(PIFrameEmbeddingChild*);
 
     virtual PTestShellChild* AllocPTestShell();
     virtual bool DeallocPTestShell(PTestShellChild*);
 
     virtual PNeckoChild* AllocPNecko();
     virtual bool DeallocPNecko(PNeckoChild*);
 
+protected:
+    virtual PObjectWrapperLiaisonChild* AllocPObjectWrapperLiaison(const JSRuntimeOwner&);
+    virtual bool DeallocPObjectWrapperLiaison(PObjectWrapperLiaisonChild* actor);
+    
 private:
     NS_OVERRIDE
     virtual void ActorDestroy(ActorDestroyReason why);
 
     void Quit();
 
     static ContentProcessChild* sSingleton;
 
diff --git a/dom/ipc/ContentProcessParent.cpp b/dom/ipc/ContentProcessParent.cpp
--- a/dom/ipc/ContentProcessParent.cpp
+++ b/dom/ipc/ContentProcessParent.cpp
@@ -48,16 +48,18 @@
 
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 
 using namespace mozilla::ipc;
 using namespace mozilla::net;
+using namespace mozilla::jsipc;
+    
 using mozilla::MonitorAutoEnter;
 
 namespace {
 PRBool gSingletonDied = PR_FALSE;
 }
 
 namespace mozilla {
 namespace dom {
@@ -177,10 +179,44 @@ ContentProcessParent::AllocPNecko()
 
 bool 
 ContentProcessParent::DeallocPNecko(PNeckoParent* necko)
 {
     delete necko;
     return true;
 }
 
+PObjectWrapperLiaisonParent*
+ContentProcessParent::AllocPObjectWrapperLiaison(const JSRuntimeOwner& jsro)
+{
+    return new ObjectWrapperLiaisonParent();
+}
+
+bool
+ContentProcessParent::DeallocPObjectWrapperLiaison(PObjectWrapperLiaisonParent* actor)
+{
+    delete actor;
+    return true;
+}
+
+bool
+ContentProcessParent::
+RecvPObjectWrapperLiaisonConstructor(PObjectWrapperLiaisonParent* actor,
+                                     const JSRuntimeOwner& jsro)
+{
+    switch (jsro.type()) {
+    case JSRuntimeOwner::TPIFrameEmbeddingParent:
+        {
+            const TabParent* tp =
+                static_cast<const TabParent*>(jsro.get_PIFrameEmbeddingParent());
+            const_cast<TabParent*>(tp)->SetObjectWrapperLiaison(actor);
+            return true;
+        }
+    case JSRuntimeOwner::TPTestShellParent:
+        // TODO
+        return true;
+    default:
+        return false;
+    }
+}   
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/ipc/ContentProcessParent.h b/dom/ipc/ContentProcessParent.h
--- a/dom/ipc/ContentProcessParent.h
+++ b/dom/ipc/ContentProcessParent.h
@@ -48,16 +48,20 @@
 #include "mozilla/Monitor.h"
 
 namespace mozilla {
 
 namespace ipc {
 class TestShellParent;
 }
 
+namespace jsipc {
+class PObjectWrapperLiaisonParent;
+}
+
 namespace dom {
 
 class TabParent;
 
 class ContentProcessParent : public PContentProcessParent,
                              public nsIObserver
 {
 private:
@@ -95,16 +99,20 @@ private:
     virtual bool DeallocPIFrameEmbedding(PIFrameEmbeddingParent* frame);
 
     virtual PTestShellParent* AllocPTestShell();
     virtual bool DeallocPTestShell(PTestShellParent* shell);
 
     virtual PNeckoParent* AllocPNecko();
     virtual bool DeallocPNecko(PNeckoParent* necko);
 
+    virtual PObjectWrapperLiaisonParent* AllocPObjectWrapperLiaison(const JSRuntimeOwner& jsro);
+    virtual bool DeallocPObjectWrapperLiaison(PObjectWrapperLiaisonParent* actor);
+    virtual bool RecvPObjectWrapperLiaisonConstructor(PObjectWrapperLiaisonParent* actor,
+                                                      const JSRuntimeOwner& jsro);
     mozilla::Monitor mMonitor;
 
     GeckoChildProcessHost* mSubprocess;
 };
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/ipc/PContentProcess.ipdl b/dom/ipc/PContentProcess.ipdl
--- a/dom/ipc/PContentProcess.ipdl
+++ b/dom/ipc/PContentProcess.ipdl
@@ -34,31 +34,62 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol "PIFrameEmbedding.ipdl";
 include protocol "PTestShell.ipdl";
 include protocol "PNecko.ipdl";
+include protocol "PObjectWrapperLiaison.ipdl";
 
 include "mozilla/TabTypes.h";
 
 namespace mozilla {
 namespace dom {
 
+/* Although PContentProcess manages PObjectWrapperLiaison,
+ * PObjectWrapperLiaison instances are always created by (or on behalf of)
+ * a particular PIFrameEmbedding or PTestShell, since each instance of these
+ * subprotocols has its own JSRuntime (and distinct PObjectWrapperLiaisons
+ * are needed for distinct JSRuntimes).
+ *
+ * It would be more natural to allow both PIFrameEmbedding and PTestShell
+ * to manage PObjectWrapperLiaison, but as far as I can tell IPDL
+ * protocols cannot have multiple managers.
+ *
+ * So that we can later determine which PObjectWrapperLiaisonParent is
+ * associated with a given PIFrameEmbeddingParent or PTestShellParent, the
+ * PObjectWrapperLiaison constructor message must convey to the
+ * PContentProcessParent which PIFrameEmbeddingChild or PTestShellChild
+ * sent the PObjectWrapperLiaison constructor message.
+ *
+ * We might like to have two separate PObjectWrapperLiaison constructors,
+ * one accepting a PIFrameEmbeddingChild and the other a PTestShell.
+ * Alas, IPDL constructors can't be overloaded, so we'll settle for a
+ * single constructor that accepts a single union-type parameter.
+ */
+union JSRuntimeOwner {
+    PIFrameEmbedding;
+    PTestShell;
+};
+    
 rpc protocol PContentProcess
 {
     manages PIFrameEmbedding;
     manages PTestShell;
     manages PNecko;
+    manages PObjectWrapperLiaison;
 
 child:
     PIFrameEmbedding();
 
     PTestShell();
 
 parent:
     PNecko();
+
+    PObjectWrapperLiaison(JSRuntimeOwner jsro);
+
 };
 
 }
 }
diff --git a/dom/ipc/PIFrameEmbedding.ipdl b/dom/ipc/PIFrameEmbedding.ipdl
--- a/dom/ipc/PIFrameEmbedding.ipdl
+++ b/dom/ipc/PIFrameEmbedding.ipdl
@@ -34,19 +34,22 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol "PContentProcess.ipdl";
 include protocol "PDocumentRenderer.ipdl";
+include protocol "PObjectWrapperLiaison.ipdl";
+include protocol "PObjectWrapper.ipdl";
 
 include "mozilla/TabTypes.h";
 include "TabMessageUtils.h";
+include "mozilla/jsipc/CPOWTypes.h";
 
 using MagicWindowHandle;
 using RemoteDOMEvent;
 
 namespace mozilla {
 namespace dom {
 
 rpc protocol PIFrameEmbedding
@@ -62,16 +65,17 @@ parent:
      * When child sends this message, parent should move focus to
      * the next or previous focusable element.
      */
     moveFocus(bool forward);
 
     sendEvent(RemoteDOMEvent aEvent);
 
     rpc createWindow() returns (PIFrameEmbedding window);
+
 child:
     createWidget(MagicWindowHandle parentWidget);
 
     loadURL(nsCString uri);
 
     move(PRUint32 x,
          PRUint32 y,
          PRUint32 width,
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -50,16 +50,24 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMWindowUtils.h"
 #include "nsISupportsImpl.h"
 #include "nsIWebBrowserFocus.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 
+#include "mozilla/dom/PContentProcessChild.h"
+#include "mozilla/jsipc/ObjectWrapperLiaisonChild.h"
+
+#include "nsIDocument.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIScriptContext.h"
+#include "jscntxt.h"
+
 #ifdef MOZ_WIDGET_GTK2
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 #endif
 
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS1(ContentListener, nsIDOMEventListener)
@@ -329,16 +337,19 @@ TabChild::RecvloadURL(const nsCString& u
     printf("loading %s, %d\n", uri.get(), NS_IsMainThread());
 
     nsresult rv = mWebNav->LoadURI(NS_ConvertUTF8toUTF16(uri).get(),
                                    nsIWebNavigation::LOAD_FLAGS_NONE,
                                    NULL, NULL, NULL);
     if (NS_FAILED(rv)) {
         NS_WARNING("mWebNav->LoadURI failed. Eating exception, what else can I do?");
     }
+
+    CreateObjectWrapperLiaisonAndAttachGlobalObject();
+    
     return true;
 }
 
 bool
 TabChild::Recvmove(const PRUint32& x,
                      const PRUint32& y,
                      const PRUint32& width,
                      const PRUint32& height)
@@ -371,16 +382,49 @@ TabChild::RecvsendMouseEvent(const nsStr
   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(mWebNav);
   nsCOMPtr<nsIDOMWindowUtils> utils = do_GetInterface(window);
   NS_ENSURE_TRUE(utils, true);
   utils->SendMouseEvent(aType, aX, aY, aButton, aClickCount, aModifiers,
                         aIgnoreRootScrollFrame);
   return true;
 }
 
+static JSContext*
+GetJSContext(nsIWebNavigation* webNav)
+{
+    nsCOMPtr<nsIDOMDocument> domDocument;
+    nsCOMPtr<nsIDocument> document;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+
+    if (NS_SUCCEEDED(webNav->GetDocument(getter_AddRefs(domDocument))) &&
+        (document = do_QueryInterface(domDocument)) &&
+        (global = do_QueryInterface(document->GetScriptGlobalObject())) &&
+        (context = do_QueryInterface(global->GetContext())))
+        return static_cast<JSContext*>(context->GetNativeContext());
+
+    return NULL;
+}
+
+void
+TabChild::CreateObjectWrapperLiaisonAndAttachGlobalObject()
+{
+
+    JSContext* cx;
+    PContentProcessChild* manager;
+    mozilla::jsipc::ObjectWrapperLiaisonChild* owlc;
+
+    if ((cx = GetJSContext(mWebNav)) &&
+        (manager = Manager()) &&
+        (owlc = new mozilla::jsipc::ObjectWrapperLiaisonChild(cx)))
+        manager
+            ->SendPObjectWrapperLiaisonConstructor(owlc, this)
+            ->SendPObjectWrapperConstructor(true);
+}
+
 mozilla::ipc::PDocumentRendererChild*
 TabChild::AllocPDocumentRenderer(
         const PRInt32& x,
         const PRInt32& y,
         const PRInt32& w,
         const PRInt32& h,
         const nsString& bgcolor,
         const PRUint32& flags,
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -119,16 +119,17 @@ public:
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
 
 private:
     nsCOMPtr<nsIWebNavigation> mWebNav;
+    void CreateObjectWrapperLiaisonAndAttachGlobalObject();
 
     DISALLOW_EVIL_CONSTRUCTORS(TabChild);
 };
 
 }
 }
 
 #endif // mozilla_tabs_TabChild_h
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -35,25 +35,29 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_tabs_TabParent_h
 #define mozilla_tabs_TabParent_h
 
 #include "mozilla/dom/PIFrameEmbeddingParent.h"
+#include "mozilla/jsipc/ObjectWrapperLiaisonParent.h"
+#include "jsapi.h"
 
 #include "mozilla/ipc/GeckoChildProcessHost.h"
 
 #include "nsCOMPtr.h"
 #include "nsIBrowserDOMWindow.h"
 
 class nsIURI;
 class nsIDOMElement;
 
+using namespace mozilla::jsipc;
+
 namespace mozilla {
 namespace dom {
 
 class TabParent : public PIFrameEmbeddingParent
 {
 public:
     TabParent();
     virtual ~TabParent();
@@ -77,17 +81,28 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
     virtual bool DeallocPDocumentRenderer(PDocumentRendererParent* actor);
+
+    void SetObjectWrapperLiaison(PObjectWrapperLiaisonParent* powlp) {
+        mObjectWrapperLiaison = static_cast<ObjectWrapperLiaisonParent*>(powlp);
+    }
+
+    bool AttachGlobal(JSContext* cx, JSObject* to, jsid id) {
+        return (mObjectWrapperLiaison &&
+                mObjectWrapperLiaison->AttachGlobal(cx, to, id));
+    }
+
 protected:
     nsIDOMElement* mFrameElement;
     nsCOMPtr<nsIBrowserDOMWindow> mBrowserDOMWindow;
+    ObjectWrapperLiaisonParent* mObjectWrapperLiaison;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif
diff --git a/dom/ipc/test.xul b/dom/ipc/test.xul
--- a/dom/ipc/test.xul
+++ b/dom/ipc/test.xul
@@ -1,13 +1,13 @@
 <?xml version="1.0"?>
 <?xml-stylesheet href="chrome://global/skin" type="text/css"?>
 <window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         width="800" height="800" orient="vertical">
-  <script>
+  <script type="application/javascript;version=1.7">
 
     function dumpClientRect(r) {
       dump(r.left + "," + r.top + "," + r.right + "," +
            r.bottom + "," + r.width + "," + r.height + "\n");
     }
 
     function handleMozAfterPaint(e) {
       return;
@@ -72,23 +72,84 @@
 
     function openWindow() {
       window.open('chrome://global/content/test-ipc.xul', '_blank', 'chrome,resizable,width=800,height=800');
     }
     
     function closeWindow() {
       window.close();
     }
+
+    function getChildGlobal() {
+      var page = document.getElementById("page");
+      if (!("contentGlobalObject" in page))
+        page.QueryInterface(Components.interfaces.nsIFrameLoaderOwner)
+            .frameLoader.attachChildGlobal(page, "contentGlobalObject");
+      return page.contentGlobalObject;
+    }
+
+    var cpow_tests = {
+      resolve: function(obj, keys) {
+        alert("resolving");
+        keys = keys.split(" ");
+        for (var i = 0; i != keys.length; ++i)
+          alert("has " + keys[i] + "? " + (keys[i] in obj));
+        alert("done resolving");
+      },
+      iterate: function(obj) {
+        alert("iterating");
+        for (var k in obj)
+          alert("key: " + k);
+        alert("done iterating");
+      },
+      navigate: function(child) {
+        alert("navigating");
+        child.location = prompt("Where to?");
+        setTimeout(function() {
+          alert(child.location.href);
+        }, 2000);
+      },
+      construct: function(foo) {
+        alert(new foo.ctor("answer", 42).answer);
+        alert(new foo.fakector("answer", 42).answer);
+      },
+      indirect_eval: function(child) {
+        alert(child.eval("location.href"));
+        alert(new child.Function("x", "return x+1")(42));
+      },
+      funcalls: function(foo) {
+        var fn = foo.f;
+        alert(foo.f(2));
+        alert(fn.call.call(fn, foo, 3));
+      },
+      equality: function(child) {
+        var foo = child.foo,
+            self = foo.self;
+        alert("foo == self? " + (foo == self));
+        alert("foo === self? " + (foo === self));
+      }
+    }
+
+    function test_cpow() {
+      var child = getChildGlobal();
+      cpow_tests.construct(child.foo);
+      cpow_tests.resolve(child.location, "href hostname");
+      cpow_tests.iterate(child.location);
+      cpow_tests.iterate(child.foo);
+      cpow_tests.funcalls(child.foo);
+      cpow_tests.equality(child);
+    }
   </script>
 
   <toolbar id="controls">
     <toolbarbutton label="Back"/>
     <toolbarbutton label="Forward"/>
     <textbox onchange="loadURL(this.value)" flex="1" id="URL"/>
     <toolbarbutton onclick="restart()" label="Recover"/>
     <toolbarbutton onclick="randomClick()" label="random click"/>
     <toolbarbutton onclick="openWindow()" label="open new window"/>
     <toolbarbutton onclick="closeWindow()" label="close this window"/>
+    <toolbarbutton onclick="test_cpow()" label="CPOW"/>
   </toolbar>
 
-  <browser type="content" src="http://www.google.com/" flex="1" id="page" remote="true"
+  <browser type="content" src="http://people.mozilla.org/~bnewman/cpow/" flex="1" id="page" remote="true"
            onfocus="this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader.activateRemoteFrame();"/>
 </window>
diff --git a/ipc/ipdl/Makefile.in b/ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in
+++ b/ipc/ipdl/Makefile.in
@@ -55,16 +55,17 @@ EXPORT_LIBRARY = 1
 ##
 IPDLDIRS =  \
   dom/plugins  \
   dom/ipc  \
   netwerk/ipc  \
   netwerk/protocol/http/src  \
   ipc/ipdl/test/cxx  \
   ipc/testshell  \
+  js/src/ipc  \
   $(NULL)
 ##-----------------------------------------------------------------------------
 
 ifdef MOZ_IPDL_TESTS
 DIRS += test
 endif
 
 vpath %.ipdl $(topsrcdir)
diff --git a/ipc/ipdl/test/cxx/Makefile.in b/ipc/ipdl/test/cxx/Makefile.in
--- a/ipc/ipdl/test/cxx/Makefile.in
+++ b/ipc/ipdl/test/cxx/Makefile.in
@@ -54,16 +54,17 @@ EXPORTS_mozilla/_ipdltest =  \
 
 LIBRARY_NAME = $(MODULE)_s
 LIBXUL_LIBRARY = 1
 FORCE_STATIC_LIB = 1
 EXPORT_LIBRARY = 1
 
 # Please keep these organized in the order "easy"-to-"hard"
 IPDLTESTS = \
+  TestObjectWrapperLiaison \
   TestSanity  \
   TestRPCErrorCleanup \
   TestLatency \
   TestRPCRaces \
   TestManyChildAllocs  \
   TestDesc \
   TestShmem \
   TestShutdown \
diff --git a/ipc/ipdl/test/cxx/PTestObjectWrapperLiaison.ipdl b/ipc/ipdl/test/cxx/PTestObjectWrapperLiaison.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/PTestObjectWrapperLiaison.ipdl
@@ -0,0 +1,31 @@
+
+namespace mozilla {
+namespace _ipdltest {
+
+
+protocol PTestObjectWrapperLiaison {
+
+child:
+    Ping(int zero, float zeroPtFive);
+
+parent:
+    Pong(int one, float zeroPtTwoFive);
+
+both:
+    UNREACHED();
+
+
+state PING:
+    send Ping goto PONG;
+
+state PONG:
+    recv Pong goto DEAD;
+
+    // hmm ... maybe support this idiom natively?
+state DEAD:
+    send UNREACHED goto DEAD;
+};
+
+
+} // namespace mozilla
+} // namespace _ipdltest
diff --git a/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.cpp b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.cpp
@@ -0,0 +1,97 @@
+#include "TestObjectWrapperLiaison.h"
+
+#include "nsIAppShell.h"
+
+#include "nsCOMPtr.h"
+#include "nsServiceManagerUtils.h" // do_GetService()
+#include "nsWidgetsCID.h"       // NS_APPSHELL_CID
+
+#include "IPDLUnitTests.h"      // fail etc.
+
+namespace mozilla {
+namespace _ipdltest {
+
+//-----------------------------------------------------------------------------
+// parent
+
+TestObjectWrapperLiaisonParent::TestObjectWrapperLiaisonParent()
+{
+    MOZ_COUNT_CTOR(TestObjectWrapperLiaisonParent);
+}
+
+TestObjectWrapperLiaisonParent::~TestObjectWrapperLiaisonParent()
+{
+    MOZ_COUNT_DTOR(TestObjectWrapperLiaisonParent);
+}
+
+void
+TestObjectWrapperLiaisonParent::Main()
+{
+    if (!SendPing(0, 0.5f))
+        fail("sending Ping");
+}
+
+
+bool
+TestObjectWrapperLiaisonParent::RecvPong(const int& one, const float& zeroPtTwoFive)
+{
+    if (1 != one)
+        fail("invalid argument `%d', should have been `1'", one);
+
+    if (0.25f != zeroPtTwoFive)
+        fail("invalid argument `%g', should have been `0.25'", zeroPtTwoFive);
+
+    passed("sent ping/received pong");
+
+    static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
+    nsCOMPtr<nsIAppShell> appShell (do_GetService(kAppShellCID));
+    appShell->Exit();
+
+    return true;
+}
+
+bool
+TestObjectWrapperLiaisonParent::RecvUNREACHED()
+{
+    fail("unreached");
+    return false;               // not reached
+}
+
+
+//-----------------------------------------------------------------------------
+// child
+
+TestObjectWrapperLiaisonChild::TestObjectWrapperLiaisonChild()
+{
+    MOZ_COUNT_CTOR(TestObjectWrapperLiaisonChild);
+}
+
+TestObjectWrapperLiaisonChild::~TestObjectWrapperLiaisonChild()
+{
+    MOZ_COUNT_DTOR(TestObjectWrapperLiaisonChild);
+}
+
+bool
+TestObjectWrapperLiaisonChild::RecvPing(const int& zero, const float& zeroPtFive)
+{
+    if (0 != zero)
+        fail("invalid argument `%d', should have been `0'", zero);
+
+    if (0.5f != zeroPtFive)
+        fail("invalid argument `%g', should have been `0.5'", zeroPtFive);
+
+    if (!SendPong(1, 0.25f))
+        fail("sending Pong");
+    return true;
+}
+
+bool
+TestObjectWrapperLiaisonChild::RecvUNREACHED()
+{
+    fail("unreached");
+    return false;               // not reached
+}
+
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.h b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.h
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.h
@@ -0,0 +1,44 @@
+#ifndef mozilla__ipdltest_TestObjectWrapperLiaison_h
+#define mozilla__ipdltest_TestObjectWrapperLiaison_h 1
+
+
+#include "mozilla/_ipdltest/PTestObjectWrapperLiaisonParent.h"
+#include "mozilla/_ipdltest/PTestObjectWrapperLiaisonChild.h"
+
+namespace mozilla {
+namespace _ipdltest {
+
+
+class TestObjectWrapperLiaisonParent :
+    public PTestObjectWrapperLiaisonParent
+{
+public:
+    TestObjectWrapperLiaisonParent();
+    virtual ~TestObjectWrapperLiaisonParent();
+
+    void Main();
+
+protected:    
+    virtual bool RecvPong(const int& one, const float& zeroPtTwoFive);
+    virtual bool RecvUNREACHED();
+};
+
+
+class TestObjectWrapperLiaisonChild :
+    public PTestObjectWrapperLiaisonChild
+{
+public:
+    TestObjectWrapperLiaisonChild();
+    virtual ~TestObjectWrapperLiaisonChild();
+
+protected:
+    virtual bool RecvPing(const int& zero, const float& zeroPtFive);
+    virtual bool RecvUNREACHED();
+};
+
+
+} // namespace _ipdltest
+} // namespace mozilla
+
+
+#endif // ifndef mozilla__ipdltest_TestObjectWrapperLiaison_h
diff --git a/ipc/ipdl/test/cxx/ipdl.mk b/ipc/ipdl/test/cxx/ipdl.mk
--- a/ipc/ipdl/test/cxx/ipdl.mk
+++ b/ipc/ipdl/test/cxx/ipdl.mk
@@ -9,9 +9,10 @@ IPDLSRCS =					\
   PTestManyChildAllocsSub.ipdl			\
   PTestRPCErrorCleanup.ipdl			\
   PTestRPCRaces.ipdl				\
   PTestSanity.ipdl				\
   PTestShmem.ipdl				\
   PTestShutdown.ipdl				\
   PTestShutdownSub.ipdl				\
   PTestShutdownSubsub.ipdl			\
+  PTestObjectWrapperLiaison.ipdl				\
   $(NULL)
diff --git a/js/src/ipc/CPOWTypes.h b/js/src/ipc/CPOWTypes.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/CPOWTypes.h
@@ -0,0 +1,59 @@
+#ifndef mozilla_jsipc_ObjectWrapperLiaisonTypes_h__
+#define mozilla_jsipc_ObjectWrapperLiaisonTypes_h__
+
+#include "jsapi.h"
+#include "jspubtd.h"
+
+namespace mozilla {
+namespace jsipc {
+
+using namespace IPC;
+
+template <typename Type, typename As>
+struct CPOWConvertible
+{
+    static void Write(Message* m, const Type& t) {
+        WriteParam(m, As(t));
+    }
+    static bool Read(const Message* m, void** iter, Type* tp) {
+        As a;
+        return (ReadParam(m, iter, &a) &&
+                (*tp = Type(a), true));
+    }
+};
+
+struct void_t {};
+struct null_t {};
+    
+template <typename P>
+struct CPOWSingleton
+{
+    static void Write(Message*, const P&) {}
+    static bool Read(const Message*, void**, P*) { return true; }
+};
+    
+} // namespace jsipc
+} // namespace mozilla
+
+namespace IPC {
+
+using namespace mozilla::jsipc;
+
+template <> struct ParamTraits<void_t> : public CPOWSingleton<void_t> {};
+template <> struct ParamTraits<null_t> : public CPOWSingleton<null_t> {};
+
+template <> struct ParamTraits<JSType> : public CPOWConvertible<JSType, int> {};
+ 
+}
+
+#if 1
+#define CLOG(PRINTF_ARGS) \
+    PR_BEGIN_MACRO        \
+    printf PRINTF_ARGS ;  \
+    fflush(0);            \
+    PR_END_MACRO
+#else
+#define CLOG(_)
+#endif
+
+#endif
diff --git a/js/src/ipc/Makefile.in b/js/src/ipc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/Makefile.in
@@ -0,0 +1,70 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#   The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = js
+LIBRARY_NAME = jsipc_s
+LIBXUL_LIBRARY = 1
+FORCE_STATIC_LIB = 1
+EXPORT_LIBRARY = 1
+
+EXPORTS_NAMESPACES = mozilla/jsipc
+
+EXPORTS_mozilla/jsipc = \
+  CPOWTypes.h \
+  ObjectWrapperLiaisonChild.h \
+  ObjectWrapperLiaisonParent.h \
+  ObjectWrapperParent.h \
+  ObjectWrapperChild.h \
+  $(NULL)
+
+CPPSRCS = \
+  ObjectWrapperParent.cpp \
+  ObjectWrapperChild.cpp \
+  $(NULL)
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/ipc/chromium/chromium-config.mk
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DBIN_SUFFIX='"$(BIN_SUFFIX)"'
diff --git a/js/src/ipc/ObjectWrapperChild.cpp b/js/src/ipc/ObjectWrapperChild.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperChild.cpp
@@ -0,0 +1,476 @@
+#include "mozilla/jsipc/ObjectWrapperLiaisonChild.h"
+#include "mozilla/jsipc/ObjectWrapperChild.h"
+
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace jsipc {
+
+ObjectWrapperChild::ObjectWrapperChild(JSContext* cx, JSObject* obj)
+    : mContext(cx)
+    , mObj(obj)
+{
+    JSAutoRequest request(mContext);
+    JS_AddNamedRoot(mContext, (void*)&mObj,
+                    "mozilla::jsipc::ObjectWrapperChild-rooted JSObject*");
+}
+
+ObjectWrapperChild::~ObjectWrapperChild()
+{
+    JSAutoRequest request(mContext);
+    JS_RemoveRoot(mContext, (void*)&mObj);
+}
+
+bool
+ObjectWrapperChild::JSObject_to_JSVariant(JSContext* cx, JSObject* from,
+                                          JSVariant* to)
+{
+    *to = Manager()->GetOrCreateWrapper(from);
+    return true;
+}
+
+bool
+ObjectWrapperChild::jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_FUNCTION:
+    case JSTYPE_OBJECT:
+        return JSObject_to_JSVariant(cx, JSVAL_TO_OBJECT(from), to);
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = *JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+        return true;
+    case JSTYPE_XML:
+        // fall through
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperChild::
+JSObject_from_PObjectWrapperChild(JSContext*,
+                                  const PObjectWrapperChild* from,
+                                  JSObject** to)
+{
+    const ObjectWrapperChild* owc =
+        static_cast<const ObjectWrapperChild*>(from);
+    *to = owc ? owc->mObj : JSVAL_NULL;
+    return true;
+}
+    
+/*static*/ bool
+ObjectWrapperChild::JSObject_from_JSVariant(JSContext* cx,
+                                            const JSVariant& from,
+                                            JSObject** to)
+{
+    if (from.type() != JSVariant::TPObjectWrapperChild)
+        return false;
+    return JSObject_from_PObjectWrapperChild(cx,
+                                             from.get_PObjectWrapperChild(),
+                                             to);
+}
+
+/*static*/ bool
+ObjectWrapperChild::jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                         jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPObjectWrapperChild:
+        {
+            JSObject* obj;
+            if (!JSObject_from_JSVariant(cx, from, &obj))
+                return false;
+            *to = OBJECT_TO_JSVAL(obj);
+            return true;
+        }
+    case JSVariant::TnsString:
+        {
+            const nsString& str = from.get_nsString();
+            JSString* s = JS_NewUCStringCopyN(cx,
+                                              str.BeginReading(),
+                                              str.Length());
+            if (!s)
+                return false;
+            *to = STRING_TO_JSVAL(s);
+        }
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+    
+ObjectWrapperLiaisonChild*
+ObjectWrapperChild::Manager()
+{
+    PObjectWrapperLiaisonChild* powlc = PObjectWrapperChild::Manager();
+    return static_cast<ObjectWrapperLiaisonChild*>(powlc);
+}
+
+static bool
+jsid_to_nsString(JSContext* cx, jsid from, nsString* to)
+{
+    jsval v;
+    if (JS_IdToValue(cx, from, &v) && JSVAL_IS_STRING(v)) {
+        *to = JS_GetStringChars(JSVAL_TO_STRING(v));
+        return true;
+    }
+    return false;
+}
+    
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    JSString* str = JS_NewUCStringCopyN(cx, from.BeginReading(), from.Length());
+    return JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+bool
+ObjectWrapperChild::AnswerAddProperty(const nsString& id)
+{
+    jsid interned_id;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+    
+    JS_DefinePropertyById(mContext, mObj, interned_id, JSVAL_VOID,
+                          NULL, NULL, 0);
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerGetProperty(const nsString& id,
+                                      bool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = false;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    *ok = JS_GetPropertyById(mContext, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(mContext, *ok ? val : JSVAL_VOID, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerSetProperty(const nsString& id, const JSVariant& v,
+                                      bool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = false;
+    *vp = v;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id) ||
+        !jsval_from_JSVariant(mContext, v, &val))
+        return false;
+
+    *ok = JS_SetPropertyById(mContext, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(mContext, *ok ? val : JSVAL_VOID, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerDelProperty(const nsString& id,
+                                      bool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = false;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    *ok = JS_DeletePropertyById2(mContext, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(mContext, *ok ? val : JSVAL_VOID, vp);
+}
+
+static const PRUint32 sIdArraySlot = 0, sNextIdIndexSlot = 1;
+static const PRUint32 sNumNewEnumerateStateSlots = 2;
+
+static void
+CPOW_NewEnumerateState_Finalize(JSContext* cx, JSObject* state)
+{
+    jsval v;
+    JSIdArray* ids;
+    if (JS_GetReservedSlot(cx, state, sIdArraySlot, &v) &&
+        (ids = static_cast<JSIdArray*>(JSVAL_TO_PRIVATE(v))))
+        JS_DestroyIdArray(cx, ids);
+}
+
+// Similar to IteratorClass in XPCWrapper.cpp
+static const JSClass sCPOW_NewEnumerateState_JSClass = {
+    "CPOW NewEnumerate State",
+    JSCLASS_HAS_RESERVED_SLOTS(sNumNewEnumerateStateSlots),
+    JS_PropertyStub,  JS_PropertyStub,
+    JS_PropertyStub,  JS_PropertyStub,
+    JS_EnumerateStub, JS_ResolveStub,
+    JS_ConvertStub,   CPOW_NewEnumerateState_Finalize,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+#if 0
+bool
+ObjectWrapperChild::AnswerSomething(/* in-parameters */
+                                    /* out-parameters */)
+{
+    // variable declarations
+    // infallible failure initializations
+    JSAutoRequest request(mContext);
+    // validate in-parameters, or return false
+    // successfully perform local JS operations, or return true
+    // prepare out-parameters
+    return true;
+}
+#endif
+
+bool
+ObjectWrapperChild::AnswerEnumerate(/* no in-parameters */
+                                    bool* ok, nsTArray<nsString>* ids)
+{
+    JSAutoRequest request(mContext);
+    JSIdArray* ida = JS_Enumerate(mContext, mObj);
+    if (!ids->SetCapacity(ida->length))
+        return *ok = false;
+    for (int i = 0; i < ida->length; ++i)
+        jsid_to_nsString(mContext, ida->vector[i], ids->AppendElement());
+    JS_DestroyIdArray(mContext, ida);
+    return *ok = true;
+}
+    
+bool
+ObjectWrapperChild::AnswerNewEnumerateInit(/* no in-parameters */
+                                           bool* ok, JSVariant* statep, int* idp)
+{
+    *ok = false;
+    *idp = 0;
+
+    JSAutoRequest request(mContext);
+
+    JSClass* clasp = const_cast<JSClass*>(&sCPOW_NewEnumerateState_JSClass);
+    JSObject* state = JS_NewObjectWithGivenProto(mContext, clasp, NULL, NULL);
+    if (!state)
+        return false;
+    
+    for (JSObject* proto = mObj;
+         proto;
+         proto = JS_GetPrototype(mContext, proto))
+    {
+        JSIdArray* ids = JS_Enumerate(mContext, proto);
+        for (jsint i = 0; i < ids->length; ++i)
+            JS_DefinePropertyById(mContext, state, ids->vector[i], JSVAL_VOID,
+                                  NULL, NULL, JSPROP_ENUMERATE | JSPROP_SHARED);
+        JS_DestroyIdArray(mContext, ids);
+    }
+
+    JSIdArray* ids = JS_Enumerate(mContext, state);
+    if (!ids)
+        return false;
+
+    *idp = ids->length;
+
+    *ok = (JS_SetReservedSlot(mContext, state, sIdArraySlot,
+                              PRIVATE_TO_JSVAL(ids)) &&
+           JS_SetReservedSlot(mContext, state, sNextIdIndexSlot,
+                              JSVAL_ZERO) &&
+           JSObject_to_JSVariant(mContext, state, statep));
+
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerNewEnumerateNext(const JSVariant& in_state,
+                                           bool* ok, JSVariant* statep, nsString* idp)
+{
+    JSObject* state;
+    jsval v;
+    JSIdArray* ids;
+    JSString* str;
+
+    *ok = false;
+    *statep = in_state;
+    *idp = EmptyString();
+    
+    JSAutoRequest request(mContext);
+
+    if (!JSObject_from_JSVariant(mContext, in_state, &state) ||
+        !JS_GetReservedSlot(mContext, state, sIdArraySlot, &v) ||
+        !(ids = static_cast<JSIdArray*>(JSVAL_TO_PRIVATE(v))) ||
+        !JS_GetReservedSlot(mContext, state, sNextIdIndexSlot, &v))
+        return false;
+
+    int i = JSVAL_TO_INT(v);
+    if (i >= ids->length) {
+        *ok = true;
+        return JSObject_to_JSVariant(mContext, NULL, statep);
+    }
+
+    if (!JS_IdToValue(mContext, ids->vector[i], &v) ||
+        !(str = JS_ValueToString(mContext, v)))
+    {
+        *ok = false;
+        return true;
+    }
+
+    *idp = JS_GetStringChars(str);
+    *ok = JS_SetReservedSlot(mContext, state, sNextIdIndexSlot,
+                             INT_TO_JSVAL(i + 1));
+    return true;
+}
+    
+bool
+ObjectWrapperChild::RecvNewEnumerateDestroy(const JSVariant& in_state)
+{
+    JSObject* state;
+    JSAutoRequest request(mContext);
+    return (JSObject_from_JSVariant(mContext, in_state, &state) &&
+            JS_SetReservedSlot(mContext, state, sIdArraySlot, JSVAL_ZERO));
+}
+
+bool
+ObjectWrapperChild::AnswerIterator(/* no in-parameters */
+                                   PObjectWrapperChild** iterator)
+{
+    JSAutoRequest request(mContext);
+    JSObject* iterObj = JS_NewPropertyIterator(mContext, mObj);
+    *iterator = Manager()->GetOrCreateWrapper(iterObj);
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerNewResolve(const nsString& id, const int& flags,
+                                     bool* ok, PObjectWrapperChild** obj2)
+{
+    jsid interned_id;
+    
+    *ok = false;
+    *obj2 = NULL;
+    
+    JSAutoRequest request(mContext);
+
+    printf("new-resolving \"%s\"...\n", NS_ConvertUTF16toUTF8(id).get());
+    fflush(0);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    JSPropertyDescriptor desc;
+    if (!JS_GetPropertyDescriptorById(mContext, mObj, interned_id, flags, &desc))
+        return true;
+
+    *ok = true;
+
+    if (desc.obj)
+        *obj2 = Manager()->GetOrCreateWrapper(desc.obj);
+
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerConvert(const JSType& type,
+                                  bool* ok, JSVariant* vp)
+{
+    jsval v;
+    JSAutoRequest request(mContext);
+    *ok = JS_ConvertValue(mContext, OBJECT_TO_JSVAL(mObj), type, &v);
+    return jsval_to_JSVariant(mContext, *ok ? v : JSVAL_VOID, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerCall(PObjectWrapperChild* receiver, const nsTArray<JSVariant>& argv,
+                               bool* ok, JSVariant* rval)
+{
+    *ok = false;
+    
+    JSAutoRequest request(mContext);
+
+    JSObject* obj;
+    if (!JSObject_from_PObjectWrapperChild(mContext, receiver, &obj))
+        return false;
+
+    jsval rv, jsargs[argv.Length()];
+    for (PRUint32 i = 0; i < argv.Length(); ++i)
+        if (!jsval_from_JSVariant(mContext, argv.ElementAt(i), jsargs + i))
+            return false;
+
+    *ok = JS_CallFunctionValue(mContext, obj, OBJECT_TO_JSVAL(mObj),
+                               argv.Length(), jsargs, &rv);
+
+    return jsval_to_JSVariant(mContext, *ok ? rv : JSVAL_VOID, rval);
+}
+
+bool
+ObjectWrapperChild::AnswerConstruct(const nsTArray<JSVariant>& argv,
+                                    bool* ok, PObjectWrapperChild** rval)
+{
+    JSAutoRequest request(mContext);
+
+    JSClass* clasp = NULL;
+    JSObject* pobj = JSVAL_NULL;
+    {
+        jsval pval;
+        if (JS_GetProperty(mContext, mObj, "prototype", &pval) &&
+            JSVAL_IS_OBJECT(pval))
+        {
+            pobj = JSVAL_TO_OBJECT(pval);
+            clasp = JS_GetClass(mContext, pobj);
+        }
+    }
+    JSObject* obj = JS_NewObject(mContext, clasp, pobj, NULL);
+    PObjectWrapperChild* wrapper = Manager()->GetOrCreateWrapper(obj);
+
+    JSVariant override;
+    bool answer = AnswerCall(*rval = wrapper,
+                             argv, ok, &override);
+    if (answer &&
+        override.type() == JSVariant::TPObjectWrapperChild &&
+        (wrapper = override.get_PObjectWrapperChild()))
+        *rval = wrapper;
+
+    return answer;
+}
+
+}}
diff --git a/js/src/ipc/ObjectWrapperChild.h b/js/src/ipc/ObjectWrapperChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperChild.h
@@ -0,0 +1,83 @@
+#ifndef mozilla_jsipc_ObjectWrapperChild_h__
+#define mozilla_jsipc_ObjectWrapperChild_h__
+
+#include "mozilla/jsipc/PObjectWrapperChild.h"
+
+using mozilla::jsipc::JSVariant;
+
+namespace mozilla {
+namespace jsipc {
+
+class ObjectWrapperLiaisonChild;
+  
+class ObjectWrapperChild
+    : public PObjectWrapperChild
+{
+public:
+
+    ObjectWrapperChild(JSContext* cx, JSObject* obj);
+    ~ObjectWrapperChild();
+
+    JSObject* GetJSObject() const { return mObj; }
+    
+private:
+
+    JSContext* const mContext;
+    JSObject* const mObj;
+
+    bool JSObject_to_JSVariant(JSContext* cx, JSObject* from, JSVariant* to);
+    bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+
+    static bool JSObject_from_PObjectWrapperChild(JSContext* cx,
+                                                  const PObjectWrapperChild* from,
+                                                  JSObject** to);
+    static bool JSObject_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                        JSObject** to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+
+    ObjectWrapperLiaisonChild* Manager();
+
+protected:
+
+    bool AnswerAddProperty(const nsString& id);
+
+    bool AnswerGetProperty(const nsString& id,
+                           bool* ok, JSVariant* vp);
+
+    bool AnswerSetProperty(const nsString& id, const JSVariant& v,
+                           bool* ok, JSVariant* vp);
+
+    bool AnswerDelProperty(const nsString& id,
+                           bool* ok, JSVariant* vp);
+
+    bool AnswerEnumerate(/* no in-parameters */
+                         bool* ok, nsTArray<nsString>* ids);
+    
+    bool AnswerNewEnumerateInit(/* no in-parameters */
+                                bool* ok, JSVariant* statep, int* idp);
+
+    bool AnswerNewEnumerateNext(const JSVariant& in_state,
+                                bool* ok, JSVariant* statep, nsString* idp);
+
+    bool RecvNewEnumerateDestroy(const JSVariant& in_state);
+
+    bool AnswerIterator(/* no in-parameters */
+                        PObjectWrapperChild** iterator);
+    
+    bool AnswerNewResolve(const nsString& id, const int& flags,
+                          bool* ok, PObjectWrapperChild** obj2);
+
+    bool AnswerConvert(const JSType& type,
+                       bool* ok, JSVariant* vp);
+
+    bool AnswerCall(PObjectWrapperChild* receiver, const nsTArray<JSVariant>& argv,
+                    bool* ok, JSVariant* rval);
+
+    bool AnswerConstruct(const nsTArray<JSVariant>& argv,
+                         bool* ok, PObjectWrapperChild** rval);
+};
+
+}}
+  
+#endif
diff --git a/js/src/ipc/ObjectWrapperLiaisonChild.h b/js/src/ipc/ObjectWrapperLiaisonChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperLiaisonChild.h
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set sw=4 ts=8 et tw=80 : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_ObjectWrapperLiaisonChild_h__
+#define mozilla_jsipc_ObjectWrapperLiaisonChild_h__
+
+#include "mozilla/jsipc/PObjectWrapperLiaisonChild.h"
+#include "mozilla/jsipc/ObjectWrapperChild.h"
+
+#include "jsapi.h"
+#include "nsClassHashtable.h"
+#include "nsHashKeys.h"
+
+namespace mozilla {
+namespace jsipc {
+
+class ObjectWrapperLiaisonChild
+    : public PObjectWrapperLiaisonChild
+{
+public:
+
+    ObjectWrapperLiaisonChild(JSContext* cx)
+        : mContext(cx)
+    {
+        mResidentObjectTable.Init();
+    }
+
+    PObjectWrapperChild* GetOrCreateWrapper(JSObject* obj,
+                                            bool attachAsGlobal = false)
+    {
+        if (!obj) // Don't wrap nothin'!
+            return NULL;
+        PObjectWrapperChild* wrapper;
+        while (!mResidentObjectTable.Get(obj, &wrapper))
+            mResidentObjectTable.Put(obj, SendPObjectWrapperConstructor(AllocPObjectWrapper(obj),
+                                                                        attachAsGlobal));
+        return wrapper;
+    }
+    
+    PObjectWrapperChild* GetOrCreateGlobalWrapper() {
+        return GetOrCreateWrapper(JS_GetGlobalObject(mContext), true);
+    }
+    
+protected:
+
+    PObjectWrapperChild* AllocPObjectWrapper(JSObject* obj) {
+        return new ObjectWrapperChild(mContext, obj);
+    }
+    
+    PObjectWrapperChild* AllocPObjectWrapper(const bool&) {
+        return AllocPObjectWrapper(JS_GetGlobalObject(mContext));
+    }
+
+    bool DeallocPObjectWrapper(PObjectWrapperChild* actor) {
+        ObjectWrapperChild* owc = static_cast<ObjectWrapperChild*>(actor);
+        mResidentObjectTable.Remove(owc->GetJSObject());
+        return true;
+    }
+
+private:
+    
+    JSContext* const mContext;
+
+    nsClassHashtable<nsPtrHashKey<JSObject>,
+                     PObjectWrapperChild> mResidentObjectTable;
+
+};
+
+}}
+
+#endif
diff --git a/js/src/ipc/ObjectWrapperLiaisonParent.h b/js/src/ipc/ObjectWrapperLiaisonParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperLiaisonParent.h
@@ -0,0 +1,91 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set sw=4 ts=8 et tw=80 : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_ObjectWrapperLiaisonParent_h__
+#define mozilla_jsipc_ObjectWrapperLiaisonParent_h__
+
+#include "mozilla/jsipc/PObjectWrapperLiaisonParent.h"
+#include "mozilla/jsipc/ObjectWrapperParent.h"
+
+#include "jsapi.h"
+
+namespace mozilla {
+namespace jsipc {
+    
+class ObjectWrapperLiaisonParent
+    : public PObjectWrapperLiaisonParent
+{
+public:
+
+    bool AttachGlobal(JSContext* cx, JSObject* to, jsid id)
+    {
+        return (mGlobal &&
+                JS_DefinePropertyById(cx, to, id, mGlobal->GetJSVal(cx), NULL,
+                                      NULL, 0));
+    }
+
+private:
+
+    ObjectWrapperParent* mGlobal;
+
+    PObjectWrapperParent* AllocPObjectWrapper(const bool&) {
+        return new ObjectWrapperParent();
+    }
+
+    bool RecvPObjectWrapperConstructor(PObjectWrapperParent* actor,
+                                       const bool& attachAsGlobal)
+    {
+        // TODO implement a notion of "reparenting"
+        if (attachAsGlobal)
+            mGlobal = static_cast<ObjectWrapperParent*>(actor);
+        return true;
+    }
+
+    bool DeallocPObjectWrapper(PObjectWrapperParent* actor)
+    {
+        // TODO what if actor == mGlobal?
+        delete actor;
+        return true;
+    }
+
+};
+
+}}
+
+#endif
diff --git a/js/src/ipc/ObjectWrapperParent.cpp b/js/src/ipc/ObjectWrapperParent.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperParent.cpp
@@ -0,0 +1,612 @@
+#include "mozilla/jsipc/ObjectWrapperParent.h"
+#include "mozilla/jsipc/CPOWTypes.h"
+
+#include "jsobj.h"
+
+namespace mozilla {
+namespace jsipc {
+
+namespace {
+
+    typedef ObjectWrapperParent _;
+
+    static const uintN sFlagsSlot = 0, sWrappedObjSlot = 1;
+    static const uintN sNumSlots = 2;
+    static const uintN CPOW_FLAG_RESOLVING = 1;
+
+    class AutoResolveFlag
+    {
+        JSContext* mContext;
+        JSObject* mObj;
+        uintN mOldFlags;
+
+        static uintN GetFlags(JSContext* cx, JSObject* obj) {
+            jsval v;
+            if (JS_GetReservedSlot(cx, obj, sFlagsSlot, &v))
+                return JSVAL_TO_INT(v);
+            return 0;
+        }
+        static uintN SetFlags(JSContext* cx, JSObject* obj, uintN flags) {
+            uintN oldFlags = GetFlags(cx, obj);
+            if (oldFlags != flags)
+                JS_SetReservedSlot(cx, obj, sFlagsSlot, INT_TO_JSVAL(flags));
+            return oldFlags;
+        }
+    public:
+        AutoResolveFlag(JSContext* cx,
+                        JSObject* obj)
+            : mContext(cx)
+            , mObj(obj)
+            , mOldFlags(SetFlags(cx, obj,
+                                 GetFlags(cx, obj) | CPOW_FLAG_RESOLVING))
+        {}
+        ~AutoResolveFlag() { SetFlags(mContext, mObj, mOldFlags); }
+        static JSBool IsSet(JSContext* cx, JSObject* obj) {
+            return GetFlags(cx, obj) & CPOW_FLAG_RESOLVING;
+        }
+    };
+
+}
+
+const JSExtendedClass _::sCPOW_JSClass = {
+    // JSClass (JSExtendedClass.base) initialization
+    { "CrossProcessObjectWrapper",
+      JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_IS_EXTENDED |
+      JSCLASS_HAS_RESERVED_SLOTS(sNumSlots),
+      _::CPOW_AddProperty,
+      _::CPOW_DelProperty,
+      _::CPOW_GetProperty,
+      _::CPOW_SetProperty,
+      (JSEnumerateOp) _::CPOW_NewEnumerate,
+        (JSResolveOp) _::CPOW_NewResolve,
+      _::CPOW_Convert,
+      _::CPOW_Finalize,
+      nsnull, // getObjectOps
+      nsnull, // checkAccess
+      _::CPOW_Call,
+      _::CPOW_Construct,
+      nsnull, // xdrObject
+      _::CPOW_HasInstance,
+      nsnull, // mark
+      nsnull, // reserveSlots
+    },
+
+    // JSExtendedClass initialization
+    _::CPOW_Equality,
+    nsnull, // outerObject
+    nsnull, // innerObject
+    nsnull, // _::CPOW_Iterator,
+    nsnull, // wrappedObject
+    JSCLASS_NO_RESERVED_MEMBERS
+};
+
+void
+ObjectWrapperParent::ActorDestroy(ActorDestroyReason)
+{
+    *mObjSlotContents = NULL;
+}
+    
+JSObject*
+ObjectWrapperParent::GetJSObject(JSContext* cx) const
+{
+    JSClass* clasp = const_cast<JSClass*>(&_::sCPOW_JSClass.base);
+    if (!mObj) {
+        mObj = JS_NewObjectWithGivenProto(cx, clasp, NULL, NULL);
+        *mObjSlotContents = this;
+        JS_SetReservedSlot(cx, mObj, sWrappedObjSlot,
+                           PRIVATE_TO_JSVAL(mObjSlotContents));
+        JS_SetReservedSlot(cx, mObj, sFlagsSlot, JSVAL_ZERO);
+    }
+    return mObj;
+}
+
+static ObjectWrapperParent*
+Unwrap(JSContext* cx, JSObject* obj)
+{
+    while (STOBJ_GET_CLASS(obj) != &_::sCPOW_JSClass.base)
+        if (!(obj = STOBJ_GET_PROTO(obj)))
+            return NULL;
+    
+    jsval info;
+
+    if (!JS_GetReservedSlot(cx, obj, sWrappedObjSlot, &info))
+        return NULL;
+
+    ObjectWrapperParent* self =
+        *static_cast<ObjectWrapperParent**>(JSVAL_TO_PRIVATE(info));
+
+    NS_ASSERTION(!self || self->GetJSObject(cx) == obj,
+                 "Wrapper and wrapped object disagree?");
+    
+    return self;
+}
+
+/*static*/ bool
+ObjectWrapperParent::jsval_to_JSVariant(JSContext* cx, jsval from,
+                                        JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_OBJECT:
+        {
+            PObjectWrapperParent* powp;
+            if (!JSObject_to_PObjectWrapperParent(cx, JSVAL_TO_OBJECT(from), &powp))
+                return false;
+            *to = powp;
+            return true;
+        }
+    case JSTYPE_FUNCTION:
+        return false; // TODO allow iff CPOW?
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = *JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+    case JSTYPE_XML:
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperParent::jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                          jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPObjectWrapperParent:
+        return jsval_from_PObjectWrapperParent(cx, from.get_PObjectWrapperParent(), to);
+    case JSVariant::TnsString:
+        *to = STRING_TO_JSVAL(JS_NewUCStringCopyZ(cx, from.get_nsString().BeginReading()));
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperParent::
+JSObject_to_PObjectWrapperParent(JSContext* cx, JSObject* from,
+                                 PObjectWrapperParent** to)
+{
+    ObjectWrapperParent* owp = Unwrap(cx, from);
+    if (!owp)
+        return false;
+    *to = owp;
+    return true;
+}
+
+/*static*/ bool
+ObjectWrapperParent::
+JSObject_from_PObjectWrapperParent(JSContext* cx,
+                                   const PObjectWrapperParent* from,
+                                   JSObject** to)
+{
+    const ObjectWrapperParent* owp =
+        static_cast<const ObjectWrapperParent*>(from);
+    *to = owp
+        ? owp->GetJSObject(cx)
+        : JSVAL_TO_OBJECT(JSVAL_NULL);
+    return true;
+}
+
+/*static*/ bool
+ObjectWrapperParent::
+jsval_from_PObjectWrapperParent(JSContext* cx,
+                                const PObjectWrapperParent* from,
+                                jsval* to)
+{
+    JSObject* obj;
+    if (!JSObject_from_PObjectWrapperParent(cx, from, &obj))
+        return false;
+    *to = OBJECT_TO_JSVAL(obj);
+    return true;
+}
+    
+static bool
+jsid_from_int(JSContext* cx, int from, jsid* to)
+{
+    // TODO check the outparams more generally
+    if (!to)
+        return true;
+    jsval v = INT_TO_JSVAL(from);
+    return JS_ValueToId(cx, v, to);
+}
+
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    if (!to)
+        return true;
+    JSString* str = JS_NewUCStringCopyZ(cx, from.BeginReading());
+    return JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+static bool
+jsval_to_nsString(JSContext* cx, jsval from, nsString* to)
+{
+    JSString* str;
+    if ((str = JS_ValueToString(cx, from))) {
+        *to = JS_GetStringChars(str);
+        return true;
+    }
+    return false;
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_AddProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CLOG(("Calling CPOW_AddProperty...\n"));
+
+    // Unwrap always has to come first!
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    if (AutoResolveFlag::IsSet(cx, obj))
+        return JS_TRUE;
+    
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    return self->CallAddProperty(in_id);
+}    
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_GetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CLOG(("Calling CPOW_GetProperty...\n"));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_v;
+    
+    return (self->CallGetProperty(in_id,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_SetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CLOG(("Calling CPOW_SetProperty...\n"));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+    JSVariant in_v;
+
+    if (!jsval_to_nsString(cx, id, &in_id) ||
+        !self->jsval_to_JSVariant(cx, *vp, &in_v))
+        return JS_FALSE;
+    
+    bool out_ok;
+    JSVariant out_v;
+
+    return (self->CallSetProperty(in_id, in_v,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}    
+    
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_DelProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CLOG(("Calling CPOW_DelProperty...\n"));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_v;
+    
+    return (self->CallDelProperty(in_id,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_v, vp));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Enumerate(JSContext* cx, JSObject* obj)
+{
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    bool out_ok;
+    nsTArray<nsString> out_ids;
+    
+    if (self->CallEnumerate(&out_ok, &out_ids) && out_ok) {
+        AutoResolveFlag arf(cx, obj);
+        jsid interned_id;
+        for (PRUint32 i = 0; i < out_ids.Length(); i++)
+            // Apparently the enumerate hook gets used during GC (by
+            // js_CloseNativeIterator), so we can't do any JS allocation!
+            if (jsid_from_nsString(cx, out_ids.ElementAt(i), &interned_id))
+                JS_DefinePropertyById(cx, obj, interned_id, JSVAL_VOID, NULL, NULL,
+                                      JSPROP_ENUMERATE | JSPROP_SHARED);
+        return JS_TRUE;
+    }
+    return JS_FALSE;
+}
+
+JSBool
+ObjectWrapperParent::NewEnumerateInit(JSContext* cx, jsval* statep, jsid* idp)
+{
+    bool out_ok;
+    JSVariant out_state;
+    int out_id;
+
+    return (CallNewEnumerateInit(&out_ok, &out_state, &out_id) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_state, statep) &&
+            jsid_from_int(cx, out_id, idp));
+}
+
+JSBool
+ObjectWrapperParent::NewEnumerateNext(JSContext* cx, jsval* statep, jsid* idp)
+{
+    JSVariant in_state;
+    if (!jsval_to_JSVariant(cx, *statep, &in_state))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_state;
+    nsString out_id;
+
+    if (CallNewEnumerateNext(in_state,
+                             &out_ok, &out_state, &out_id) &&
+        out_ok &&
+        jsval_from_JSVariant(cx, out_state, statep) &&
+        jsid_from_nsString(cx, out_id, idp))
+    {
+        JSObject* obj = GetJSObject(cx);
+        AutoResolveFlag arf(cx, obj);
+        return JS_DefinePropertyById(cx, obj, *idp, JSVAL_VOID, NULL, NULL,
+                                     JSPROP_ENUMERATE);
+    }
+    return JS_FALSE;
+}
+
+JSBool
+ObjectWrapperParent::NewEnumerateDestroy(JSContext* cx, jsval state)
+{
+    JSVariant in_state;
+    if (!jsval_to_JSVariant(cx, state, &in_state))
+        return JS_FALSE;
+
+    return SendNewEnumerateDestroy(in_state);
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_NewEnumerate(JSContext *cx, JSObject *obj,
+                                       JSIterateOp enum_op, jsval *statep,
+                                       jsid *idp)
+{
+    CLOG(("Calling CPOW_NewEnumerate...\n"));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;    
+
+    switch (enum_op) {
+    case JSENUMERATE_INIT:
+        return self->NewEnumerateInit(cx, statep, idp);
+    case JSENUMERATE_NEXT:
+        return self->NewEnumerateNext(cx, statep, idp);
+    case JSENUMERATE_DESTROY:
+        return self->NewEnumerateDestroy(cx, *statep);
+    }
+
+    return JS_FALSE;
+}
+
+/*static*/ JSObject*
+ObjectWrapperParent::CPOW_Iterator(JSContext *cx, JSObject *obj,
+                                   JSBool keysonly)
+{
+    CLOG(("Calling CPOW_Iterator...\n"));
+    
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    PObjectWrapperParent* iterator;
+    if (self->CallIterator(&iterator) && iterator)
+        return static_cast<ObjectWrapperParent*>(iterator)->GetJSObject(cx);
+
+    return JSVAL_NULL;
+}
+    
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_NewResolve(JSContext *cx, JSObject *obj, jsval id,
+                                     uintN flags, JSObject **objp)
+{
+    CLOG(("Calling CPOW_NewResolve (%s)...\n",
+         JS_GetTypeName(cx, JS_TypeOfValue(cx, id))));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    PObjectWrapperParent* out_pobj;
+
+    if (!self->CallNewResolve(in_id, flags,
+                              &out_ok, &out_pobj) ||
+        !out_ok ||
+        !JSObject_from_PObjectWrapperParent(cx, out_pobj, objp))
+        return JS_FALSE;
+
+    jsid interned_id;
+    if (*objp &&
+        JS_ValueToId(cx, id, &interned_id)) {
+        AutoResolveFlag arf(cx, *objp);
+        JS_DefinePropertyById(cx, *objp, interned_id, JSVAL_VOID, NULL, NULL,
+                              JSPROP_ENUMERATE);
+    }
+    return JS_TRUE;
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Convert(JSContext *cx, JSObject *obj, JSType type,
+                                  jsval *vp)
+{
+    CLOG(("Calling CPOW_Convert (%s)...\n",
+          JS_GetTypeName(cx, type)));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_v;
+
+    return (self->CallConvert(type,
+                              &out_ok, &out_v) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_v, vp));
+}
+    
+/*static*/ void
+ObjectWrapperParent::CPOW_Finalize(JSContext* cx, JSObject* obj)
+{
+    CLOG(("Calling CPOW_Finalize...\n"));
+    
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (self)
+        ObjectWrapperParent::Send__delete__(self);
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Call(JSContext* cx, JSObject* obj, uintN argc,
+                               jsval* argv, jsval* rval)
+{
+    CLOG(("Calling CPOW_Call...\n"));
+
+    ObjectWrapperParent* receiver = Unwrap(cx, obj);
+    if (!receiver)
+        return JS_FALSE;
+    
+    ObjectWrapperParent* function =
+        Unwrap(cx, JSVAL_TO_OBJECT(JS_ARGV_CALLEE(argv)));
+    if (!function)
+        return JS_FALSE;
+
+    nsTArray<JSVariant> in_argv(argc);
+    for (uintN i = 0; i < argc; i++)
+        if (!jsval_to_JSVariant(cx, argv[i], in_argv.AppendElement()))
+            return JS_FALSE;
+    
+    bool out_ok;
+    JSVariant out_rval;
+
+    return (function->CallCall(receiver, in_argv,
+                               &out_ok, &out_rval) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_rval, rval));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Construct(JSContext *cx, JSObject *obj, uintN argc,
+                                    jsval *argv, jsval *rval)
+{
+    CLOG(("Calling CPOW_Construct...\n"));
+    
+    ObjectWrapperParent* constructor =
+        Unwrap(cx, JSVAL_TO_OBJECT(JS_ARGV_CALLEE(argv)));
+    if (!constructor)
+        return JS_FALSE;
+
+    nsTArray<JSVariant> in_argv(argc);
+    for (uintN i = 0; i < argc; i++)
+        if (!jsval_to_JSVariant(cx, argv[i], in_argv.AppendElement()))
+            return JS_FALSE;
+
+    bool out_ok;
+    PObjectWrapperParent* out_powp;
+
+    return (constructor->CallConstruct(in_argv,
+                                       &out_ok, &out_powp) &&
+            out_ok &&
+            jsval_from_PObjectWrapperParent(cx, out_powp, rval));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Equality(JSContext *cx, JSObject *obj, jsval v,
+                                   JSBool *bp)
+{
+    CLOG(("Calling CPOW_Equality...\n"));
+
+    *bp = JS_FALSE;
+    
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    if (JSVAL_IS_PRIMITIVE(v))
+        return JS_TRUE;
+
+    ObjectWrapperParent* other = Unwrap(cx, JSVAL_TO_OBJECT(v));
+    if (!other)
+        return JS_TRUE;
+
+    *bp = (self == other);
+    
+    return JS_TRUE;
+}
+
+}}
diff --git a/js/src/ipc/ObjectWrapperParent.h b/js/src/ipc/ObjectWrapperParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperParent.h
@@ -0,0 +1,108 @@
+#ifndef mozilla_jsipc_ObjectWrapperParent_h__
+#define mozilla_jsipc_ObjectWrapperParent_h__
+
+#include "mozilla/jsipc/PObjectWrapperParent.h"
+#include "jsapi.h"
+#include "nsAutoJSValHolder.h"
+
+namespace mozilla {
+namespace jsipc {
+
+class ObjectWrapperParent
+    : public PObjectWrapperParent
+{
+public:
+
+    ObjectWrapperParent()
+        : mObj(NULL)
+        , mObjSlotContents(new ObjectWrapperParent const*(NULL))
+    {}
+    
+    JSObject* GetJSObject(JSContext* cx) const;
+
+    jsval GetJSVal(JSContext* cx) const {
+        return OBJECT_TO_JSVAL(GetJSObject(cx));
+    }
+
+    static const JSExtendedClass sCPOW_JSClass;    
+    
+protected:
+
+    void ActorDestroy(ActorDestroyReason why);
+
+private:
+
+    mutable JSObject* mObj;
+    ObjectWrapperParent const** const mObjSlotContents;
+
+    static JSBool
+    CPOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    CPOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    CPOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+    
+    static JSBool
+    CPOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool CPOW_Enumerate(JSContext* cx, JSObject* obj);
+    
+    JSBool NewEnumerateInit(JSContext* cx, jsval* statep, jsid* idp);
+    JSBool NewEnumerateNext(JSContext* cx, jsval* statep, jsid* idp);
+    JSBool NewEnumerateDestroy(JSContext* cx, jsval state);
+    static JSBool
+    CPOW_NewEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
+                      jsval *statep, jsid *idp);
+
+    static JSObject*
+    CPOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
+    
+    static JSBool
+    CPOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
+                    JSObject **objp);
+
+    static JSBool
+    CPOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
+
+    static void
+    CPOW_Finalize(JSContext* cx, JSObject* obj);
+
+    static JSBool
+    CPOW_Call(JSContext* cx, JSObject* obj, uintN argc, jsval* argv,
+              jsval* rval);
+
+    static JSBool
+    CPOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                   jsval *rval);
+    
+    static JSBool
+    CPOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
+    {
+        printf("Calling CPOW_HasInstance...\n"); fflush(0);
+        return JS_TRUE;
+    }
+
+    static JSBool
+    CPOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
+
+    static bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+    static bool
+    JSObject_to_PObjectWrapperParent(JSContext* cx, JSObject* from,
+                                     PObjectWrapperParent** to);
+    static bool
+    JSObject_from_PObjectWrapperParent(JSContext* cx,
+                                       const PObjectWrapperParent* from,
+                                       JSObject** to);
+    static bool
+    jsval_from_PObjectWrapperParent(JSContext* cx,
+                                    const PObjectWrapperParent* from,
+                                    jsval* to);
+};
+
+}}
+  
+#endif
diff --git a/js/src/ipc/PObjectWrapper.ipdl b/js/src/ipc/PObjectWrapper.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PObjectWrapper.ipdl
@@ -0,0 +1,82 @@
+include protocol "PObjectWrapperLiaison.ipdl";
+
+include "mozilla/jsipc/CPOWTypes.h";
+
+using mozilla::jsipc::void_t;
+using mozilla::jsipc::null_t;
+using JSType;
+
+namespace mozilla {
+namespace jsipc {
+
+union JSVariant {
+    void_t;
+    nullable PObjectWrapper;
+    nsString;
+    int;
+    double;
+    bool;
+    null_t;
+};
+
+rpc protocol PObjectWrapper
+{
+    manager PObjectWrapperLiaison;
+    
+child:
+    __delete__(); // unroot
+
+    rpc AddProperty(nsString id);
+
+    rpc GetProperty(nsString id)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc SetProperty(nsString id,
+                    JSVariant v)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc DelProperty(nsString id)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc Enumerate()
+        returns (bool ok,
+                 nsString[] ids);
+                 
+    rpc NewEnumerateInit()
+        returns (bool ok,
+                 JSVariant statep,
+                 int idp);
+
+    rpc NewEnumerateNext(JSVariant in_state)
+        returns (bool ok,
+                 JSVariant statep,
+                 nsString idp);
+
+    async NewEnumerateDestroy(JSVariant in_state);
+
+    rpc Iterator()
+        returns (PObjectWrapper iterator);
+    
+    rpc NewResolve(nsString id,
+                   int flags)
+        returns (bool ok,
+                 nullable PObjectWrapper obj2);
+
+    rpc Convert(JSType type)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc Call(PObjectWrapper receiver,
+             JSVariant[] argv)
+        returns (bool ok,
+                 JSVariant rval);
+
+    rpc Construct(JSVariant[] argv)
+        returns (bool ok,
+                 PObjectWrapper rval);
+};
+
+}}
diff --git a/js/src/ipc/PObjectWrapperLiaison.ipdl b/js/src/ipc/PObjectWrapperLiaison.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PObjectWrapperLiaison.ipdl
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 8 -*- */
+/* vim: set sw=4 ts=8 et tw=80 ft=cpp : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol "PContentProcess.ipdl";
+include protocol "PObjectWrapper.ipdl";
+
+namespace mozilla {
+namespace jsipc {
+
+rpc protocol PObjectWrapperLiaison
+{
+    manager PContentProcess;
+    manages PObjectWrapper;
+parent:
+    __delete__();
+    sync PObjectWrapper(bool attachAsGlobal);
+};
+
+}}
diff --git a/js/src/ipc/ipdl.mk b/js/src/ipc/ipdl.mk
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ipdl.mk
@@ -0,0 +1,41 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#   The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+IPDLSRCS = \
+  PObjectWrapperLiaison.ipdl \
+  PObjectWrapper.ipdl \
+  $(NULL)
diff --git a/js/src/ipc/jar.mn b/js/src/ipc/jar.mn
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/jar.mn
@@ -0,0 +1,3 @@
+toolkit.jar:
+        content/global/cpow/test.xul (tests/adhoc/test.xul)
+        content/global/cpow/child.html (tests/adhoc/child.html)
diff --git a/js/src/ipc/tests/adhoc/child.html b/js/src/ipc/tests/adhoc/child.html
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/tests/adhoc/child.html
@@ -0,0 +1,26 @@
+<html>
+  <head>
+  </head>
+  <body>
+    <script>
+      window.foo = {
+        a: 42,
+	b: 37 * 73,
+        ctor: function(name, value) {
+	  this[name] = value;
+        },
+	fakector: function(name, value) {
+	  window[name] = "oyez";
+	  this[name] = value;
+	  return window;
+        },
+        f: function(x) { 
+	  document.body.appendChild(document.createElement("div")).innerHTML = "called f(" + x + ")";
+	  return x + Math.PI;
+	}
+      };
+      window.foo.self = window.foo;
+    </script>
+    oyez
+  </body>
+</html>
diff --git a/js/src/ipc/tests/adhoc/test.xul b/js/src/ipc/tests/adhoc/test.xul
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/tests/adhoc/test.xul
@@ -0,0 +1,78 @@
+<?xml version="1.0"?>
+<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
+<window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        width="800" height="600" orient="vertical">
+
+  <script type="application/javascript">
+
+    function getChildGlobal() {
+      var page = document.getElementById("page");
+      if (!("contentGlobalObject" in page))
+        page.QueryInterface(Components.interfaces.nsIFrameLoaderOwner)
+            .frameLoader.attachChildGlobal(page, "contentGlobalObject");
+      return page.contentGlobalObject;
+    }
+
+    var cpow_tests = {
+      resolve: function(obj, keys) {
+        alert("resolving");
+        keys = keys.split(" ");
+        for (var i = 0; i != keys.length; ++i)
+          alert("has " + keys[i] + "? " + (keys[i] in obj));
+        alert("done resolving");
+      },
+      iterate: function(obj) {
+        alert("iterating");
+        for (var k in obj)
+          alert("key: " + k);
+        alert("done iterating");
+      },
+      navigate: function(child) {
+        alert("navigating");
+        child.location = prompt("Where to?");
+        setTimeout(function() {
+          alert(child.location.href);
+        }, 2000);
+      },
+      construct: function(foo) {
+        alert(new foo.ctor("answer", 42).answer);
+        alert(new foo.fakector("answer", 42).answer);
+      },
+      indirect_eval: function(child) {
+        alert(child.eval("location.href"));
+        alert(new child.Function("x", "return x+1")(42));
+      },
+      funcalls: function(foo) {
+        var fn = foo.f;
+        alert(foo.f(2));
+        alert(fn.call.call(fn, foo, 3));
+      },
+      equality: function(child) {
+        var foo = child.foo,
+            self = foo.self;
+        alert("foo == self? " + (foo == self));
+        alert("foo === self? " + (foo === self));
+      }
+    }
+
+    function test_cpow() {
+      var child = getChildGlobal();
+      cpow_tests.construct(child.foo);
+      cpow_tests.resolve(child.location, "href hostname");
+      cpow_tests.iterate(child.location);
+      cpow_tests.iterate(child.foo);
+      cpow_tests.funcalls(child.foo);
+      cpow_tests.equality(child);
+    }
+  </script>
+
+  <toolbar id="controls">
+    <toolbarbutton onclick="test_cpow()" label="Run tests."/>
+  </toolbar>
+
+  <browser remote="true" width="200" height="200"
+           type="content"
+           src="child.html"
+           id="page" />
+
+</window>
diff --git a/toolkit/library/libxul-config.mk b/toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk
+++ b/toolkit/library/libxul-config.mk
@@ -88,16 +88,17 @@ RCFLAGS += -i $(topsrcdir)/widget/src/os
 endif
 
 LOCAL_INCLUDES += -I$(topsrcdir)/widget/src/os2
 endif
 
 # dependent libraries
 ifdef MOZ_IPC
 STATIC_LIBS += \
+  jsipc_s \
   domipc_s \
   domplugins_s \
   mozipc_s \
   mozipdlgen_s \
   chromium_s \
   ipcshell_s \
   gfxipc_s \
   $(NULL)
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -203,16 +203,20 @@ MAKEFILES_xpconnect="
   js/src/xpconnect/loader/Makefile
   js/src/xpconnect/tests/Makefile
   js/src/xpconnect/tests/components/Makefile
   js/src/xpconnect/tests/idl/Makefile
   js/src/xpconnect/tools/Makefile
   js/src/xpconnect/tools/idl/Makefile
 "
 
+MAKEFILES_jsipc="
+  js/src/ipc/Makefile
+"
+
 MAKEFILES_jsdebugger="
   js/jsd/Makefile
   js/jsd/idl/Makefile
 "
 
 MAKEFILES_jsctypes="
   js/ctypes/Makefile
 "
@@ -851,16 +855,17 @@ add_makefiles "
   $MAKEFILES_db
   $MAKEFILES_dom
   $MAKEFILES_editor
   $MAKEFILES_xmlparser
   $MAKEFILES_gfx
   $MAKEFILES_htmlparser
   $MAKEFILES_intl
   $MAKEFILES_xpconnect
+  $MAKEFILES_jsipc
   $MAKEFILES_jsdebugger
   $MAKEFILES_jsctypes
   $MAKEFILES_content
   $MAKEFILES_layout
   $MAKEFILES_libimg
   $MAKEFILES_libjar
   $MAKEFILES_libreg
   $MAKEFILES_libpref
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -76,17 +76,17 @@ ifeq ($(OS_ARCH),WINCE)
 tier_external_dirs += modules/lib7z
 endif
 
 #
 # tier "gecko" - core components
 #
 
 ifdef MOZ_IPC
-tier_gecko_dirs += ipc
+tier_gecko_dirs += ipc js/src/ipc
 endif
 
 tier_gecko_dirs += \
 		$(tier_necko_dirs) \
 		js/src/xpconnect \
 		js/ctypes \
 		intl/chardet \
 		$(NULL)
