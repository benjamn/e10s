# HG changeset patch
# User Ben Newman <bnewman@mozilla.com>
# Date 1257540219 28800
# Node ID a82312ef8ffd49051c380264ad70c05b5948c643
# Parent  69674697dbce469745f1baaccb507cca27afd1e8
Bug 516522 - CPOW: Cross-Process Object Wrapper.

diff --git a/content/base/public/nsIFrameLoader.idl b/content/base/public/nsIFrameLoader.idl
--- a/content/base/public/nsIFrameLoader.idl
+++ b/content/base/public/nsIFrameLoader.idl
@@ -37,16 +37,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
 interface nsIDocShell;
 interface nsIURI;
 interface nsIFrame;
+interface nsIVariant;
 
 [scriptable, uuid(8f94788d-ec69-4220-971c-0fd68d47b80f)]
 interface nsIFrameLoader : nsISupports
 {
   /**
    * Get the docshell from the frame loader.
    */
   readonly attribute nsIDocShell docShell;
@@ -99,16 +100,22 @@ interface nsIFrameLoader : nsISupports
                                   in long aClickCount,
                                   in long aModifiers,
                                   [optional] in boolean aIgnoreRootScrollFrame);
 
   /**
    * Activate event forwarding from client (remote frame) to parent.
    */
   void activateFrameEvent(in AString aType, in boolean capture);
+
+  /**
+   * Define a property on |where| named |property| whose value is a JSObject
+   * corresponding to the global object of the child frame.
+   */
+  void attachChildGlobal(in nsIVariant where, in AString property);
 };
 
 native alreadyAddRefed_nsFrameLoader(already_AddRefed<nsFrameLoader>);
 
 [scriptable, uuid(8f3b12a0-35ae-4e0d-9152-8e0d7e49d446)]
 interface nsIFrameLoaderOwner : nsISupports
 {
   /**
diff --git a/content/base/src/nsFrameLoader.cpp b/content/base/src/nsFrameLoader.cpp
--- a/content/base/src/nsFrameLoader.cpp
+++ b/content/base/src/nsFrameLoader.cpp
@@ -108,16 +108,19 @@
 #ifdef MOZ_IPC
 #include "ContentProcessParent.h"
 #include "TabParent.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 #endif
 
+#include "nsIXPConnect.h"
+#include "nsIJSContextStack.h"
+
 class nsAsyncDocShellDestroyer : public nsRunnable
 {
 public:
   nsAsyncDocShellDestroyer(nsIDocShell* aDocShell)
     : mDocShell(aDocShell)
   {
   }
 
@@ -1508,16 +1511,42 @@ nsFrameLoader::ActivateFrameEvent(const 
   if (mChildProcess) {
     mChildProcess->SendactivateFrameEvent(nsString(aType), aCapture);
     return NS_OK;
   }
 #endif
   return NS_ERROR_FAILURE;
 }
 
+NS_IMETHODIMP
+nsFrameLoader::AttachChildGlobal(nsIVariant* where,
+                                 const nsAString& property)
+{
+  nsIXPConnect* xpc;
+  nsIThreadJSContextStack* stack;
+  JSContext* cx;
+  jsval v;
+  JSObject* obj;
+  JSString* str;
+  jsid interned_id;
+
+  if ((xpc = nsContentUtils::XPConnect()) &&
+      (stack = nsContentUtils::ThreadJSContextStack()) &&
+      NS_SUCCEEDED(stack->Peek(&cx)) && cx &&
+      NS_SUCCEEDED(xpc->VariantToJS(cx, JS_GetScopeChain(cx), where, &v)) &&
+      JS_ValueToObject(cx, v, &obj) &&
+      (str = JS_NewUCStringCopyN(cx, property.BeginReading(),
+                                 property.Length())) &&
+      JS_ValueToId(cx, STRING_TO_JSVAL(str), &interned_id) &&
+      mChildProcess->AttachGlobal(cx, obj, interned_id))
+    return NS_OK;
+
+  return NS_ERROR_FAILURE;
+}
+
 nsresult
 nsFrameLoader::CreateStaticClone(nsIFrameLoader* aDest)
 {
   nsFrameLoader* dest = static_cast<nsFrameLoader*>(aDest);
   dest->MaybeCreateDocShell();
   NS_ENSURE_STATE(dest->mDocShell);
 
   nsCOMPtr<nsIDOMDocument> dummy = do_GetInterface(dest->mDocShell);
diff --git a/dom/ipc/PContentProcess.ipdl b/dom/ipc/PContentProcess.ipdl
--- a/dom/ipc/PContentProcess.ipdl
+++ b/dom/ipc/PContentProcess.ipdl
@@ -40,17 +40,17 @@ include protocol "PIFrameEmbedding.ipdl"
 include protocol "PTestShell.ipdl";
 include protocol "PNecko.ipdl";
 
 include "mozilla/TabTypes.h";
 
 namespace mozilla {
 namespace dom {
 
-sync protocol PContentProcess
+rpc protocol PContentProcess
 {
     manages PIFrameEmbedding;
     manages PTestShell;
     manages PNecko;
 
 child:
     PIFrameEmbedding();
 
diff --git a/dom/ipc/PIFrameEmbedding.ipdl b/dom/ipc/PIFrameEmbedding.ipdl
--- a/dom/ipc/PIFrameEmbedding.ipdl
+++ b/dom/ipc/PIFrameEmbedding.ipdl
@@ -34,42 +34,49 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol "PContentProcess.ipdl";
 include protocol "PDocumentRenderer.ipdl";
+include protocol "PObjectWrapperLiaison.ipdl";
+include protocol "PObjectWrapper.ipdl";
 
 include "mozilla/TabTypes.h";
 include "TabMessageUtils.h";
+include "mozilla/jsipc/CPOWTypes.h";
 
 using MagicWindowHandle;
 using RemoteDOMEvent;
 
 namespace mozilla {
 namespace dom {
 
-async protocol PIFrameEmbedding
+rpc protocol PIFrameEmbedding
 {
     manager PContentProcess;
     manages PDocumentRenderer;
+    manages PObjectWrapperLiaison;
 
 child:
     __delete__();
 
 parent:
     /**
      * When child sends this message, parent should move focus to
      * the next or previous focusable element.
      */
     moveFocus(bool forward);
 
     sendEvent(RemoteDOMEvent aEvent);
+
+    PObjectWrapperLiaison();
+
 child:
     createWidget(MagicWindowHandle parentWidget);
 
     loadURL(nsCString uri);
 
     move(PRUint32 x,
          PRUint32 y,
          PRUint32 width,
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -50,16 +50,22 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMWindowUtils.h"
 #include "nsISupportsImpl.h"
 #include "nsIWebBrowserFocus.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 
+#include "mozilla/jsipc/ObjectWrapperLiaisonChild.h"
+#include "nsIDocument.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIScriptContext.h"
+#include "jscntxt.h"
+
 #ifdef MOZ_WIDGET_GTK2
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 #endif
 
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS1(ContentListener, nsIDOMEventListener)
@@ -300,16 +306,19 @@ TabChild::RecvloadURL(const nsCString& u
     printf("loading %s, %d\n", uri.get(), NS_IsMainThread());
 
     nsresult rv = mWebNav->LoadURI(NS_ConvertUTF8toUTF16(uri).get(),
                                    nsIWebNavigation::LOAD_FLAGS_NONE,
                                    NULL, NULL, NULL);
     if (NS_FAILED(rv)) {
         NS_WARNING("mWebNav->LoadURI failed. Eating exception, what else can I do?");
     }
+
+    SendPObjectWrapperLiaisonConstructor()->SendPObjectWrapperConstructor(true);
+    
     return true;
 }
 
 bool
 TabChild::Recvmove(const PRUint32& x,
                      const PRUint32& y,
                      const PRUint32& width,
                      const PRUint32& height)
@@ -342,16 +351,94 @@ TabChild::RecvsendMouseEvent(const nsStr
   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(mWebNav);
   nsCOMPtr<nsIDOMWindowUtils> utils = do_GetInterface(window);
   NS_ENSURE_TRUE(utils, true);
   utils->SendMouseEvent(aType, aX, aY, aButton, aClickCount, aModifiers,
                         aIgnoreRootScrollFrame);
   return true;
 }
 
+#include "nsIScriptGlobalObjectOwner.h"
+
+mozilla::jsipc::PObjectWrapperLiaisonChild*
+TabChild::AllocPObjectWrapperLiaison()
+{
+#if 0
+    nsCOMPtr<nsIDocShell> docShell;
+    nsCOMPtr<nsIScriptGlobalObjectOwner> owner;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+    JSContext* cx;
+
+    if ((docShell = do_QueryInterface(mWebNav)) &&
+        (owner = do_QueryInterface(mWebNav)) &&
+        (global = owner->GetScriptGlobalObject()) &&
+        (context = do_QueryInterface(global->GetContext())) &&
+        (cx = static_cast<JSContext*>(context->GetNativeContext())))
+        return mObjectWrapperLiaison = new mozilla::jsipc::ObjectWrapperLiaisonChild(cx);
+
+    return NULL;
+#endif
+    
+#if 0
+    nsCOMPtr<nsIJSRuntimeService>
+        rtsvc(do_GetService("@mozilla.org/js/xpc/RuntimeService;1"));
+    JSRuntime* rt;
+    JSContext* cx;
+    if (NS_SUCCEEDED(rtsvc->GetRuntime(&rt)) &&
+        (cx = JS_NewContext(rt, 1<<10)))
+        return mObjectWrapperLiaison = new mozilla::jsipc::ObjectWrapperLiaisonChild(cx);
+    return NULL;
+#endif
+    
+#if 1
+    nsCOMPtr<nsIDOMDocument> domDocument;
+    nsCOMPtr<nsIDocument> document;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+    JSContext* cx;
+
+    if (NS_SUCCEEDED(mWebNav->GetDocument(getter_AddRefs(domDocument))) &&
+        (document = do_QueryInterface(domDocument)) &&
+        (global = do_QueryInterface(document->GetScriptGlobalObject())) &&
+        (context = do_QueryInterface(global->GetContext())) &&
+        (cx = static_cast<JSContext*>(context->GetNativeContext())))
+        return mObjectWrapperLiaison = new mozilla::jsipc::ObjectWrapperLiaisonChild(cx);
+
+    return NULL;
+#endif
+
+#if 0
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    nsCOMPtr<nsIDOMWindow> domWindow;
+    nsCOMPtr<nsIDOMDocument> domDocument;
+    nsCOMPtr<nsIDocument> document;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+    JSContext* cx;
+    if ((webBrowser = do_QueryInterface(mWebNav)) &&
+        (NS_SUCCEEDED(webBrowser->GetContentDOMWindow(getter_AddRefs(domWindow)))) &&
+        (NS_SUCCEEDED(domWindow->GetDocument(getter_AddRefs(domDocument)))) &&
+        (document = do_QueryInterface(domDocument)) &&
+        (global = do_QueryInterface(document->GetScriptGlobalObject())) &&
+        (context = do_QueryInterface(global->GetContext())) &&
+        (cx = static_cast<JSContext*>(context->GetNativeContext()))) {
+        return mObjectWrapperLiaison = new mozilla::jsipc::ObjectWrapperLiaisonChild(cx);
+    }
+    return NULL;
+#endif
+}
+
+bool
+TabChild::DeallocPObjectWrapperLiaison(mozilla::jsipc::PObjectWrapperLiaisonChild* actor)
+{
+    delete actor;
+    return true;
+}
+
 mozilla::ipc::PDocumentRendererChild*
 TabChild::AllocPDocumentRenderer(
         const PRInt32& x,
         const PRInt32& y,
         const PRInt32& w,
         const PRInt32& h,
         const nsString& bgcolor,
         const PRUint32& flags,
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -44,16 +44,19 @@
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 #include "nsIWebBrowserChrome2.h"
 #include "nsIEmbeddingSiteWindow2.h"
 #include "nsIWebBrowserChromeFocus.h"
 #include "nsIDOMEventListener.h"
 #include "nsIDOMEventTarget.h"
 
+#include "mozilla/jsipc/ObjectWrapperLiaisonChild.h"
+#include "mozilla/jsipc/PObjectWrapperLiaisonChild.h"
+
 namespace mozilla {
 namespace dom {
 
 class TabChild;
 
 class ContentListener : public nsIDOMEventListener
 {
 public:
@@ -111,18 +114,23 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
 
+protected:
+    mozilla::jsipc::PObjectWrapperLiaisonChild* AllocPObjectWrapperLiaison();
+    bool DeallocPObjectWrapperLiaison(mozilla::jsipc::PObjectWrapperLiaisonChild*);
+    
 private:
     nsCOMPtr<nsIWebNavigation> mWebNav;
+    mozilla::jsipc::ObjectWrapperLiaisonChild* mObjectWrapperLiaison;
 
     DISALLOW_EVIL_CONSTRUCTORS(TabChild);
 };
 
 }
 }
 
 #endif // mozilla_tabs_TabChild_h
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -46,30 +46,39 @@
 #include "nsCOMPtr.h"
 #include "nsServiceManagerUtils.h"
 #include "nsIDOMElement.h"
 #include "nsEventDispatcher.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 
+#include "mozilla/jsipc/ObjectWrapperLiaisonParent.h"
+
 using mozilla::ipc::BrowserProcessSubThread;
 using mozilla::ipc::DocumentRendererParent;
 
 namespace mozilla {
 namespace dom {
 
 TabParent::TabParent()
 {
 }
 
 TabParent::~TabParent()
 {
 }
 
+void
+TabParent::SetOwnerElement(nsIDOMElement* aElement)
+{
+    if (mFrameElement != aElement)
+        mFrameElement = aElement;
+}
+
 bool
 TabParent::RecvmoveFocus(const bool& aForward)
 {
   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
   if (fm) {
     nsCOMPtr<nsIDOMElement> dummy;
     PRUint32 type = aForward ? nsIFocusManager::MOVEFOCUS_FORWARD
                              : nsIFocusManager::MOVEFOCUS_BACKWARD;
@@ -109,16 +118,29 @@ TabParent::Move(PRUint32 x, PRUint32 y, 
 }
 
 void
 TabParent::Activate()
 {
     Sendactivate();
 }
 
+mozilla::jsipc::PObjectWrapperLiaisonParent*
+TabParent::AllocPObjectWrapperLiaison()
+{
+    return mObjectWrapperLiaison = new mozilla::jsipc::ObjectWrapperLiaisonParent();
+}
+
+bool
+TabParent::DeallocPObjectWrapperLiaison(mozilla::jsipc::PObjectWrapperLiaisonParent* actor)
+{
+    delete actor;
+    return true;
+}
+
 mozilla::ipc::PDocumentRendererParent*
 TabParent::AllocPDocumentRenderer(const PRInt32& x,
         const PRInt32& y, const PRInt32& w, const PRInt32& h, const nsString& bgcolor,
         const PRUint32& flags, const bool& flush)
 {
     return new DocumentRendererParent();
 }
 
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -37,29 +37,32 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_tabs_TabParent_h
 #define mozilla_tabs_TabParent_h
 
 #include "mozilla/dom/PIFrameEmbeddingParent.h"
 
 #include "mozilla/ipc/GeckoChildProcessHost.h"
+#include "mozilla/jsipc/ObjectWrapperLiaisonParent.h"
+
+#include "jsapi.h"
 
 class nsIURI;
 class nsIDOMElement;
 
 namespace mozilla {
 namespace dom {
 
 class TabParent : public PIFrameEmbeddingParent
 {
 public:
     TabParent();
     virtual ~TabParent();
-    void SetOwnerElement(nsIDOMElement* aElement) { mFrameElement = aElement; }
+    void SetOwnerElement(nsIDOMElement* aElement);
 
     virtual bool RecvmoveFocus(const bool& aForward);
     virtual bool RecvsendEvent(const RemoteDOMEvent& aEvent);
 
     void LoadURL(nsIURI* aURI);
     void Move(PRUint32 x, PRUint32 y, PRUint32 width, PRUint32 height);
     void Activate();
     void SendMouseEvent(const nsAString& aType, float aX, float aY,
@@ -70,16 +73,26 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
     virtual bool DeallocPDocumentRenderer(PDocumentRendererParent* actor);
+
+    mozilla::jsipc::PObjectWrapperLiaisonParent* AllocPObjectWrapperLiaison();
+    bool DeallocPObjectWrapperLiaison(mozilla::jsipc::PObjectWrapperLiaisonParent*);
+
+    bool AttachGlobal(JSContext* cx, JSObject* to, jsid id) {
+        return (mObjectWrapperLiaison &&
+                mObjectWrapperLiaison->AttachGlobal(cx, to, id));
+    }       
+
 protected:
     nsIDOMElement* mFrameElement;
+    mozilla::jsipc::ObjectWrapperLiaisonParent* mObjectWrapperLiaison;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif
diff --git a/dom/ipc/test.xul b/dom/ipc/test.xul
--- a/dom/ipc/test.xul
+++ b/dom/ipc/test.xul
@@ -1,13 +1,13 @@
 <?xml version="1.0"?>
 <?xml-stylesheet href="chrome://global/skin" type="text/css"?>
 <window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         width="800" height="800" orient="vertical">
-  <script>
+  <script type="application/javascript;version=1.7">
 
     function dumpClientRect(r) {
       dump(r.left + "," + r.top + "," + r.right + "," +
            r.bottom + "," + r.width + "," + r.height + "\n");
     }
 
     function handleMozAfterPaint(e) {
       return;
@@ -72,23 +72,63 @@
 
     function openWindow() {
       window.open('chrome://global/content/test-ipc.xul', '_blank', 'chrome,resizable,width=800,height=800');
     }
     
     function closeWindow() {
       window.close();
     }
+
+    function getChildGlobal() {
+      var page = document.getElementById("page");
+      if (!("contentGlobalObject" in page))
+        page.QueryInterface(Components.interfaces.nsIFrameLoaderOwner)
+            .frameLoader.attachChildGlobal(page, "contentGlobalObject");
+      return page.contentGlobalObject;
+    }
+
+    function resolve(obj, keys) {
+      keys = keys.split(" ");
+      for (var i = 0; i != keys.length; ++i)
+        alert(obj[keys[i]]);
+    }
+    
+    function iterate(obj) {
+      try {
+        for (var k in obj)
+          alert(k);
+      } catch (x) {
+        alert(x);
+      }
+    }
+
+    function navigate(child) {
+      child.location = prompt("Where to?");
+      setTimeout(function() {
+        alert(child.location.href);
+      }, 2000);
+    }
+    
+    function show() {
+      var child = getChildGlobal(),
+          loc = child.location;
+      resolve(loc, "href foo hash");
+      alert(loc.href);
+      iterate(loc);
+      navigate(child);
+    }
   </script>
 
   <toolbar id="controls">
     <toolbarbutton label="Back"/>
     <toolbarbutton label="Forward"/>
     <textbox onchange="loadURL(this.value)" flex="1" id="URL"/>
     <toolbarbutton onclick="restart()" label="Recover"/>
     <toolbarbutton onclick="randomClick()" label="random click"/>
     <toolbarbutton onclick="openWindow()" label="open new window"/>
     <toolbarbutton onclick="closeWindow()" label="close this window"/>
+    <toolbarbutton onclick="show()" label="CPOW"/>
   </toolbar>
 
   <browser type="content" src="http://www.google.com/" flex="1" id="page" remote="true"
            onfocus="this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader.activateRemoteFrame();"/>
 </window>
diff --git a/ipc/ipdl/Makefile.in b/ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in
+++ b/ipc/ipdl/Makefile.in
@@ -55,16 +55,17 @@ EXPORT_LIBRARY = 1
 ##
 IPDLDIRS =  \
   dom/plugins  \
   dom/ipc  \
   netwerk/ipc  \
   netwerk/protocol/http/src  \
   ipc/ipdl/test/cxx  \
   ipc/testshell  \
+  js/src/ipc  \
   $(NULL)
 ##-----------------------------------------------------------------------------
 
 ifdef MOZ_IPDL_TESTS
 DIRS += test
 endif
 
 vpath %.ipdl $(topsrcdir)
diff --git a/ipc/ipdl/test/cxx/Makefile.in b/ipc/ipdl/test/cxx/Makefile.in
--- a/ipc/ipdl/test/cxx/Makefile.in
+++ b/ipc/ipdl/test/cxx/Makefile.in
@@ -54,16 +54,17 @@ EXPORTS_mozilla/_ipdltest =  \
 
 LIBRARY_NAME = $(MODULE)_s
 LIBXUL_LIBRARY = 1
 FORCE_STATIC_LIB = 1
 EXPORT_LIBRARY = 1
 
 # Please keep these organized in the order "easy"-to-"hard"
 IPDLTESTS = \
+  TestObjectWrapperLiaison \
   TestSanity  \
   TestLatency \
   TestRPCRaces \
   TestManyChildAllocs  \
   TestDesc \
   TestShmem \
   TestShutdown \
   TestArrays \
diff --git a/ipc/ipdl/test/cxx/PTestObjectWrapperLiaison.ipdl b/ipc/ipdl/test/cxx/PTestObjectWrapperLiaison.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/PTestObjectWrapperLiaison.ipdl
@@ -0,0 +1,31 @@
+
+namespace mozilla {
+namespace _ipdltest {
+
+
+protocol PTestObjectWrapperLiaison {
+
+child:
+    Ping(int zero, float zeroPtFive);
+
+parent:
+    Pong(int one, float zeroPtTwoFive);
+
+both:
+    UNREACHED();
+
+
+state PING:
+    send Ping goto PONG;
+
+state PONG:
+    recv Pong goto DEAD;
+
+    // hmm ... maybe support this idiom natively?
+state DEAD:
+    send UNREACHED goto DEAD;
+};
+
+
+} // namespace mozilla
+} // namespace _ipdltest
diff --git a/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.cpp b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.cpp
@@ -0,0 +1,97 @@
+#include "TestObjectWrapperLiaison.h"
+
+#include "nsIAppShell.h"
+
+#include "nsCOMPtr.h"
+#include "nsServiceManagerUtils.h" // do_GetService()
+#include "nsWidgetsCID.h"       // NS_APPSHELL_CID
+
+#include "IPDLUnitTests.h"      // fail etc.
+
+namespace mozilla {
+namespace _ipdltest {
+
+//-----------------------------------------------------------------------------
+// parent
+
+TestObjectWrapperLiaisonParent::TestObjectWrapperLiaisonParent()
+{
+    MOZ_COUNT_CTOR(TestObjectWrapperLiaisonParent);
+}
+
+TestObjectWrapperLiaisonParent::~TestObjectWrapperLiaisonParent()
+{
+    MOZ_COUNT_DTOR(TestObjectWrapperLiaisonParent);
+}
+
+void
+TestObjectWrapperLiaisonParent::Main()
+{
+    if (!SendPing(0, 0.5f))
+        fail("sending Ping");
+}
+
+
+bool
+TestObjectWrapperLiaisonParent::RecvPong(const int& one, const float& zeroPtTwoFive)
+{
+    if (1 != one)
+        fail("invalid argument `%d', should have been `1'", one);
+
+    if (0.25f != zeroPtTwoFive)
+        fail("invalid argument `%g', should have been `0.25'", zeroPtTwoFive);
+
+    passed("sent ping/received pong");
+
+    static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
+    nsCOMPtr<nsIAppShell> appShell (do_GetService(kAppShellCID));
+    appShell->Exit();
+
+    return true;
+}
+
+bool
+TestObjectWrapperLiaisonParent::RecvUNREACHED()
+{
+    fail("unreached");
+    return false;               // not reached
+}
+
+
+//-----------------------------------------------------------------------------
+// child
+
+TestObjectWrapperLiaisonChild::TestObjectWrapperLiaisonChild()
+{
+    MOZ_COUNT_CTOR(TestObjectWrapperLiaisonChild);
+}
+
+TestObjectWrapperLiaisonChild::~TestObjectWrapperLiaisonChild()
+{
+    MOZ_COUNT_DTOR(TestObjectWrapperLiaisonChild);
+}
+
+bool
+TestObjectWrapperLiaisonChild::RecvPing(const int& zero, const float& zeroPtFive)
+{
+    if (0 != zero)
+        fail("invalid argument `%d', should have been `0'", zero);
+
+    if (0.5f != zeroPtFive)
+        fail("invalid argument `%g', should have been `0.5'", zeroPtFive);
+
+    if (!SendPong(1, 0.25f))
+        fail("sending Pong");
+    return true;
+}
+
+bool
+TestObjectWrapperLiaisonChild::RecvUNREACHED()
+{
+    fail("unreached");
+    return false;               // not reached
+}
+
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.h b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.h
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestObjectWrapperLiaison.h
@@ -0,0 +1,44 @@
+#ifndef mozilla__ipdltest_TestObjectWrapperLiaison_h
+#define mozilla__ipdltest_TestObjectWrapperLiaison_h 1
+
+
+#include "mozilla/_ipdltest/PTestObjectWrapperLiaisonParent.h"
+#include "mozilla/_ipdltest/PTestObjectWrapperLiaisonChild.h"
+
+namespace mozilla {
+namespace _ipdltest {
+
+
+class TestObjectWrapperLiaisonParent :
+    public PTestObjectWrapperLiaisonParent
+{
+public:
+    TestObjectWrapperLiaisonParent();
+    virtual ~TestObjectWrapperLiaisonParent();
+
+    void Main();
+
+protected:    
+    virtual bool RecvPong(const int& one, const float& zeroPtTwoFive);
+    virtual bool RecvUNREACHED();
+};
+
+
+class TestObjectWrapperLiaisonChild :
+    public PTestObjectWrapperLiaisonChild
+{
+public:
+    TestObjectWrapperLiaisonChild();
+    virtual ~TestObjectWrapperLiaisonChild();
+
+protected:
+    virtual bool RecvPing(const int& zero, const float& zeroPtFive);
+    virtual bool RecvUNREACHED();
+};
+
+
+} // namespace _ipdltest
+} // namespace mozilla
+
+
+#endif // ifndef mozilla__ipdltest_TestObjectWrapperLiaison_h
diff --git a/ipc/ipdl/test/cxx/ipdl.mk b/ipc/ipdl/test/cxx/ipdl.mk
--- a/ipc/ipdl/test/cxx/ipdl.mk
+++ b/ipc/ipdl/test/cxx/ipdl.mk
@@ -8,9 +8,10 @@ IPDLSRCS =					\
   PTestManyChildAllocs.ipdl			\
   PTestManyChildAllocsSub.ipdl			\
   PTestRPCRaces.ipdl				\
   PTestSanity.ipdl				\
   PTestShmem.ipdl				\
   PTestShutdown.ipdl				\
   PTestShutdownSub.ipdl				\
   PTestShutdownSubsub.ipdl			\
+  PTestObjectWrapperLiaison.ipdl				\
   $(NULL)
diff --git a/js/src/ipc/CPOWTypes.h b/js/src/ipc/CPOWTypes.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/CPOWTypes.h
@@ -0,0 +1,49 @@
+#ifndef mozilla_jsipc_ObjectWrapperLiaisonTypes_h__
+#define mozilla_jsipc_ObjectWrapperLiaisonTypes_h__
+
+#include "jsapi.h"
+#include "jspubtd.h"
+
+namespace mozilla {
+namespace jsipc {
+
+using namespace IPC;
+
+template <typename Type, typename As>
+struct CPOWConvertible
+{
+    static void Write(Message* m, const Type& t) {
+        WriteParam(m, As(t));
+    }
+    static bool Read(const Message* m, void** iter, Type* tp) {
+        As a;
+        return (ReadParam(m, iter, &a) &&
+                (*tp = Type(a), true));
+    }
+};
+
+struct void_t {};
+struct null_t {};
+    
+template <typename P>
+struct CPOWSingleton
+{
+    static void Write(Message*, const P&) {}
+    static bool Read(const Message*, void**, P*) { return true; }
+};
+    
+} // namespace jsipc
+} // namespace mozilla
+
+namespace IPC {
+
+using namespace mozilla::jsipc;
+
+template <> struct ParamTraits<void_t> : public CPOWSingleton<void_t> {};
+template <> struct ParamTraits<null_t> : public CPOWSingleton<null_t> {};
+
+template <> struct ParamTraits<JSType> : public CPOWConvertible<JSType, int> {};
+ 
+}
+
+#endif
diff --git a/js/src/ipc/Makefile.in b/js/src/ipc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/Makefile.in
@@ -0,0 +1,70 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#   The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = js
+LIBRARY_NAME = jsipc_s
+LIBXUL_LIBRARY = 1
+FORCE_STATIC_LIB = 1
+EXPORT_LIBRARY = 1
+
+EXPORTS_NAMESPACES = mozilla/jsipc
+
+EXPORTS_mozilla/jsipc = \
+  CPOWTypes.h \
+  ObjectWrapperLiaisonChild.h \
+  ObjectWrapperLiaisonParent.h \
+  ObjectWrapperParent.h \
+  ObjectWrapperChild.h \
+  $(NULL)
+
+CPPSRCS = \
+  ObjectWrapperParent.cpp \
+  ObjectWrapperChild.cpp \
+  $(NULL)
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/ipc/chromium/chromium-config.mk
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DBIN_SUFFIX='"$(BIN_SUFFIX)"'
diff --git a/js/src/ipc/ObjectWrapperChild.cpp b/js/src/ipc/ObjectWrapperChild.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperChild.cpp
@@ -0,0 +1,364 @@
+#include "mozilla/jsipc/ObjectWrapperLiaisonChild.h"
+#include "mozilla/jsipc/ObjectWrapperChild.h"
+
+namespace mozilla {
+namespace jsipc {
+
+ObjectWrapperChild::ObjectWrapperChild(JSContext* cx, JSObject* obj)
+    : mContext(cx)
+    , mObj(obj)
+{
+    JSAutoRequest request(mContext);
+    JS_AddNamedRoot(mContext, (void*)&mObj,
+                    "mozilla::jsipc::ObjectWrapperChild-rooted JSObject*");
+}
+
+ObjectWrapperChild::~ObjectWrapperChild()
+{
+    JSAutoRequest request(mContext);
+    JS_RemoveRoot(mContext, (void*)&mObj);
+}
+
+bool
+ObjectWrapperChild::JSObject_to_JSVariant(JSContext* cx, JSObject* from,
+                                          JSVariant* to)
+{
+    *to = Manager()->GetOrCreateWrapper(from);
+    return true;
+}
+
+bool
+ObjectWrapperChild::jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_OBJECT:
+        return JSObject_to_JSVariant(cx, JSVAL_TO_OBJECT(from), to);
+    case JSTYPE_FUNCTION:
+        return false;
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+        return true;
+    case JSTYPE_XML:
+        // fall through
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperChild::JSObject_from_JSVariant(JSContext* cx,
+                                            const JSVariant& from,
+                                            JSObject** to)
+{
+    if (from.type() != JSVariant::TPObjectWrapperChild)
+        return false;
+    if (!to)
+        return true;
+    const ObjectWrapperChild* owc =
+        static_cast<const ObjectWrapperChild*>(from.get_PObjectWrapperChild());
+    *to = owc ? owc->mObj : JSVAL_NULL;
+    return true;
+}
+
+/*static*/ bool
+ObjectWrapperChild::jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                         jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPObjectWrapperChild:
+        {
+            JSObject* obj;
+            if (!JSObject_from_JSVariant(cx, from, &obj))
+                return false;
+            *to = OBJECT_TO_JSVAL(obj);
+            return true;
+        }
+    case JSVariant::TnsString:
+        {
+            const nsString& str = from.get_nsString();
+            JSString* s = JS_NewUCStringCopyN(cx,
+                                              str.BeginReading(),
+                                              str.Length());
+            if (!s)
+                return false;
+            *to = STRING_TO_JSVAL(s);
+        }
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+    
+ObjectWrapperLiaisonChild*
+ObjectWrapperChild::Manager()
+{
+    PObjectWrapperLiaisonChild* powlc = PObjectWrapperChild::Manager();
+    return static_cast<ObjectWrapperLiaisonChild*>(powlc);
+}
+    
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    JSString* str = JS_NewUCStringCopyN(cx, from.BeginReading(), from.Length());
+    return JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+bool
+ObjectWrapperChild::RecvAddProperty(const nsString& id)
+{
+    jsid interned_id;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+    
+    JS_DefinePropertyById(mContext, mObj, interned_id,
+                          JSVAL_ZERO, NULL, NULL, 0);
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerGetProperty(const nsString& id,
+                                      bool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = false;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    *ok = JS_GetPropertyById(mContext, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(mContext, val, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerSetProperty(const nsString& id, const JSVariant& v,
+                                      bool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = false;
+    *vp = v;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id) ||
+        !jsval_from_JSVariant(mContext, v, &val))
+        return false;
+
+    *ok = JS_SetPropertyById(mContext, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(mContext, val, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerDelProperty(const nsString& id,
+                                      bool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval v;
+
+    *ok = false;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    if ((*ok = JS_DeletePropertyById2(mContext, mObj, interned_id, &v)))
+        return jsval_to_JSVariant(mContext, v, vp);
+
+    return true;
+}
+
+static const PRUint32 sIdArraySlot = 0, sNextIdIndexSlot = 1;
+static const PRUint32 sNumNewEnumerateStateSlots = 2;
+
+static void
+CPOW_NewEnumerateState_Finalize(JSContext* cx, JSObject* obj)
+{
+    jsval v;
+    JSIdArray* ids;
+    if (JS_GetReservedSlot(cx, obj, sIdArraySlot, &v) &&
+        (ids = static_cast<JSIdArray*>(JSVAL_TO_PRIVATE(v))))
+        JS_DestroyIdArray(cx, ids);
+}
+
+// Similar to IteratorClass in XPCWrapper.cpp
+static const JSClass sCPOW_NewEnumerateState_JSClass = {
+    "CPOW NewEnumerate State",
+    JSCLASS_HAS_RESERVED_SLOTS(sNumNewEnumerateStateSlots),
+    JS_PropertyStub,  JS_PropertyStub,
+    JS_PropertyStub,  JS_PropertyStub,
+    JS_EnumerateStub, JS_ResolveStub,
+    JS_ConvertStub,   CPOW_NewEnumerateState_Finalize,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+#if 0
+bool
+ObjectWrapperChild::AnswerSomething(/* in-parameters */
+                                    /* out-parameters */)
+{
+    // variable declarations
+    // infallible failure initializations
+    JSAutoRequest request(mContext);
+    // validate in-parameters, or return false
+    // successfully perform local JS operations, or return true
+    // prepare out-parameters
+    return true;
+}
+#endif
+    
+bool
+ObjectWrapperChild::AnswerNewEnumerateInit(/* no in-parameters */
+                                           bool* ok, JSVariant* statep, int* idp)
+{
+    JSIdArray* ids;
+    JSObject* state;
+    JSClass* clasp = const_cast<JSClass*>(&sCPOW_NewEnumerateState_JSClass);
+
+    *ok = false;
+
+    JSAutoRequest request(mContext);
+
+    if (!(ids = JS_Enumerate(mContext, mObj)) ||
+        !(state = JS_NewObjectWithGivenProto(mContext, clasp, NULL, NULL)))
+        return true;
+    
+    *idp = ids->length;
+
+    *ok = (JS_SetReservedSlot(mContext, state, sIdArraySlot,
+                              PRIVATE_TO_JSVAL(ids)) &&
+           JS_SetReservedSlot(mContext, state, sNextIdIndexSlot,
+                              JSVAL_ZERO) &&
+           JSObject_to_JSVariant(mContext, state, statep));
+
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerNewEnumerateNext(const JSVariant& in_state,
+                                           bool* ok, JSVariant* statep, nsString* idp)
+{
+    JSObject* state;
+    jsval v;
+    JSIdArray* ids;
+    JSString* str;
+
+    *statep = in_state;
+    
+    JSAutoRequest request(mContext);
+
+    if (!JSObject_from_JSVariant(mContext, in_state, &state) ||
+        !JS_GetReservedSlot(mContext, state, sIdArraySlot, &v) ||
+        !(ids = static_cast<JSIdArray*>(JSVAL_TO_PRIVATE(v))) ||
+        !JS_GetReservedSlot(mContext, state, sNextIdIndexSlot, &v))
+        return false;
+
+    int i = JSVAL_TO_INT(v);
+    if (i >= ids->length) {
+        *ok = true;
+        return JSObject_to_JSVariant(mContext, NULL, statep);
+    }
+
+    if (!JS_IdToValue(mContext, ids->vector[i], &v) ||
+        !(str = JS_ValueToString(mContext, v)))
+    {
+        *ok = false;
+        return true;
+    }
+
+    *idp = JS_GetStringChars(str);
+    *ok = JS_SetReservedSlot(mContext, state, sNextIdIndexSlot,
+                             INT_TO_JSVAL(i + 1));
+    return true;
+}
+    
+bool
+ObjectWrapperChild::RecvNewEnumerateDestroy(const JSVariant& in_state)
+{
+    JSObject* state;
+    JSAutoRequest request(mContext);
+    return (JSObject_from_JSVariant(mContext, in_state, &state) &&
+            JS_SetReservedSlot(mContext, state, sIdArraySlot, JSVAL_ZERO));
+}
+    
+bool
+ObjectWrapperChild::AnswerNewResolve(const nsString& id, const int& flags,
+                                     bool* ok, PObjectWrapperChild** obj2)
+{
+    jsid interned_id;
+    
+    *ok = false;
+    *obj2 = NULL;
+    
+    JSAutoRequest request(mContext);
+
+    printf("new-resolving \"%s\"...\n", NS_ConvertUTF16toUTF8(id).get());
+    fflush(0);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    JSPropertyDescriptor desc;
+    if (!JS_GetPropertyDescriptorById(mContext, mObj, interned_id, flags, &desc))
+        return true;
+
+    *ok = true;
+
+    if (desc.obj)
+        *obj2 = Manager()->GetOrCreateWrapper(desc.obj);
+
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerConvert(const JSType& type,
+                                  bool* ok, JSVariant* vp)
+{
+    jsval v;
+    JSAutoRequest request(mContext);
+    *ok = (JS_ConvertValue(mContext, OBJECT_TO_JSVAL(mObj), type, &v) &&
+           jsval_to_JSVariant(mContext, v, vp));
+    return true;
+}
+
+}}
diff --git a/js/src/ipc/ObjectWrapperChild.h b/js/src/ipc/ObjectWrapperChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperChild.h
@@ -0,0 +1,69 @@
+#ifndef mozilla_jsipc_ObjectWrapperChild_h__
+#define mozilla_jsipc_ObjectWrapperChild_h__
+
+#include "mozilla/jsipc/PObjectWrapperChild.h"
+
+using mozilla::jsipc::JSVariant;
+
+namespace mozilla {
+namespace jsipc {
+
+class ObjectWrapperLiaisonChild;
+  
+class ObjectWrapperChild
+    : public PObjectWrapperChild
+{
+public:
+
+    ObjectWrapperChild(JSContext* cx, JSObject* obj);
+
+    ~ObjectWrapperChild();
+
+    JSObject* GetJSObject() const { return mObj; }
+    
+private:
+
+    JSContext* const mContext;
+    JSObject* const mObj;
+
+    bool JSObject_to_JSVariant(JSContext* cx, JSObject* from, JSVariant* to);
+    bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+
+    static bool JSObject_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                        JSObject** to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+
+    ObjectWrapperLiaisonChild* Manager();
+
+protected:
+
+    bool RecvAddProperty(const nsString& id);
+
+    bool AnswerGetProperty(const nsString& id,
+                           bool* ok, JSVariant* vp);
+
+    bool AnswerSetProperty(const nsString& id, const JSVariant& v,
+                           bool* ok, JSVariant* vp);
+
+    bool AnswerDelProperty(const nsString& id,
+                           bool* ok, JSVariant* vp);
+
+    bool AnswerNewEnumerateInit(/* no in-parameters */
+                                bool* ok, JSVariant* statep, int* idp);
+
+    bool AnswerNewEnumerateNext(const JSVariant& in_state,
+                                bool* ok, JSVariant* statep, nsString* idp);
+
+    bool RecvNewEnumerateDestroy(const JSVariant& in_state);
+
+    bool AnswerNewResolve(const nsString& id, const int& flags,
+                          bool* ok, PObjectWrapperChild** obj2);
+
+    bool AnswerConvert(const JSType& type,
+                       bool* ok, JSVariant* vp);
+};
+
+}}
+  
+#endif
diff --git a/js/src/ipc/ObjectWrapperLiaisonChild.h b/js/src/ipc/ObjectWrapperLiaisonChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperLiaisonChild.h
@@ -0,0 +1,105 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set sw=4 ts=8 et tw=80 : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_ObjectWrapperLiaisonChild_h__
+#define mozilla_jsipc_ObjectWrapperLiaisonChild_h__
+
+#include "mozilla/jsipc/PObjectWrapperLiaisonChild.h"
+#include "mozilla/jsipc/ObjectWrapperChild.h"
+
+#include "jsapi.h"
+#include "nsClassHashtable.h"
+#include "nsHashKeys.h"
+
+namespace mozilla {
+namespace jsipc {
+
+class ObjectWrapperLiaisonChild
+    : public PObjectWrapperLiaisonChild
+{
+public:
+
+    ObjectWrapperLiaisonChild(JSContext* cx)
+        : mContext(cx)
+    {
+        mResidentObjectTable.Init();
+    }
+
+    PObjectWrapperChild* GetOrCreateWrapper(JSObject* obj,
+                                            bool attachAsGlobal = false)
+    {
+        PObjectWrapperChild* wrapper;
+        while (!mResidentObjectTable.Get(obj, &wrapper))
+            mResidentObjectTable.Put(obj, SendPObjectWrapperConstructor(AllocPObjectWrapper(obj),
+                                                                        attachAsGlobal));
+        return wrapper;
+    }
+    
+    PObjectWrapperChild* GetOrCreateGlobalWrapper() {
+        return GetOrCreateWrapper(JS_GetGlobalObject(mContext), true);
+    }
+    
+protected:
+
+    PObjectWrapperChild* AllocPObjectWrapper(JSObject* obj) {
+        return new ObjectWrapperChild(mContext, obj);
+    }
+    
+    PObjectWrapperChild* AllocPObjectWrapper(const bool&) {
+        return AllocPObjectWrapper(JS_GetGlobalObject(mContext));
+    }
+
+    bool DeallocPObjectWrapper(PObjectWrapperChild* actor) {
+        ObjectWrapperChild* owc = static_cast<ObjectWrapperChild*>(actor);
+        mResidentObjectTable.Remove(owc->GetJSObject());
+        return true;
+    }
+
+private:
+    
+    JSContext* const mContext;
+
+    nsClassHashtable<nsPtrHashKey<JSObject>,
+                     PObjectWrapperChild> mResidentObjectTable;
+
+};
+
+}}
+
+#endif
diff --git a/js/src/ipc/ObjectWrapperLiaisonParent.h b/js/src/ipc/ObjectWrapperLiaisonParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperLiaisonParent.h
@@ -0,0 +1,90 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set sw=4 ts=8 et tw=80 : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_ObjectWrapperLiaisonParent_h__
+#define mozilla_jsipc_ObjectWrapperLiaisonParent_h__
+
+#include "mozilla/jsipc/PObjectWrapperLiaisonParent.h"
+#include "mozilla/jsipc/ObjectWrapperParent.h"
+
+#include "jsapi.h"
+
+namespace mozilla {
+namespace jsipc {
+    
+class ObjectWrapperLiaisonParent
+    : public PObjectWrapperLiaisonParent
+{
+public:
+
+    bool AttachGlobal(JSContext* cx, JSObject* to, jsid id)
+    {
+        return (mGlobal &&
+                JS_DefinePropertyById(cx, to, id, mGlobal->GetJSVal(cx), NULL,
+                                      NULL, 0));
+    }
+
+private:
+
+    ObjectWrapperParent* mGlobal;
+
+    PObjectWrapperParent* AllocPObjectWrapper(const bool&) {
+        return new ObjectWrapperParent();
+    }
+
+    bool RecvPObjectWrapperConstructor(PObjectWrapperParent* actor,
+                                       const bool& attachAsGlobal)
+    {
+        // TODO implement a notion of "reparenting"
+        if (attachAsGlobal)
+            mGlobal = static_cast<ObjectWrapperParent*>(actor);
+    }
+
+    bool DeallocPObjectWrapper(PObjectWrapperParent* actor)
+    {
+        // TODO what if actor == mGlobal?
+        delete actor;
+        return true;
+    }
+
+};
+
+}}
+
+#endif
diff --git a/js/src/ipc/ObjectWrapperParent.cpp b/js/src/ipc/ObjectWrapperParent.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperParent.cpp
@@ -0,0 +1,391 @@
+#include "mozilla/jsipc/ObjectWrapperParent.h"
+
+#include "jsobj.h"
+
+namespace mozilla {
+namespace jsipc {
+
+namespace {
+    static const PRUint32 sFlagsSlot = 0, sWrappedObjSlot = 1;
+    static const PRUint32 sNumSlots = 2;
+    typedef ObjectWrapperParent _;
+}
+
+const JSExtendedClass _::sCPOW_JSClass = {
+    // JSClass (JSExtendedClass.base) initialization
+    { "CrossProcessObjectWrapper",
+      JSCLASS_NEW_RESOLVE |
+      JSCLASS_NEW_ENUMERATE |
+      JSCLASS_IS_EXTENDED |
+      JSCLASS_HAS_RESERVED_SLOTS(sNumSlots),
+      _::CPOW_AddProperty, _::CPOW_DelProperty,
+      _::CPOW_GetProperty, _::CPOW_SetProperty,
+      (JSEnumerateOp)_::CPOW_NewEnumerate,
+      (JSResolveOp)_::CPOW_NewResolve,
+      _::CPOW_Convert,     _::CPOW_Finalize,
+      nsnull,              _::CPOW_CheckAccess,
+      nsnull,              nsnull,
+      nsnull,              _::CPOW_HasInstance,
+      nsnull,              nsnull
+    },
+
+    // JSExtendedClass initialization
+    _::CPOW_Equality,
+    nsnull, // outerObject
+    nsnull, // innerObject
+    nsnull, // iterator
+    nsnull, // wrappedObject
+    JSCLASS_NO_RESERVED_MEMBERS
+};
+
+void
+ObjectWrapperParent::ActorDestroy(ActorDestroyReason why)
+{
+    *mObjSlotContents = NULL;
+}
+    
+JSObject*
+ObjectWrapperParent::GetJSObject(JSContext* cx) const
+{
+    JSClass* clasp = const_cast<JSClass*>(&_::sCPOW_JSClass.base);
+    if (!mObj) {
+        mObj = JS_NewObjectWithGivenProto(cx, clasp, NULL, NULL);
+        *mObjSlotContents = this;
+        JS_SetReservedSlot(cx, mObj, sWrappedObjSlot,
+                           PRIVATE_TO_JSVAL(mObjSlotContents));
+        JS_SetReservedSlot(cx, mObj, sFlagsSlot, JSVAL_ZERO);
+    }
+    return mObj;
+}
+
+static ObjectWrapperParent*
+Unwrap(JSContext* cx, JSObject* obj)
+{
+    while (STOBJ_GET_CLASS(obj) != &_::sCPOW_JSClass.base)
+        if (!(obj = STOBJ_GET_PROTO(obj)))
+            return NULL;
+    
+    jsval info;
+
+    if (!JS_GetReservedSlot(cx, obj, sWrappedObjSlot, &info))
+        return NULL;
+
+    return *static_cast<ObjectWrapperParent**>(JSVAL_TO_PRIVATE(info));
+}
+
+/*static*/ bool
+ObjectWrapperParent::jsval_to_JSVariant(JSContext* cx, jsval from,
+                                        JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_OBJECT:
+        {
+            ObjectWrapperParent* owp = Unwrap(cx, JSVAL_TO_OBJECT(from));
+            if (!owp)
+                return false;
+            *to = owp;
+            return true;
+        }
+    case JSTYPE_FUNCTION:
+        return false; // TODO allow iff CPOW?
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+    case JSTYPE_XML:
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperParent::jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                          jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPObjectWrapperParent:
+        {
+            JSObject* obj;
+            if (!JSObject_from_PObjectWrapperParent(cx, from.get_PObjectWrapperParent(), &obj))
+                return false;
+            *to = OBJECT_TO_JSVAL(obj);
+            return true;
+        }
+    case JSVariant::TnsString:
+        *to = STRING_TO_JSVAL(JS_NewUCStringCopyZ(cx, from.get_nsString().BeginReading()));
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperParent::
+JSObject_from_PObjectWrapperParent(JSContext* cx,
+                                   const PObjectWrapperParent* from,
+                                   JSObject** to)
+{
+    const ObjectWrapperParent* owp =
+        static_cast<const ObjectWrapperParent*>(from);
+    *to = owp
+        ? owp->GetJSObject(cx)
+        : JSVAL_TO_OBJECT(JSVAL_NULL);
+    return true;
+}
+    
+static bool
+jsid_from_int(JSContext* cx, int from, jsid* to)
+{
+    // TODO check the outparams more generally
+    if (!to)
+        return true;
+    jsval v = INT_TO_JSVAL(from);
+    return JS_ValueToId(cx, v, to);
+}
+
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    if (!to)
+        return true;
+    JSString* str = JS_NewUCStringCopyZ(cx, from.BeginReading());
+    return JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+static bool
+jsval_to_nsString(JSContext* cx, jsval from, nsString* to)
+{
+    JSString* str;
+    if (JSVAL_IS_STRING(from) &&
+        (str = JS_ValueToString(cx, from))) {
+        *to = JS_GetStringChars(str);
+        return true;
+    }
+    return false;
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_AddProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    printf("Calling CPOW_AddProperty...\n"); fflush(0);
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;    
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    return self->SendAddProperty(in_id);
+}    
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_GetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    printf("Calling CPOW_GetProperty...\n"); fflush(0);
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_v;
+    
+    return (self->CallGetProperty(in_id,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_SetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    printf("Calling CPOW_SetProperty...\n"); fflush(0);
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+    JSVariant in_v;
+
+    if (!jsval_to_nsString(cx, id, &in_id) ||
+        !self->jsval_to_JSVariant(cx, *vp, &in_v))
+        return JS_FALSE;
+    
+    bool out_ok;
+    JSVariant out_v;
+
+    return (self->CallSetProperty(in_id, in_v,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}    
+    
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_DelProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    printf("Calling CPOW_DelProperty...\n"); fflush(0);
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_v;
+    
+    return (self->CallDelProperty(in_id,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_v, vp));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_NewEnumerate(JSContext *cx, JSObject *obj,
+                                       JSIterateOp enum_op, jsval *statep,
+                                       jsid *idp)
+{
+    printf("Calling CPOW_NewEnumerate...\n"); fflush(0);
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;    
+    
+    JSVariant in_state;
+
+    if ((enum_op == JSENUMERATE_NEXT ||
+         enum_op == JSENUMERATE_DESTROY) &&
+        !self->jsval_to_JSVariant(cx, *statep, &in_state))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_state;
+
+    switch (enum_op) {
+    case JSENUMERATE_INIT: {
+        int out_id;
+        return (self->CallNewEnumerateInit(&out_ok, &out_state, &out_id) &&
+                out_ok &&
+                self->jsval_from_JSVariant(cx, out_state, statep) &&
+                jsid_from_int(cx, out_id, idp));
+    }
+    case JSENUMERATE_NEXT: {
+        nsString out_id;
+        return (self->CallNewEnumerateNext(in_state,
+                                           &out_ok, &out_state, &out_id) &&
+                out_ok,
+                self->jsval_from_JSVariant(cx, out_state, statep) &&
+                jsid_from_nsString(cx, out_id, idp));
+    }
+    case JSENUMERATE_DESTROY:
+        return self->SendNewEnumerateDestroy(in_state);
+    }
+
+    return JS_FALSE;
+}
+    
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_NewResolve(JSContext *cx, JSObject *obj, jsval id,
+                                     uintN flags, JSObject **objp)
+{
+    printf("Calling CPOW_NewResolve (%s)...\n",
+           JS_GetTypeName(cx, JS_TypeOfValue(cx, id)));
+    fflush(0);
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    PObjectWrapperParent* out_obj;
+    
+    if (!self->CallNewResolve(in_id, flags,
+                              &out_ok, &out_obj) ||
+        !out_ok ||
+        !JSObject_from_PObjectWrapperParent(cx, out_obj, objp))
+        return JS_FALSE;
+
+    return JS_TRUE;
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Convert(JSContext *cx, JSObject *obj, JSType type,
+                                  jsval *vp)
+{
+    printf("Calling CPOW_Convert...\n"); fflush(0);
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_v;
+
+    return (self->CallConvert(type,
+                              &out_ok, &out_v) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_v, vp));
+}
+    
+/*static*/ void
+ObjectWrapperParent::CPOW_Finalize(JSContext* cx, JSObject* obj)
+{
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+
+    printf("Calling CPOW_Finalize...\n");
+    fflush(0);
+    
+    if (self) // disable for now
+        ObjectWrapperParent::Send__delete__(self);
+}
+
+}}
diff --git a/js/src/ipc/ObjectWrapperParent.h b/js/src/ipc/ObjectWrapperParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperParent.h
@@ -0,0 +1,109 @@
+#ifndef mozilla_jsipc_ObjectWrapperParent_h__
+#define mozilla_jsipc_ObjectWrapperParent_h__
+
+#include "mozilla/jsipc/PObjectWrapperParent.h"
+#include "jsapi.h"
+#include "nsAutoJSValHolder.h"
+
+namespace mozilla {
+namespace jsipc {
+
+class ObjectWrapperParent
+    : public PObjectWrapperParent
+{
+public:
+
+    ObjectWrapperParent()
+        : mObj(NULL)
+        , mObjSlotContents(new ObjectWrapperParent const*(NULL))
+    {}
+    
+    JSObject* GetJSObject(JSContext* cx) const;
+
+    jsval GetJSVal(JSContext* cx) const {
+        return OBJECT_TO_JSVAL(GetJSObject(cx));
+    }
+
+    static const JSExtendedClass sCPOW_JSClass;    
+    
+protected:
+
+    void ActorDestroy(ActorDestroyReason why);
+
+private:
+
+    mutable JSObject* mObj;
+    ObjectWrapperParent const** const mObjSlotContents;
+
+    static JSBool
+    CPOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    CPOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    CPOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+    
+    static JSBool
+    CPOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    CPOW_NewEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
+                      jsval *statep, jsid *idp);
+
+    static JSBool
+    CPOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
+                    JSObject **objp);
+
+    static JSBool
+    CPOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
+
+    static void
+    CPOW_Finalize(JSContext* cx, JSObject* obj);
+
+    static JSBool
+    CPOW_CheckAccess(JSContext *cx, JSObject *obj, jsval id,
+                     JSAccessMode mode, jsval *vp)
+    {
+        printf("Calling CPOW_CheckAccess...\n"); fflush(0);
+        return JS_TRUE;
+    }
+
+    static JSBool
+    CPOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
+    {
+        printf("Calling CPOW_HasInstance...\n"); fflush(0);
+        return JS_TRUE;
+    }
+
+    static JSBool
+    CPOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
+    {
+        printf("Calling CPOW_Equality...\n"); fflush(0);
+        return JS_TRUE;
+    }
+
+    static JSBool
+    CPOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                  jsval *rval)
+    {
+        printf("Calling CPOW_toString...\n"); fflush(0);
+        JSString *str = JS_NewStringCopyZ(cx, "[object CPOW]");
+        if (!str)
+            return JS_FALSE;
+        *rval = STRING_TO_JSVAL(str);
+        return JS_TRUE;
+    }
+
+    static bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+    static bool
+    JSObject_from_PObjectWrapperParent(JSContext* cx,
+                                       const PObjectWrapperParent* from,
+                                       JSObject** to);
+};
+
+}}
+  
+#endif
diff --git a/js/src/ipc/PObjectWrapper.ipdl b/js/src/ipc/PObjectWrapper.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PObjectWrapper.ipdl
@@ -0,0 +1,66 @@
+include protocol "PObjectWrapperLiaison.ipdl";
+
+include "mozilla/jsipc/CPOWTypes.h";
+
+using mozilla::jsipc::void_t;
+using mozilla::jsipc::null_t;
+using JSType;
+
+namespace mozilla {
+namespace jsipc {
+
+union JSVariant {
+    void_t;
+    nullable PObjectWrapper;
+    nsString;
+    int;
+    double;
+    bool;
+    null_t;
+};
+
+rpc protocol PObjectWrapper
+{
+    manager PObjectWrapperLiaison;
+    
+child:
+    __delete__(); // unroot
+
+    async AddProperty(nsString id);
+
+    rpc GetProperty(nsString id)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc SetProperty(nsString id,
+                    JSVariant v)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc DelProperty(nsString id)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc NewEnumerateInit()
+        returns (bool ok,
+                 JSVariant statep,
+                 int idp);
+
+    rpc NewEnumerateNext(JSVariant in_state)
+        returns (bool ok,
+                 JSVariant statep,
+                 nsString idp);
+
+    async NewEnumerateDestroy(JSVariant in_state);
+
+    rpc NewResolve(nsString id,
+                   int flags)
+        returns (bool ok,
+                 nullable PObjectWrapper obj2);
+
+    rpc Convert(JSType type)
+        returns (bool ok,
+                 JSVariant vp);
+};
+
+}}
diff --git a/js/src/ipc/PObjectWrapperLiaison.ipdl b/js/src/ipc/PObjectWrapperLiaison.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PObjectWrapperLiaison.ipdl
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 8 -*- */
+/* vim: set sw=4 ts=8 et tw=80 ft=cpp : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol "PIFrameEmbedding.ipdl";
+include protocol "PObjectWrapper.ipdl";
+
+namespace mozilla {
+namespace jsipc {
+
+rpc protocol PObjectWrapperLiaison
+{
+    manager PIFrameEmbedding;
+    manages PObjectWrapper;
+parent:
+    __delete__();
+    sync PObjectWrapper(bool attachAsGlobal);
+};
+
+}}
diff --git a/js/src/ipc/ipdl.mk b/js/src/ipc/ipdl.mk
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ipdl.mk
@@ -0,0 +1,41 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#   The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+IPDLSRCS = \
+  PObjectWrapperLiaison.ipdl \
+  PObjectWrapper.ipdl \
+  $(NULL)
diff --git a/toolkit/library/libxul-config.mk b/toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk
+++ b/toolkit/library/libxul-config.mk
@@ -88,16 +88,17 @@ RCFLAGS += -i $(topsrcdir)/widget/src/os
 endif
 
 LOCAL_INCLUDES += -I$(topsrcdir)/widget/src/os2
 endif
 
 # dependent libraries
 ifdef MOZ_IPC
 STATIC_LIBS += \
+  jsipc_s \
   domipc_s \
   domplugins_s \
   mozipc_s \
   mozipdlgen_s \
   chromium_s \
   ipcshell_s \
   gfxipc_s \
   $(NULL)
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -203,16 +203,20 @@ MAKEFILES_xpconnect="
   js/src/xpconnect/loader/Makefile
   js/src/xpconnect/tests/Makefile
   js/src/xpconnect/tests/components/Makefile
   js/src/xpconnect/tests/idl/Makefile
   js/src/xpconnect/tools/Makefile
   js/src/xpconnect/tools/idl/Makefile
 "
 
+MAKEFILES_jsipc="
+  js/src/ipc/Makefile
+"
+
 MAKEFILES_jsdebugger="
   js/jsd/Makefile
   js/jsd/idl/Makefile
 "
 
 MAKEFILES_jsctypes="
   js/ctypes/Makefile
 "
@@ -851,16 +855,17 @@ add_makefiles "
   $MAKEFILES_db
   $MAKEFILES_dom
   $MAKEFILES_editor
   $MAKEFILES_xmlparser
   $MAKEFILES_gfx
   $MAKEFILES_htmlparser
   $MAKEFILES_intl
   $MAKEFILES_xpconnect
+  $MAKEFILES_jsipc
   $MAKEFILES_jsdebugger
   $MAKEFILES_jsctypes
   $MAKEFILES_content
   $MAKEFILES_layout
   $MAKEFILES_libimg
   $MAKEFILES_libjar
   $MAKEFILES_libreg
   $MAKEFILES_libpref
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -76,17 +76,17 @@ ifeq ($(OS_ARCH),WINCE)
 tier_external_dirs += modules/lib7z
 endif
 
 #
 # tier "gecko" - core components
 #
 
 ifdef MOZ_IPC
-tier_gecko_dirs += ipc
+tier_gecko_dirs += ipc js/src/ipc
 endif
 
 tier_gecko_dirs += \
 		$(tier_necko_dirs) \
 		js/src/xpconnect \
 		js/ctypes \
 		intl/chardet \
 		$(NULL)
