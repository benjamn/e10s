# HG changeset patch
# User Ben Newman <bnewman@mozilla.com>
# Date 1257540219 28800
# Node ID c631b16ad5f0cc808c0fc910a3c2bfa6e539f9da
# Parent  705a3964ed70a7145837f2b2eeba9c0ce6d68bb8
Bug 516522 - CPOW: Cross-Process (JavaScript) Object Wrapper.

diff --git a/content/base/public/nsIFrameLoader.idl b/content/base/public/nsIFrameLoader.idl
--- a/content/base/public/nsIFrameLoader.idl
+++ b/content/base/public/nsIFrameLoader.idl
@@ -37,16 +37,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
 interface nsIDocShell;
 interface nsIURI;
 interface nsIFrame;
+interface nsIVariant;
 
 [scriptable, uuid(8f94788d-ec69-4220-971c-0fd68d47b80f)]
 interface nsIFrameLoader : nsISupports
 {
   /**
    * Get the docshell from the frame loader.
    */
   readonly attribute nsIDocShell docShell;
@@ -112,16 +113,18 @@ native alreadyAddRefed_nsFrameLoader(alr
 interface nsIFrameLoaderOwner : nsISupports
 {
   /**
    * The frame loader owned by this nsIFrameLoaderOwner
    */
   readonly attribute nsIFrameLoader frameLoader;
   [noscript, notxpcom] alreadyAddRefed_nsFrameLoader GetFrameLoader();
 
+  readonly attribute nsIVariant crossProcessObjectWrapper;
+
   /**
    * Swap frame loaders with the given nsIFrameLoaderOwner.  This may
    * only be posible in a very limited range of circumstances, or
    * never, depending on the object implementing this interface.
    *
    * @throws NS_ERROR_NOT_IMPLEMENTED if the swapping logic is not
    *   implemented for the two given frame loader owners.
    * @throws NS_ERROR_DOM_SECURITY_ERR if the swap is not allowed on
diff --git a/content/base/src/nsFrameLoader.cpp b/content/base/src/nsFrameLoader.cpp
--- a/content/base/src/nsFrameLoader.cpp
+++ b/content/base/src/nsFrameLoader.cpp
@@ -64,16 +64,18 @@
 #include "nsIWebNavigation.h"
 #include "nsIDocShell.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIDocShellTreeNode.h"
 #include "nsIDocShellTreeOwner.h"
 #include "nsIDocShellLoadInfo.h"
 #include "nsIBaseWindow.h"
 #include "nsContentUtils.h"
+#include "nsIXPConnect.h"
+#include "nsIJSContextStack.h"
 #include "nsUnicharUtils.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIScrollable.h"
 #include "nsFrameLoader.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIFrame.h"
 #include "nsIFrameFrame.h"
@@ -109,16 +111,18 @@
 #ifdef MOZ_IPC
 #include "ContentProcessParent.h"
 #include "TabParent.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 #endif
 
+#include "jsapi.h"
+
 class nsAsyncDocShellDestroyer : public nsRunnable
 {
 public:
   nsAsyncDocShellDestroyer(nsIDocShell* aDocShell)
     : mDocShell(aDocShell)
   {
   }
 
@@ -1513,16 +1517,34 @@ nsFrameLoader::ActivateFrameEvent(const 
   if (mChildProcess) {
     mChildProcess->SendactivateFrameEvent(nsString(aType), aCapture);
     return NS_OK;
   }
 #endif
   return NS_ERROR_FAILURE;
 }
 
+NS_IMETHODIMP
+nsFrameLoader::GetCrossProcessObjectWrapper(nsIVariant** cpow)
+{
+  
+   nsIXPConnect* xpc;
+   nsIThreadJSContextStack* stack;
+   JSContext* cx;
+   JSObject* global;
+ 
+   if ((xpc = nsContentUtils::XPConnect()) &&
+       (stack = nsContentUtils::ThreadJSContextStack()) &&
+       NS_SUCCEEDED(stack->Peek(&cx)) && cx &&
+       mChildProcess->GetGlobalJSObject(cx, &global))
+    return xpc->JSToVariant(cx, OBJECT_TO_JSVAL(global), cpow);
+  
+  return NS_ERROR_NOT_AVAILABLE;
+}
+
 nsresult
 nsFrameLoader::CreateStaticClone(nsIFrameLoader* aDest)
 {
   nsFrameLoader* dest = static_cast<nsFrameLoader*>(aDest);
   dest->MaybeCreateDocShell();
   NS_ENSURE_STATE(dest->mDocShell);
 
   nsCOMPtr<nsIDOMDocument> dummy = do_GetInterface(dest->mDocShell);
diff --git a/content/base/src/nsFrameLoader.h b/content/base/src/nsFrameLoader.h
--- a/content/base/src/nsFrameLoader.h
+++ b/content/base/src/nsFrameLoader.h
@@ -127,16 +127,17 @@ public:
   // frame loader owner needs to call this, and pass in the two references to
   // nsRefPtrs for frame loaders that need to be swapped.
   nsresult SwapWithOtherLoader(nsFrameLoader* aOther,
                                nsRefPtr<nsFrameLoader>& aFirstToSwap,
                                nsRefPtr<nsFrameLoader>& aSecondToSwap);
 
 #ifdef MOZ_IPC
   mozilla::dom::PIFrameEmbeddingParent* GetChildProcess();
+  NS_IMETHOD GetCrossProcessObjectWrapper(nsIVariant** cpow);
 #endif
 
 private:
 
 #ifdef MOZ_IPC
   bool ShouldUseRemoteProcess();
 #endif
 
diff --git a/content/base/src/nsObjectLoadingContent.cpp b/content/base/src/nsObjectLoadingContent.cpp
--- a/content/base/src/nsObjectLoadingContent.cpp
+++ b/content/base/src/nsObjectLoadingContent.cpp
@@ -702,16 +702,22 @@ nsObjectLoadingContent::GetFrameLoader()
 }
 
 NS_IMETHODIMP
 nsObjectLoadingContent::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherLoader)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+NS_IMETHODIMP
+nsObjectLoadingContent::GetCrossProcessObjectWrapper(nsIVariant**)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 // nsIObjectLoadingContent
 NS_IMETHODIMP
 nsObjectLoadingContent::GetActualType(nsACString& aType)
 {
   aType = mContentType;
   return NS_OK;
 }
 
diff --git a/content/html/content/src/nsGenericHTMLElement.cpp b/content/html/content/src/nsGenericHTMLElement.cpp
--- a/content/html/content/src/nsGenericHTMLElement.cpp
+++ b/content/html/content/src/nsGenericHTMLElement.cpp
@@ -2774,16 +2774,23 @@ nsGenericHTMLFrameElement::GetFrameLoade
 
 NS_IMETHODIMP
 nsGenericHTMLFrameElement::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherOwner)
 {
   // We don't support this yet
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+NS_IMETHODIMP
+nsGenericHTMLFrameElement::GetCrossProcessObjectWrapper(nsIVariant**)
+{
+  // We don't support this yet
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 nsresult
 nsGenericHTMLFrameElement::LoadSrc()
 {
   nsresult rv = EnsureFrameLoader();
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (!mFrameLoader) {
     return NS_OK;
diff --git a/content/xul/content/src/nsXULElement.cpp b/content/xul/content/src/nsXULElement.cpp
--- a/content/xul/content/src/nsXULElement.cpp
+++ b/content/xul/content/src/nsXULElement.cpp
@@ -2061,16 +2061,22 @@ nsXULElement::SwapFrameLoaders(nsIFrameL
     }
 
     return
         ourSlots->mFrameLoader->SwapWithOtherLoader(otherSlots->mFrameLoader,
                                                     ourSlots->mFrameLoader,
                                                     otherSlots->mFrameLoader);
 }
 
+NS_IMETHODIMP
+nsXULElement::GetCrossProcessObjectWrapper(nsIVariant** cpow)
+{
+    nsRefPtr<nsFrameLoader> frameLoader(GetFrameLoader());
+    return frameLoader->GetCrossProcessObjectWrapper(cpow);
+}
 
 NS_IMETHODIMP
 nsXULElement::GetParentTree(nsIDOMXULMultiSelectControlElement** aTreeElement)
 {
     for (nsIContent* current = GetParent(); current;
          current = current->GetParent()) {
         if (current->NodeInfo()->Equals(nsGkAtoms::listbox,
                                         kNameSpaceID_XUL)) {
diff --git a/content/xul/content/src/nsXULElement.h b/content/xul/content/src/nsXULElement.h
--- a/content/xul/content/src/nsXULElement.h
+++ b/content/xul/content/src/nsXULElement.h
@@ -579,16 +579,18 @@ public:
     virtual PRInt32 IntrinsicState() const;
 
     nsresult GetStyle(nsIDOMCSSStyleDeclaration** aStyle);
 
     nsresult GetFrameLoader(nsIFrameLoader** aFrameLoader);
     already_AddRefed<nsFrameLoader> GetFrameLoader();
     nsresult SwapFrameLoaders(nsIFrameLoaderOwner* aOtherOwner);
 
+    NS_IMETHOD GetCrossProcessObjectWrapper(nsIVariant** cpow);
+
     virtual void RecompileScriptEventListeners();
 
     // This function should ONLY be used by BindToTree implementations.
     // The function exists solely because XUL elements store the binding
     // parent as a member instead of in the slots, as nsGenericElement does.
     void SetXULBindingParent(nsIContent* aBindingParent)
     {
       mBindingParent = aBindingParent;
diff --git a/dom/ipc/ContentProcessChild.cpp b/dom/ipc/ContentProcessChild.cpp
--- a/dom/ipc/ContentProcessChild.cpp
+++ b/dom/ipc/ContentProcessChild.cpp
@@ -36,24 +36,27 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "ContentProcessChild.h"
 #include "TabChild.h"
 
 #include "mozilla/ipc/TestShellChild.h"
 #include "mozilla/net/NeckoChild.h"
+#include "mozilla/ipc/XPCShellEnvironment.h"
+#include "mozilla/jsipc/ContextWrapperChild.h"
 
 #include "nsXULAppAPI.h"
 
 #include "base/message_loop.h"
 #include "base/task.h"
 
 using namespace mozilla::ipc;
 using namespace mozilla::net;
+using namespace mozilla::jsipc;
 
 namespace mozilla {
 namespace dom {
 
 ContentProcessChild* ContentProcessChild::sSingleton;
 
 ContentProcessChild::ContentProcessChild()
     : mQuit(PR_FALSE)
@@ -109,30 +112,63 @@ ContentProcessChild::AllocPTestShell()
 }
 
 bool
 ContentProcessChild::DeallocPTestShell(PTestShellChild* shell)
 {
     mTestShells.RemoveElement(shell);
     return true;
 }
+    
+bool
+ContentProcessChild::RecvPTestShellConstructor(PTestShellChild* actor)
+{
+    XPCShellEnvironment* env;
+    ContextWrapperChild* cwc;
+    JSContext* cx;
+
+    if ((env = static_cast<TestShellChild*>(actor)->GetXPCShell()) &&
+        (cx = env->GetContext()) &&
+        (cwc = new ContextWrapperChild(cx)))
+        this->SendPContextWrapperConstructor(cwc, actor)
+            ->SendPObjectWrapperConstructor(true);
+
+    return true;
+}
 
 PNeckoChild* 
 ContentProcessChild::AllocPNecko()
 {
     return new NeckoChild();
 }
 
 bool 
 ContentProcessChild::DeallocPNecko(PNeckoChild* necko)
 {
     delete necko;
     return true;
 }
 
+PContextWrapperChild*
+ContentProcessChild::AllocPContextWrapper(const ContextWrapperOwner&)
+{
+    NS_NOTREACHED("ContentProcessChild::AllocPContextWrapper does not "
+                  "have enough information to allocate instances of "
+                  "ContextWrapperChild (see "
+                  "TabChild::CreateContextWrapperAndSetGlobalObject).");
+    return NULL;
+}
+
+bool
+ContentProcessChild::DeallocPContextWrapper(PContextWrapperChild* actor)
+{
+    delete actor;
+    return true;
+}
+    
 void
 ContentProcessChild::Quit()
 {
     NS_ASSERTION(mQuit, "Exiting uncleanly!");
     mIFrames.Clear();
     mTestShells.Clear();
 }
 
diff --git a/dom/ipc/ContentProcessChild.h b/dom/ipc/ContentProcessChild.h
--- a/dom/ipc/ContentProcessChild.h
+++ b/dom/ipc/ContentProcessChild.h
@@ -39,16 +39,18 @@
 #ifndef mozilla_dom_ContentProcessChild_h
 #define mozilla_dom_ContentProcessChild_h
 
 #include "mozilla/dom/PContentProcessChild.h"
 
 #include "nsTArray.h"
 #include "nsAutoPtr.h"
 
+using namespace mozilla::jsipc;
+
 namespace mozilla {
 namespace dom {
 
 class ContentProcessChild : public PContentProcessChild
 {
 public:
     ContentProcessChild();
     virtual ~ContentProcessChild();
@@ -62,20 +64,25 @@ public:
         return sSingleton;
     }
 
     virtual PIFrameEmbeddingChild* AllocPIFrameEmbedding();
     virtual bool DeallocPIFrameEmbedding(PIFrameEmbeddingChild*);
 
     virtual PTestShellChild* AllocPTestShell();
     virtual bool DeallocPTestShell(PTestShellChild*);
+    virtual bool RecvPTestShellConstructor(PTestShellChild* actor);
 
     virtual PNeckoChild* AllocPNecko();
     virtual bool DeallocPNecko(PNeckoChild*);
 
+protected:
+    virtual PContextWrapperChild* AllocPContextWrapper(const ContextWrapperOwner&);
+    virtual bool DeallocPContextWrapper(PContextWrapperChild* actor);
+    
 private:
     NS_OVERRIDE
     virtual void ActorDestroy(ActorDestroyReason why);
 
     void Quit();
 
     static ContentProcessChild* sSingleton;
 
diff --git a/dom/ipc/ContentProcessParent.cpp b/dom/ipc/ContentProcessParent.cpp
--- a/dom/ipc/ContentProcessParent.cpp
+++ b/dom/ipc/ContentProcessParent.cpp
@@ -48,16 +48,18 @@
 
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 
 using namespace mozilla::ipc;
 using namespace mozilla::net;
+using namespace mozilla::jsipc;
+    
 using mozilla::MonitorAutoEnter;
 
 namespace {
 PRBool gSingletonDied = PR_FALSE;
 }
 
 namespace mozilla {
 namespace dom {
@@ -177,10 +179,53 @@ ContentProcessParent::AllocPNecko()
 
 bool 
 ContentProcessParent::DeallocPNecko(PNeckoParent* necko)
 {
     delete necko;
     return true;
 }
 
+PContextWrapperParent*
+ContentProcessParent::AllocPContextWrapper(const ContextWrapperOwner&)
+{
+    return new ContextWrapperParent();
+}
+
+bool
+ContentProcessParent::DeallocPContextWrapper(PContextWrapperParent* actor)
+{
+    delete actor;
+    return true;
+}
+
+bool
+ContentProcessParent::
+RecvPContextWrapperConstructor(PContextWrapperParent* actor,
+                               const ContextWrapperOwner& cwo)
+{
+    // TODO This method can go away once IPDL supports multiple managers,
+    // for then PObjectWrapper can be managed by PIFrameEmbeddingParent
+    // and PTestShellParent, instead of their common parent
+    // PContentProcess.
+    
+    switch (cwo.type()) {
+    case ContextWrapperOwner::TPIFrameEmbeddingParent:
+        {
+            const TabParent* tp =
+                static_cast<const TabParent*>(cwo.get_PIFrameEmbeddingParent());
+            const_cast<TabParent*>(tp)->SetContextWrapper(actor);
+            return true;
+        }
+    case ContextWrapperOwner::TPTestShellParent:
+        {
+            const TestShellParent* tsp =
+                static_cast<const TestShellParent*>(cwo.get_PTestShellParent());
+            const_cast<TestShellParent*>(tsp)->SetContextWrapper(actor);
+            return true;
+        }
+    default:
+        return false;
+    }
+}   
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/ipc/ContentProcessParent.h b/dom/ipc/ContentProcessParent.h
--- a/dom/ipc/ContentProcessParent.h
+++ b/dom/ipc/ContentProcessParent.h
@@ -42,16 +42,18 @@
 #include "base/waitable_event_watcher.h"
 
 #include "mozilla/dom/PContentProcessParent.h"
 #include "mozilla/ipc/GeckoChildProcessHost.h"
 
 #include "nsIObserver.h"
 #include "mozilla/Monitor.h"
 
+using namespace mozilla::jsipc;
+
 namespace mozilla {
 
 namespace ipc {
 class TestShellParent;
 }
 
 namespace dom {
 
@@ -95,16 +97,20 @@ private:
     virtual bool DeallocPIFrameEmbedding(PIFrameEmbeddingParent* frame);
 
     virtual PTestShellParent* AllocPTestShell();
     virtual bool DeallocPTestShell(PTestShellParent* shell);
 
     virtual PNeckoParent* AllocPNecko();
     virtual bool DeallocPNecko(PNeckoParent* necko);
 
+    virtual PContextWrapperParent* AllocPContextWrapper(const ContextWrapperOwner&);
+    virtual bool DeallocPContextWrapper(PContextWrapperParent* actor);
+    virtual bool RecvPContextWrapperConstructor(PContextWrapperParent* actor,
+                                                const ContextWrapperOwner& cwo);
     mozilla::Monitor mMonitor;
 
     GeckoChildProcessHost* mSubprocess;
 };
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/ipc/PContentProcess.ipdl b/dom/ipc/PContentProcess.ipdl
--- a/dom/ipc/PContentProcess.ipdl
+++ b/dom/ipc/PContentProcess.ipdl
@@ -34,31 +34,62 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol "PIFrameEmbedding.ipdl";
 include protocol "PTestShell.ipdl";
 include protocol "PNecko.ipdl";
+include protocol "PContextWrapper.ipdl";
 
 include "mozilla/TabTypes.h";
 
 namespace mozilla {
 namespace dom {
 
+/* Although PContentProcess manages PContextWrapper, PContextWrapper
+ * instances are always created by (or on behalf of) a particular
+ * PIFrameEmbedding or PTestShell, since each instance of these
+ * subprotocols has its own JSContext (and distinct PContextWrappers are
+ * needed for distinct JSContexts).
+ *
+ * It would be more natural to allow both PIFrameEmbedding and PTestShell
+ * to manage PContextWrapper, but as far as I can tell IPDL protocols
+ * cannot have multiple managers (bug 540111 may change this).
+ *
+ * So that we can later determine which PContextWrapperParent is
+ * associated with a given PIFrameEmbeddingParent or PTestShellParent, the
+ * PContextWrapper constructor message must convey to the
+ * PContentProcessParent which PIFrameEmbeddingChild or PTestShellChild
+ * sent the PContextWrapper constructor message.
+ *
+ * We might like to have two separate PContextWrapper constructors, one
+ * accepting a PIFrameEmbeddingChild and the other a PTestShell.  Alas,
+ * IPDL constructors can't be overloaded, so we'll settle for a single
+ * constructor that accepts a union-type parameter.
+ */
+union ContextWrapperOwner {
+    PIFrameEmbedding;
+    PTestShell;
+};
+    
 rpc protocol PContentProcess
 {
     manages PIFrameEmbedding;
     manages PTestShell;
     manages PNecko;
+    manages PContextWrapper;
 
 child:
     PIFrameEmbedding();
 
     PTestShell();
 
 parent:
     PNecko();
+
+    PContextWrapper(ContextWrapperOwner cwo);
+
 };
 
 }
 }
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -50,16 +50,24 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMWindowUtils.h"
 #include "nsISupportsImpl.h"
 #include "nsIWebBrowserFocus.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 
+#include "mozilla/dom/PContentProcessChild.h"
+#include "mozilla/jsipc/ContextWrapperChild.h"
+
+#include "nsIDocument.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIScriptContext.h"
+#include "jscntxt.h"
+
 #ifdef MOZ_WIDGET_GTK2
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 #endif
 
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS1(ContentListener, nsIDOMEventListener)
@@ -329,16 +337,19 @@ TabChild::RecvloadURL(const nsCString& u
     printf("loading %s, %d\n", uri.get(), NS_IsMainThread());
 
     nsresult rv = mWebNav->LoadURI(NS_ConvertUTF8toUTF16(uri).get(),
                                    nsIWebNavigation::LOAD_FLAGS_NONE,
                                    NULL, NULL, NULL);
     if (NS_FAILED(rv)) {
         NS_WARNING("mWebNav->LoadURI failed. Eating exception, what else can I do?");
     }
+
+    CreateContextWrapperAndSetGlobalObject();
+    
     return true;
 }
 
 bool
 TabChild::Recvmove(const PRUint32& x,
                      const PRUint32& y,
                      const PRUint32& width,
                      const PRUint32& height)
@@ -371,16 +382,48 @@ TabChild::RecvsendMouseEvent(const nsStr
   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(mWebNav);
   nsCOMPtr<nsIDOMWindowUtils> utils = do_GetInterface(window);
   NS_ENSURE_TRUE(utils, true);
   utils->SendMouseEvent(aType, aX, aY, aButton, aClickCount, aModifiers,
                         aIgnoreRootScrollFrame);
   return true;
 }
 
+static JSContext*
+GetJSContext(nsIWebNavigation* webNav)
+{
+    nsCOMPtr<nsIDOMDocument> domDocument;
+    nsCOMPtr<nsIDocument> document;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+
+    if (NS_SUCCEEDED(webNav->GetDocument(getter_AddRefs(domDocument))) &&
+        (document = do_QueryInterface(domDocument)) &&
+        (global = do_QueryInterface(document->GetScriptGlobalObject())) &&
+        (context = do_QueryInterface(global->GetContext())))
+        return static_cast<JSContext*>(context->GetNativeContext());
+
+    return NULL;
+}
+
+void
+TabChild::CreateContextWrapperAndSetGlobalObject()
+{
+    JSContext* cx;
+    PContentProcessChild* manager;
+    mozilla::jsipc::ContextWrapperChild* cwc;
+
+    if ((cx = GetJSContext(mWebNav)) &&
+        (manager = Manager()) &&
+        (cwc = new mozilla::jsipc::ContextWrapperChild(cx)))
+        manager
+            ->SendPContextWrapperConstructor(cwc, this)
+            ->SendPObjectWrapperConstructor(true);
+}
+
 mozilla::ipc::PDocumentRendererChild*
 TabChild::AllocPDocumentRenderer(
         const PRInt32& x,
         const PRInt32& y,
         const PRInt32& w,
         const PRInt32& h,
         const nsString& bgcolor,
         const PRUint32& flags,
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -119,16 +119,17 @@ public:
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
 
 private:
     nsCOMPtr<nsIWebNavigation> mWebNav;
+    void CreateContextWrapperAndSetGlobalObject();
 
     DISALLOW_EVIL_CONSTRUCTORS(TabChild);
 };
 
 }
 }
 
 #endif // mozilla_tabs_TabChild_h
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -54,16 +54,17 @@
 
 using mozilla::ipc::BrowserProcessSubThread;
 using mozilla::ipc::DocumentRendererParent;
 
 namespace mozilla {
 namespace dom {
 
 TabParent::TabParent()
+  : mContextWrapper(nsnull)
 {
 }
 
 TabParent::~TabParent()
 {
 }
 
 bool
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -35,25 +35,30 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_tabs_TabParent_h
 #define mozilla_tabs_TabParent_h
 
 #include "mozilla/dom/PIFrameEmbeddingParent.h"
+#include "mozilla/jsipc/ContextWrapperParent.h"
 
 #include "mozilla/ipc/GeckoChildProcessHost.h"
 
 #include "nsCOMPtr.h"
 #include "nsIBrowserDOMWindow.h"
 
 class nsIURI;
 class nsIDOMElement;
 
+using namespace mozilla::jsipc;
+struct JSContext;
+struct JSObject;
+
 namespace mozilla {
 namespace dom {
 
 class TabParent : public PIFrameEmbeddingParent
 {
 public:
     TabParent();
     virtual ~TabParent();
@@ -77,17 +82,28 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
     virtual bool DeallocPDocumentRenderer(PDocumentRendererParent* actor);
+
+    void SetContextWrapper(PContextWrapperParent* pcwp) {
+        mContextWrapper = static_cast<ContextWrapperParent*>(pcwp);
+    }
+
+    bool GetGlobalJSObject(JSContext* cx, JSObject** globalp) {
+        return (mContextWrapper &&
+                mContextWrapper->GetGlobalJSObject(cx, globalp));
+    }
+
 protected:
     nsIDOMElement* mFrameElement;
     nsCOMPtr<nsIBrowserDOMWindow> mBrowserDOMWindow;
+    ContextWrapperParent* mContextWrapper;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif
diff --git a/ipc/ipdl/Makefile.in b/ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in
+++ b/ipc/ipdl/Makefile.in
@@ -55,16 +55,17 @@ EXPORT_LIBRARY = 1
 ##
 IPDLDIRS =  \
   dom/plugins  \
   dom/ipc  \
   netwerk/ipc  \
   netwerk/protocol/http/src  \
   ipc/ipdl/test/cxx  \
   ipc/testshell  \
+  js/src/ipc  \
   $(NULL)
 ##-----------------------------------------------------------------------------
 
 ifdef MOZ_IPDL_TESTS
 DIRS += test
 endif
 
 vpath %.ipdl $(topsrcdir)
diff --git a/ipc/testshell/TestShellChild.h b/ipc/testshell/TestShellChild.h
--- a/ipc/testshell/TestShellChild.h
+++ b/ipc/testshell/TestShellChild.h
@@ -61,16 +61,17 @@ public:
 
   bool
   RecvPTestShellCommandConstructor(PTestShellCommandChild* aActor,
                                    const nsString& aCommand);
 
   bool
   DeallocPTestShellCommand(PTestShellCommandChild* aCommand);
 
+  XPCShellEnvironment* GetXPCShell() const { return mXPCShell; }
   void SetXPCShell(XPCShellEnvironment* aXPCShell) {
     mXPCShell = aXPCShell;
   }
 
 private:
   nsAutoPtr<XPCShellEnvironment> mXPCShell;
 };
 
diff --git a/ipc/testshell/TestShellParent.h b/ipc/testshell/TestShellParent.h
--- a/ipc/testshell/TestShellParent.h
+++ b/ipc/testshell/TestShellParent.h
@@ -43,32 +43,48 @@
 #include "mozilla/ipc/PTestShellParent.h"
 #include "mozilla/ipc/PTestShellCommandParent.h"
 
 #include "jsapi.h"
 #include "nsAutoJSValHolder.h"
 #include "nsStringGlue.h"
 
 namespace mozilla {
+
+namespace jsipc {
+class PContextWrapperParent;
+}
+
 namespace ipc {
 
+using namespace mozilla::jsipc;
+
 class TestShellCommandParent;
 
-
 class TestShellParent : public PTestShellParent
 {
 public:
   PTestShellCommandParent*
   AllocPTestShellCommand(const nsString& aCommand);
 
   bool
   DeallocPTestShellCommand(PTestShellCommandParent* aActor);
 
   bool
   CommandDone(TestShellCommandParent* aActor, const nsString& aResponse);
+
+  void SetContextWrapper(PContextWrapperParent* pcwp) {
+    mContextWrapper = pcwp;
+  }
+  PContextWrapperParent* GetContextWrapper() const {
+    return mContextWrapper;
+  }
+
+private:
+  PContextWrapperParent* mContextWrapper;
 };
 
 
 class TestShellCommandParent : public PTestShellCommandParent
 {
 public:
   TestShellCommandParent() : mCx(NULL) { }
 
diff --git a/ipc/testshell/XPCShellEnvironment.h b/ipc/testshell/XPCShellEnvironment.h
--- a/ipc/testshell/XPCShellEnvironment.h
+++ b/ipc/testshell/XPCShellEnvironment.h
@@ -68,16 +68,20 @@ public:
     JSPrincipals* GetPrincipal() {
         return mJSPrincipals;
     }
 
     JSObject* GetGlobalObject() {
         return mGlobalHolder.ToJSObject();
     }
 
+    JSContext* GetContext() {
+        return mCx;
+    }
+
     void SetExitCode(int aExitCode) {
         mExitCode = aExitCode;
     }
     int ExitCode() {
         return mExitCode;
     }
 
     void SetIsQuitting() {
@@ -124,9 +128,9 @@ private:
     JSBool mQuitting;
     JSBool mReportWarnings;
     JSBool mCompileOnly;
 };
 
 } /* namespace ipc */
 } /* namespace mozilla */
 
-#endif /* _IPC_TESTSHELL_XPCSHELLENVIRONMENT_H_ */
\ No newline at end of file
+#endif /* _IPC_TESTSHELL_XPCSHELLENVIRONMENT_H_ */
diff --git a/js/src/ipc/CPOWTypes.h b/js/src/ipc/CPOWTypes.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/CPOWTypes.h
@@ -0,0 +1,63 @@
+#ifndef mozilla_jsipc_ContextWrapperTypes_h__
+#define mozilla_jsipc_ContextWrapperTypes_h__
+
+#include "jsapi.h"
+#include "jspubtd.h"
+
+namespace mozilla {
+namespace jsipc {
+
+using namespace IPC;
+
+template <typename Type, typename As>
+struct CPOWConvertible
+{
+    static void Write(Message* m, const Type& t) {
+        WriteParam(m, As(t));
+    }
+    static bool Read(const Message* m, void** iter, Type* tp) {
+        As a;
+        return (ReadParam(m, iter, &a) &&
+                (*tp = Type(a), true));
+    }
+};
+
+struct void_t {};
+struct null_t {};
+    
+template <typename P>
+struct CPOWSingleton
+{
+    static void Write(Message*, const P&) {}
+    static bool Read(const Message*, void**, P*) { return true; }
+};
+    
+} // namespace jsipc
+} // namespace mozilla
+
+namespace IPC {
+
+using namespace mozilla::jsipc;
+
+template <> struct ParamTraits<void_t> : public CPOWSingleton<void_t> {};
+template <> struct ParamTraits<null_t> : public CPOWSingleton<null_t> {};
+
+template <> struct ParamTraits<JSType> : public CPOWConvertible<JSType, int> {};
+// We already seem to know how to serialize JSBools, huh.
+// template <> struct ParamTraits<JSBool> : public CPOWConvertible<JSBool, bool> {};
+ 
+}
+
+// TODO Use a more standard logging mechanism.
+#ifdef DEBUG
+#define CPOW_LOG(PRINTF_ARGS) \
+    JS_BEGIN_MACRO            \
+    printf("CPOW | ");        \
+    printf PRINTF_ARGS ;      \
+    printf("\n");             \
+    JS_END_MACRO
+#else
+#define CPOW_LOG(_) JS_BEGIN_MACRO JS_END_MACRO
+#endif
+
+#endif
diff --git a/js/src/ipc/ContextWrapperChild.h b/js/src/ipc/ContextWrapperChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ContextWrapperChild.h
@@ -0,0 +1,70 @@
+#ifndef mozilla_jsipc_ContextWrapperChild_h__
+#define mozilla_jsipc_ContextWrapperChild_h__
+
+#include "mozilla/jsipc/PContextWrapperChild.h"
+#include "mozilla/jsipc/ObjectWrapperChild.h"
+
+#include "jsapi.h"
+#include "nsClassHashtable.h"
+#include "nsHashKeys.h"
+
+namespace mozilla {
+namespace jsipc {
+
+class ContextWrapperChild
+    : public PContextWrapperChild
+{
+public:
+
+    ContextWrapperChild(JSContext* cx)
+        : mContext(cx)
+    {
+        mResidentObjectTable.Init();
+    }
+
+    JSContext* GetContext() { return mContext; }
+
+    PObjectWrapperChild* GetOrCreateWrapper(JSObject* obj,
+                                            bool makeGlobal = false)
+    {
+        if (!obj) // Don't wrap nothin'!
+            return NULL;
+        PObjectWrapperChild* wrapper;
+        while (!mResidentObjectTable.Get(obj, &wrapper))
+            mResidentObjectTable.Put(obj, SendPObjectWrapperConstructor(AllocPObjectWrapper(obj),
+                                                                        makeGlobal));
+        return wrapper;
+    }
+    
+    PObjectWrapperChild* GetOrCreateGlobalWrapper() {
+        return GetOrCreateWrapper(JS_GetGlobalObject(mContext), true);
+    }
+    
+protected:
+
+    PObjectWrapperChild* AllocPObjectWrapper(JSObject* obj) {
+        return new ObjectWrapperChild(mContext, obj);
+    }
+    
+    PObjectWrapperChild* AllocPObjectWrapper(const bool&) {
+        return AllocPObjectWrapper(JS_GetGlobalObject(mContext));
+    }
+
+    bool DeallocPObjectWrapper(PObjectWrapperChild* actor) {
+        ObjectWrapperChild* owc = static_cast<ObjectWrapperChild*>(actor);
+        mResidentObjectTable.Remove(owc->GetJSObject());
+        return true;
+    }
+
+private:
+    
+    JSContext* const mContext;
+
+    nsClassHashtable<nsPtrHashKey<JSObject>,
+                     PObjectWrapperChild> mResidentObjectTable;
+
+};
+
+}}
+
+#endif
diff --git a/js/src/ipc/ContextWrapperParent.h b/js/src/ipc/ContextWrapperParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ContextWrapperParent.h
@@ -0,0 +1,66 @@
+#ifndef mozilla_jsipc_ContextWrapperParent_h__
+#define mozilla_jsipc_ContextWrapperParent_h__
+
+#include "mozilla/jsipc/PContextWrapperParent.h"
+#include "mozilla/jsipc/ObjectWrapperParent.h"
+
+#include "jsapi.h"
+#include "nsAutoJSValHolder.h"
+
+namespace mozilla {
+namespace jsipc {
+    
+class ContextWrapperParent
+    : public PContextWrapperParent
+{
+public:
+
+    ContextWrapperParent() : mGlobal(NULL) {}
+
+    bool GetGlobalJSObject(JSContext* cx, JSObject** globalp) {
+        if (!mGlobal)
+            return false;
+        mGlobalHolder.Hold(cx);
+        mGlobalHolder = *globalp = mGlobal->GetJSObject(cx);
+        return true;
+    }
+
+    ObjectWrapperParent* GetGlobalObjectWrapper() const {
+        return mGlobal;
+    }
+
+private:
+
+    ObjectWrapperParent* mGlobal;
+    nsAutoJSValHolder mGlobalHolder;
+
+    PObjectWrapperParent* AllocPObjectWrapper(const bool&) {
+        return new ObjectWrapperParent();
+    }
+
+    bool RecvPObjectWrapperConstructor(PObjectWrapperParent* actor,
+                                       const bool& makeGlobal)
+    {
+        if (makeGlobal) {
+            mGlobalHolder.Release();
+            mGlobal = static_cast<ObjectWrapperParent*>(actor);
+        }
+        return true;
+    }
+
+    bool DeallocPObjectWrapper(PObjectWrapperParent* actor)
+    {
+        if (mGlobal &&
+            mGlobal == static_cast<ObjectWrapperParent*>(actor)) {
+            mGlobalHolder.Release();
+            mGlobal = NULL;
+        }
+        delete actor;
+        return true;
+    }
+
+};
+
+}}
+
+#endif
diff --git a/js/src/ipc/Makefile.in b/js/src/ipc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/Makefile.in
@@ -0,0 +1,33 @@
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = js
+LIBRARY_NAME = jsipc_s
+LIBXUL_LIBRARY = 1
+FORCE_STATIC_LIB = 1
+EXPORT_LIBRARY = 1
+
+EXPORTS_NAMESPACES = mozilla/jsipc
+
+EXPORTS_mozilla/jsipc = \
+  CPOWTypes.h \
+  ContextWrapperChild.h \
+  ContextWrapperParent.h \
+  ObjectWrapperParent.h \
+  ObjectWrapperChild.h \
+  $(NULL)
+
+CPPSRCS = \
+  ObjectWrapperParent.cpp \
+  ObjectWrapperChild.cpp \
+  $(NULL)
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/ipc/chromium/chromium-config.mk
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DBIN_SUFFIX='"$(BIN_SUFFIX)"'
diff --git a/js/src/ipc/ObjectWrapperChild.cpp b/js/src/ipc/ObjectWrapperChild.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperChild.cpp
@@ -0,0 +1,500 @@
+#include "mozilla/jsipc/ContextWrapperChild.h"
+#include "mozilla/jsipc/ObjectWrapperChild.h"
+#include "mozilla/jsipc/CPOWTypes.h"
+
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace jsipc {
+
+ObjectWrapperChild::ObjectWrapperChild(JSContext* cx, JSObject* obj)
+    : mObj(obj)
+{
+    JSAutoRequest request(cx);
+    JS_AddNamedRoot(cx, (void*)&mObj,
+                    "mozilla::jsipc::ObjectWrapperChild-rooted JSObject*");
+}
+
+void
+ObjectWrapperChild::ActorDestroy(ActorDestroyReason why)
+{
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+    JS_RemoveRoot(cx, (void*)&mObj);
+}
+
+bool
+ObjectWrapperChild::JSObject_to_JSVariant(JSContext* cx, JSObject* from,
+                                          JSVariant* to)
+{
+    *to = Manager()->GetOrCreateWrapper(from);
+    return true;
+}
+
+bool
+ObjectWrapperChild::jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_FUNCTION:
+    case JSTYPE_OBJECT:
+        return JSObject_to_JSVariant(cx, JSVAL_TO_OBJECT(from), to);
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = *JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = !!JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+        return true;
+    case JSTYPE_XML:
+        // fall through
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperChild::
+JSObject_from_PObjectWrapperChild(JSContext*,
+                                  const PObjectWrapperChild* from,
+                                  JSObject** to)
+{
+    const ObjectWrapperChild* owc =
+        static_cast<const ObjectWrapperChild*>(from);
+    *to = owc ? owc->mObj : JSVAL_NULL;
+    return true;
+}
+    
+/*static*/ bool
+ObjectWrapperChild::JSObject_from_JSVariant(JSContext* cx,
+                                            const JSVariant& from,
+                                            JSObject** to)
+{
+    if (from.type() != JSVariant::TPObjectWrapperChild)
+        return false;
+    return JSObject_from_PObjectWrapperChild(cx,
+                                             from.get_PObjectWrapperChild(),
+                                             to);
+}
+
+/*static*/ bool
+ObjectWrapperChild::jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                         jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPObjectWrapperChild:
+        {
+            JSObject* obj;
+            if (!JSObject_from_JSVariant(cx, from, &obj))
+                return false;
+            *to = OBJECT_TO_JSVAL(obj);
+            return true;
+        }
+    case JSVariant::TnsString:
+        {
+            const nsString& str = from.get_nsString();
+            JSString* s = JS_NewUCStringCopyN(cx,
+                                              str.BeginReading(),
+                                              str.Length());
+            if (!s)
+                return false;
+            *to = STRING_TO_JSVAL(s);
+        }
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+    
+ContextWrapperChild*
+ObjectWrapperChild::Manager()
+{
+    PContextWrapperChild* pcwc = PObjectWrapperChild::Manager();
+    return static_cast<ContextWrapperChild*>(pcwc);
+}
+
+static bool
+jsid_to_nsString(JSContext* cx, jsid from, nsString* to)
+{
+    jsval v;
+    if (JS_IdToValue(cx, from, &v) && JSVAL_IS_STRING(v)) {
+        *to = JS_GetStringChars(JSVAL_TO_STRING(v));
+        return true;
+    }
+    return false;
+}
+    
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    JSString* str = JS_NewUCStringCopyN(cx, from.BeginReading(), from.Length());
+    return JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+#if 0
+// The general schema for ObjectWrapperChild::Answer* methods:
+bool
+ObjectWrapperChild::AnswerSomething(/* in-parameters */
+                                    /* out-parameters */)
+{
+    // initialize out-parameters for failure
+    JSAutoRequest request(Manager()->GetContext());
+    // validate in-parameters, else return false
+    // successfully perform local JS operations, else return true
+    // perform out-parameter conversions, else return false
+    return true;
+}
+// There's an important subtlety here: though a local JS operation may
+// fail, leaving out-parameters uninitialized, we must initialize all
+// out-parameters when reporting success (returning true) to the IPC
+// messaging system.  See AnswerGetProperty for illustration.
+#endif
+
+bool
+ObjectWrapperChild::AnswerAddProperty(const nsString& id)
+{
+    jsid interned_id;
+
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    if (!jsid_from_nsString(cx, id, &interned_id))
+        return false;
+    
+    JS_DefinePropertyById(cx, mObj, interned_id, JSVAL_VOID, NULL, NULL, 0);
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerGetProperty(const nsString& id,
+                                      JSBool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = JS_FALSE;
+
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    if (!jsid_from_nsString(cx, id, &interned_id))
+        return false;
+
+    *ok = JS_GetPropertyById(cx, mObj, interned_id, &val);
+
+    // Since we fully expect this call to jsval_to_JSVariant to return
+    // true, we can't just leave vp uninitialized when JS_GetPropertyById
+    // returns JS_FALSE.  This pitfall could be avoided in general if IPDL
+    // ensured that outparams were pre-initialized to some default value
+    // (XXXfixme cjones?).
+    return jsval_to_JSVariant(cx, *ok ? val : JSVAL_VOID, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerSetProperty(const nsString& id, const JSVariant& v,
+                                      JSBool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = JS_FALSE;
+    *vp = v;
+
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    if (!jsid_from_nsString(cx, id, &interned_id) ||
+        !jsval_from_JSVariant(cx, v, &val))
+        return false;
+
+    *ok = JS_SetPropertyById(cx, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(cx, *ok ? val : JSVAL_VOID, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerDelProperty(const nsString& id,
+                                      JSBool* ok, JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = JS_FALSE;
+
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    if (!jsid_from_nsString(cx, id, &interned_id))
+        return false;
+
+    *ok = JS_DeletePropertyById2(cx, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(cx, *ok ? val : JSVAL_VOID, vp);
+}
+
+static const PRUint32 sIdArraySlot = 0, sNextIdIndexSlot = 1;
+static const PRUint32 sNumNewEnumerateStateSlots = 2;
+
+static void
+CPOW_NewEnumerateState_Finalize(JSContext* cx, JSObject* state)
+{
+    jsval v;
+    JSIdArray* ids;
+    if (JS_GetReservedSlot(cx, state, sIdArraySlot, &v) &&
+        (ids = static_cast<JSIdArray*>(JSVAL_TO_PRIVATE(v))))
+        JS_DestroyIdArray(cx, ids);
+}
+
+// Similar to IteratorClass in XPCWrapper.cpp
+static const JSClass sCPOW_NewEnumerateState_JSClass = {
+    "CPOW NewEnumerate State",
+    JSCLASS_HAS_RESERVED_SLOTS(sNumNewEnumerateStateSlots),
+    JS_PropertyStub,  JS_PropertyStub,
+    JS_PropertyStub,  JS_PropertyStub,
+    JS_EnumerateStub, JS_ResolveStub,
+    JS_ConvertStub,   CPOW_NewEnumerateState_Finalize,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+bool
+ObjectWrapperChild::AnswerNewEnumerateInit(/* no in-parameters */
+                                           JSBool* ok, JSVariant* statep, int* idp)
+{
+    *ok = JS_FALSE;
+    *idp = 0;
+
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    JSClass* clasp = const_cast<JSClass*>(&sCPOW_NewEnumerateState_JSClass);
+    JSObject* state = JS_NewObjectWithGivenProto(cx, clasp, NULL, NULL);
+    if (!state)
+        return false;
+    
+    for (JSObject* proto = mObj;
+         proto;
+         proto = JS_GetPrototype(cx, proto))
+    {
+        JSIdArray* ids = JS_Enumerate(cx, proto);
+        for (jsint i = 0; i < ids->length; ++i)
+            JS_DefinePropertyById(cx, state, ids->vector[i], JSVAL_VOID,
+                                  NULL, NULL, JSPROP_ENUMERATE | JSPROP_SHARED);
+        JS_DestroyIdArray(cx, ids);
+    }
+
+    JSIdArray* ids = JS_Enumerate(cx, state);
+    if (!ids)
+        return false;
+
+    *idp = ids->length;
+
+    *ok = (JS_SetReservedSlot(cx, state, sIdArraySlot,
+                              PRIVATE_TO_JSVAL(ids)) &&
+           JS_SetReservedSlot(cx, state, sNextIdIndexSlot,
+                              JSVAL_ZERO) &&
+           JSObject_to_JSVariant(cx, state, statep));
+
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerNewEnumerateNext(const JSVariant& in_state,
+                                           JSBool* ok, JSVariant* statep, nsString* idp)
+{
+    JSObject* state;
+    jsval v;
+    JSIdArray* ids;
+    JSString* str;
+
+    *ok = JS_FALSE;
+    *statep = in_state;
+    *idp = EmptyString();
+    
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    if (!JSObject_from_JSVariant(cx, in_state, &state) ||
+        !JS_GetReservedSlot(cx, state, sIdArraySlot, &v) ||
+        !(ids = static_cast<JSIdArray*>(JSVAL_TO_PRIVATE(v))) ||
+        !JS_GetReservedSlot(cx, state, sNextIdIndexSlot, &v))
+        return false;
+
+    int i = JSVAL_TO_INT(v);
+    if (i >= ids->length) {
+        *ok = JS_TRUE;
+        return JSObject_to_JSVariant(cx, NULL, statep);
+    }
+
+    if (!JS_IdToValue(cx, ids->vector[i], &v) ||
+        !(str = JS_ValueToString(cx, v)))
+    {
+        *ok = JS_FALSE;
+        return true;
+    }
+
+    *idp = JS_GetStringChars(str);
+    *ok = JS_SetReservedSlot(cx, state, sNextIdIndexSlot,
+                             INT_TO_JSVAL(i + 1));
+    return true;
+}
+    
+bool
+ObjectWrapperChild::RecvNewEnumerateDestroy(const JSVariant& in_state)
+{
+    JSObject* state;
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+    return (JSObject_from_JSVariant(cx, in_state, &state) &&
+            JS_SetReservedSlot(cx, state, sIdArraySlot, JSVAL_ZERO));
+}
+
+bool
+ObjectWrapperChild::AnswerIterator(/* no in-parameters */
+                                   PObjectWrapperChild** iterator)
+{
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+    JSObject* iterObj = JS_NewPropertyIterator(cx, mObj);
+    *iterator = Manager()->GetOrCreateWrapper(iterObj);
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerNewResolve(const nsString& id, const int& flags,
+                                     JSBool* ok, PObjectWrapperChild** obj2)
+{
+    jsid interned_id;
+    
+    *ok = JS_FALSE;
+    *obj2 = NULL;
+
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    if (!jsid_from_nsString(cx, id, &interned_id))
+        return false;
+
+    CPOW_LOG(("new-resolving \"%s\"...",
+              NS_ConvertUTF16toUTF8(id).get()));
+
+    JSPropertyDescriptor desc;
+    if (!JS_GetPropertyDescriptorById(cx, mObj, interned_id, flags, &desc))
+        return true;
+
+    *ok = JS_TRUE;
+
+    if (desc.obj)
+        *obj2 = Manager()->GetOrCreateWrapper(desc.obj);
+
+    return true;
+}
+
+bool
+ObjectWrapperChild::AnswerConvert(const JSType& type,
+                                  JSBool* ok, JSVariant* vp)
+{
+    jsval v;
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+    *ok = JS_ConvertValue(cx, OBJECT_TO_JSVAL(mObj), type, &v);
+    return jsval_to_JSVariant(cx, *ok ? v : JSVAL_VOID, vp);
+}
+
+bool
+ObjectWrapperChild::AnswerCall(PObjectWrapperChild* receiver, const nsTArray<JSVariant>& argv,
+                               JSBool* ok, JSVariant* rval)
+{
+    *ok = JS_FALSE;
+    
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    JSObject* obj;
+    if (!JSObject_from_PObjectWrapperChild(cx, receiver, &obj))
+        return false;
+
+    jsval rv, jsargs[argv.Length()];
+    for (PRUint32 i = 0; i < argv.Length(); ++i)
+        if (!jsval_from_JSVariant(cx, argv.ElementAt(i), jsargs + i))
+            return false;
+
+    *ok = JS_CallFunctionValue(cx, obj, OBJECT_TO_JSVAL(mObj),
+                               argv.Length(), jsargs, &rv);
+
+    return jsval_to_JSVariant(cx, *ok ? rv : JSVAL_VOID, rval);
+}
+
+bool
+ObjectWrapperChild::AnswerConstruct(const nsTArray<JSVariant>& argv,
+                                    JSBool* ok, PObjectWrapperChild** rval)
+{
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+
+    JSClass* clasp = NULL;
+    JSObject* pobj = JSVAL_NULL;
+    {
+        jsval pval;
+        if (JS_GetProperty(cx, mObj, "prototype", &pval) &&
+            JSVAL_IS_OBJECT(pval))
+        {
+            pobj = JSVAL_TO_OBJECT(pval);
+            clasp = JS_GetClass(cx, pobj);
+        }
+    }
+    JSObject* obj = JS_NewObject(cx, clasp, pobj, NULL);
+    PObjectWrapperChild* wrapper = Manager()->GetOrCreateWrapper(obj);
+
+    JSVariant override;
+    bool answer = AnswerCall(*rval = wrapper,
+                             argv, ok, &override);
+
+    // Allow the constructor to return a different object from the one
+    // allocated for it by the JS_NewObject call above.
+    if (answer &&
+        override.type() == JSVariant::TPObjectWrapperChild &&
+        (wrapper = override.get_PObjectWrapperChild()))
+        *rval = wrapper;
+
+    return answer;
+}
+
+bool
+ObjectWrapperChild::AnswerHasInstance(const JSVariant& v,
+                                      JSBool* ok, JSBool* bp)
+{
+    jsval candidate;
+    JSContext* cx = Manager()->GetContext();
+    JSAutoRequest request(cx);
+    if (!jsval_from_JSVariant(cx, v, &candidate))
+        return false;
+    *ok = JS_HasInstance(cx, mObj, candidate, bp);
+    return true;
+}
+
+}}
diff --git a/js/src/ipc/ObjectWrapperChild.h b/js/src/ipc/ObjectWrapperChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperChild.h
@@ -0,0 +1,83 @@
+#ifndef mozilla_jsipc_ObjectWrapperChild_h__
+#define mozilla_jsipc_ObjectWrapperChild_h__
+
+#include "mozilla/jsipc/PObjectWrapperChild.h"
+
+using mozilla::jsipc::JSVariant;
+
+namespace mozilla {
+namespace jsipc {
+
+class ContextWrapperChild;
+  
+class ObjectWrapperChild
+    : public PObjectWrapperChild
+{
+public:
+
+    ObjectWrapperChild(JSContext* cx, JSObject* obj);
+
+    JSObject* GetJSObject() const { return mObj; }
+    
+private:
+
+    JSObject* const mObj;
+
+    bool JSObject_to_JSVariant(JSContext* cx, JSObject* from, JSVariant* to);
+    bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+
+    static bool JSObject_from_PObjectWrapperChild(JSContext* cx,
+                                                  const PObjectWrapperChild* from,
+                                                  JSObject** to);
+    static bool JSObject_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                        JSObject** to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+
+    ContextWrapperChild* Manager();
+
+protected:
+
+    void ActorDestroy(ActorDestroyReason why);
+
+    bool AnswerAddProperty(const nsString& id);
+
+    bool AnswerGetProperty(const nsString& id,
+                           JSBool* ok, JSVariant* vp);
+
+    bool AnswerSetProperty(const nsString& id, const JSVariant& v,
+                           JSBool* ok, JSVariant* vp);
+
+    bool AnswerDelProperty(const nsString& id,
+                           JSBool* ok, JSVariant* vp);
+
+    bool AnswerNewEnumerateInit(/* no in-parameters */
+                                JSBool* ok, JSVariant* statep, int* idp);
+
+    bool AnswerNewEnumerateNext(const JSVariant& in_state,
+                                JSBool* ok, JSVariant* statep, nsString* idp);
+
+    bool RecvNewEnumerateDestroy(const JSVariant& in_state);
+
+    bool AnswerIterator(/* no in-parameters */
+                        PObjectWrapperChild** iterator);
+    
+    bool AnswerNewResolve(const nsString& id, const int& flags,
+                          JSBool* ok, PObjectWrapperChild** obj2);
+
+    bool AnswerConvert(const JSType& type,
+                       JSBool* ok, JSVariant* vp);
+
+    bool AnswerCall(PObjectWrapperChild* receiver, const nsTArray<JSVariant>& argv,
+                    JSBool* ok, JSVariant* rval);
+
+    bool AnswerConstruct(const nsTArray<JSVariant>& argv,
+                         JSBool* ok, PObjectWrapperChild** rval);
+
+    bool AnswerHasInstance(const JSVariant& v,
+                           JSBool* ok, JSBool* bp);
+};
+
+}}
+  
+#endif
diff --git a/js/src/ipc/ObjectWrapperParent.cpp b/js/src/ipc/ObjectWrapperParent.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperParent.cpp
@@ -0,0 +1,608 @@
+#include "mozilla/jsipc/ObjectWrapperParent.h"
+#include "mozilla/jsipc/ContextWrapperParent.h"
+#include "mozilla/jsipc/CPOWTypes.h"
+
+#include "jsobj.h"
+#include "jsfun.h"
+#include "jsutil.h"
+
+namespace mozilla {
+namespace jsipc {
+
+namespace {
+
+    // This shorthand saves a LOT of typing.
+    typedef ObjectWrapperParent _;
+
+    static const uintN sFlagsSlot = 0, sWrappedObjSlot = 1;
+    static const uintN sNumSlots = 2;
+    static const uintN CPOW_FLAG_RESOLVING = 1 << 0;
+
+    class AutoResolveFlag
+    {
+        JSContext* mContext;
+        JSObject* mObj;
+        uintN mOldFlags;
+        JS_DECL_USE_GUARD_OBJECT_NOTIFIER;
+
+        static uintN GetFlags(JSContext* cx, JSObject* obj) {
+            jsval v;
+            if (JS_GetReservedSlot(cx, obj, sFlagsSlot, &v))
+                return JSVAL_TO_INT(v);
+            return 0;
+        }
+        static uintN SetFlags(JSContext* cx, JSObject* obj, uintN flags) {
+            uintN oldFlags = GetFlags(cx, obj);
+            if (oldFlags != flags)
+                JS_SetReservedSlot(cx, obj, sFlagsSlot, INT_TO_JSVAL(flags));
+            return oldFlags;
+        }
+    public:
+        AutoResolveFlag(JSContext* cx,
+                        JSObject* obj
+                        JS_GUARD_OBJECT_NOTIFIER_PARAM)
+            : mContext(cx)
+            , mObj(obj)
+            , mOldFlags(SetFlags(cx, obj,
+                                 GetFlags(cx, obj) | CPOW_FLAG_RESOLVING))
+        { JS_GUARD_OBJECT_NOTIFIER_INIT; }
+        ~AutoResolveFlag() { SetFlags(mContext, mObj, mOldFlags); }
+        static JSBool IsSet(JSContext* cx, JSObject* obj) {
+            return GetFlags(cx, obj) & CPOW_FLAG_RESOLVING;
+        }
+    };
+
+}
+
+const JSExtendedClass _::sCPOW_JSClass = {
+    // JSClass (JSExtendedClass.base) initialization
+    { "CrossProcessObjectWrapper",
+      JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_IS_EXTENDED |
+      JSCLASS_HAS_RESERVED_SLOTS(sNumSlots),
+      _::CPOW_AddProperty,
+      _::CPOW_DelProperty,
+      _::CPOW_GetProperty,
+      _::CPOW_SetProperty,
+      (JSEnumerateOp) _::CPOW_NewEnumerate,
+        (JSResolveOp) _::CPOW_NewResolve,
+      _::CPOW_Convert,
+      _::CPOW_Finalize,
+      nsnull, // getObjectOps
+      nsnull, // checkAccess
+      _::CPOW_Call,
+      _::CPOW_Construct,
+      nsnull, // xdrObject
+      _::CPOW_HasInstance,
+      nsnull, // mark
+      nsnull, // reserveSlots
+    },
+
+    // JSExtendedClass initialization
+    _::CPOW_Equality,
+    nsnull, // outerObject
+    nsnull, // innerObject
+    nsnull, // _::CPOW_Iterator,
+    nsnull, // wrappedObject
+    JSCLASS_NO_RESERVED_MEMBERS
+};
+
+void
+ObjectWrapperParent::ActorDestroy(ActorDestroyReason)
+{
+    // See GetJSObject, Unwrap.
+    *mObjSlotContents = NULL;
+}
+    
+JSObject*
+ObjectWrapperParent::GetJSObject(JSContext* cx) const
+{
+    JSClass* clasp = const_cast<JSClass*>(&_::sCPOW_JSClass.base);
+    if (!mObj) {
+        mObj = JS_NewObject(cx, clasp, NULL, NULL);
+        *mObjSlotContents = this; // See ActorDestroy, Unwrap.
+        JS_SetReservedSlot(cx, mObj, sWrappedObjSlot,
+                           PRIVATE_TO_JSVAL(mObjSlotContents));
+        JS_SetReservedSlot(cx, mObj, sFlagsSlot, JSVAL_ZERO);
+    }
+    return mObj;
+}
+
+static ObjectWrapperParent*
+Unwrap(JSContext* cx, JSObject* obj)
+{
+    while (STOBJ_GET_CLASS(obj) != &_::sCPOW_JSClass.base)
+        if (!(obj = STOBJ_GET_PROTO(obj)))
+            return NULL;
+    
+    jsval info;
+
+    if (!JS_GetReservedSlot(cx, obj, sWrappedObjSlot, &info))
+        return NULL;
+
+    // See ActorDestroy, GetJSObject.
+    ObjectWrapperParent* self =
+        *static_cast<ObjectWrapperParent**>(JSVAL_TO_PRIVATE(info));
+
+    NS_ASSERTION(!self || self->GetJSObject(cx) == obj,
+                 "Wrapper and wrapped object disagree?");
+    
+    return self;
+}
+
+/*static*/ bool
+ObjectWrapperParent::jsval_to_JSVariant(JSContext* cx, jsval from,
+                                        JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_OBJECT:
+        {
+            PObjectWrapperParent* powp;
+            if (!JSObject_to_PObjectWrapperParent(cx, JSVAL_TO_OBJECT(from), &powp))
+                return false;
+            *to = powp;
+            return true;
+        }
+    case JSTYPE_FUNCTION:
+        // CPOW-wrapped functions have JSTYPE_OBJECT, so this function
+        // must be unknown to the child process.
+        return false;
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = *JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = !!JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+    case JSTYPE_XML:
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperParent::jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                          jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPObjectWrapperParent:
+        return jsval_from_PObjectWrapperParent(cx, from.get_PObjectWrapperParent(), to);
+    case JSVariant::TnsString:
+        *to = STRING_TO_JSVAL(JS_NewUCStringCopyZ(cx, from.get_nsString().BeginReading()));
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+ObjectWrapperParent::
+JSObject_to_PObjectWrapperParent(JSContext* cx, JSObject* from,
+                                 PObjectWrapperParent** to)
+{
+    ObjectWrapperParent* owp = Unwrap(cx, from);
+    if (!owp)
+        return false;
+    *to = owp;
+    return true;
+}
+
+/*static*/ bool
+ObjectWrapperParent::
+JSObject_from_PObjectWrapperParent(JSContext* cx,
+                                   const PObjectWrapperParent* from,
+                                   JSObject** to)
+{
+    const ObjectWrapperParent* owp =
+        static_cast<const ObjectWrapperParent*>(from);
+    *to = owp
+        ? owp->GetJSObject(cx)
+        : JSVAL_TO_OBJECT(JSVAL_NULL);
+    return true;
+}
+
+/*static*/ bool
+ObjectWrapperParent::
+jsval_from_PObjectWrapperParent(JSContext* cx,
+                                const PObjectWrapperParent* from,
+                                jsval* to)
+{
+    JSObject* obj;
+    if (!JSObject_from_PObjectWrapperParent(cx, from, &obj))
+        return false;
+    *to = OBJECT_TO_JSVAL(obj);
+    return true;
+}
+    
+static bool
+jsid_from_int(JSContext* cx, int from, jsid* to)
+{
+    jsval v = INT_TO_JSVAL(from);
+    return JS_ValueToId(cx, v, to);
+}
+
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    JSString* str = JS_NewUCStringCopyZ(cx, from.BeginReading());
+    return JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+static bool
+jsval_to_nsString(JSContext* cx, jsval from, nsString* to)
+{
+    JSString* str;
+    if ((str = JS_ValueToString(cx, from))) {
+        *to = JS_GetStringChars(str);
+        return true;
+    }
+    return false;
+}
+
+#define JSVAL_TO_CSTR(CX, V) \
+    NS_ConvertUTF16toUTF8(nsString(JS_GetStringChars(JS_ValueToString(CX, V)))).get()
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_AddProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CPOW_LOG(("Calling CPOW_AddProperty (%s)...",
+              JSVAL_TO_CSTR(cx, id)));
+
+    // Unwrap always has to come first!
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    if (AutoResolveFlag::IsSet(cx, obj))
+        return JS_TRUE;
+    
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    return self->CallAddProperty(in_id);
+}    
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_GetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CPOW_LOG(("Calling CPOW_GetProperty (%s)...",
+              JSVAL_TO_CSTR(cx, id)));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    JSBool out_ok;
+    JSVariant out_v;
+    
+    return (self->CallGetProperty(in_id,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_SetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CPOW_LOG(("Calling CPOW_SetProperty (%s)...",
+              JSVAL_TO_CSTR(cx, id)));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+    JSVariant in_v;
+
+    if (!jsval_to_nsString(cx, id, &in_id) ||
+        !self->jsval_to_JSVariant(cx, *vp, &in_v))
+        return JS_FALSE;
+    
+    JSBool out_ok;
+    JSVariant out_v;
+
+    return (self->CallSetProperty(in_id, in_v,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}    
+    
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_DelProperty(JSContext *cx, JSObject *obj, jsval id,
+                                      jsval *vp)
+{
+    CPOW_LOG(("Calling CPOW_DelProperty (%s)...",
+              JSVAL_TO_CSTR(cx, id)));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    JSBool out_ok;
+    JSVariant out_v;
+    
+    return (self->CallDelProperty(in_id,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_v, vp));
+}
+
+JSBool
+ObjectWrapperParent::NewEnumerateInit(JSContext* cx, jsval* statep, jsid* idp)
+{
+    JSBool out_ok;
+    JSVariant out_state;
+    int out_id;
+
+    return (CallNewEnumerateInit(&out_ok, &out_state, &out_id) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_state, statep) &&
+            (!idp || jsid_from_int(cx, out_id, idp)));
+}
+
+JSBool
+ObjectWrapperParent::NewEnumerateNext(JSContext* cx, jsval* statep, jsid* idp)
+{
+    JSVariant in_state;
+    if (!jsval_to_JSVariant(cx, *statep, &in_state))
+        return JS_FALSE;
+
+    JSBool out_ok;
+    JSVariant out_state;
+    nsString out_id;
+
+    if (CallNewEnumerateNext(in_state,
+                             &out_ok, &out_state, &out_id) &&
+        out_ok &&
+        jsval_from_JSVariant(cx, out_state, statep) &&
+        jsid_from_nsString(cx, out_id, idp))
+    {
+        JSObject* obj = GetJSObject(cx);
+        AutoResolveFlag arf(cx, obj);
+        return JS_DefinePropertyById(cx, obj, *idp, JSVAL_VOID, NULL, NULL,
+                                     JSPROP_ENUMERATE);
+    }
+    return JS_FALSE;
+}
+
+JSBool
+ObjectWrapperParent::NewEnumerateDestroy(JSContext* cx, jsval state)
+{
+    JSVariant in_state;
+    if (!jsval_to_JSVariant(cx, state, &in_state))
+        return JS_FALSE;
+
+    return SendNewEnumerateDestroy(in_state);
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_NewEnumerate(JSContext *cx, JSObject *obj,
+                                       JSIterateOp enum_op, jsval *statep,
+                                       jsid *idp)
+{
+    CPOW_LOG(("Calling CPOW_NewEnumerate..."));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;    
+
+    switch (enum_op) {
+    case JSENUMERATE_INIT:
+        return self->NewEnumerateInit(cx, statep, idp);
+    case JSENUMERATE_NEXT:
+        return self->NewEnumerateNext(cx, statep, idp);
+    case JSENUMERATE_DESTROY:
+        return self->NewEnumerateDestroy(cx, *statep);
+    }
+
+    return JS_FALSE;
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_NewResolve(JSContext *cx, JSObject *obj, jsval id,
+                                     uintN flags, JSObject **objp)
+{
+    CPOW_LOG(("Calling CPOW_NewResolve (%s)...",
+              JSVAL_TO_CSTR(cx, id)));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    JSBool out_ok;
+    PObjectWrapperParent* out_pobj;
+
+    if (!self->CallNewResolve(in_id, flags,
+                              &out_ok, &out_pobj) ||
+        !out_ok ||
+        !JSObject_from_PObjectWrapperParent(cx, out_pobj, objp))
+        return JS_FALSE;
+
+    jsid interned_id;
+    if (*objp &&
+        JS_ValueToId(cx, id, &interned_id)) {
+        AutoResolveFlag arf(cx, *objp);
+        JS_DefinePropertyById(cx, *objp, interned_id, JSVAL_VOID, NULL, NULL,
+                              JSPROP_ENUMERATE);
+    }
+    return JS_TRUE;
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Convert(JSContext *cx, JSObject *obj, JSType type,
+                                  jsval *vp)
+{
+    CPOW_LOG(("Calling CPOW_Convert (to %s)...",
+              JS_GetTypeName(cx, type)));
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    *vp = OBJECT_TO_JSVAL(obj);
+
+    return JS_TRUE;
+}
+
+/*static*/ void
+ObjectWrapperParent::CPOW_Finalize(JSContext* cx, JSObject* obj)
+{
+    CPOW_LOG(("Calling CPOW_Finalize..."));
+    
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (self)
+        ObjectWrapperParent::Send__delete__(self);
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Call(JSContext* cx, JSObject* obj, uintN argc,
+                               jsval* argv, jsval* rval)
+{
+    CPOW_LOG(("Calling CPOW_Call..."));
+
+    ObjectWrapperParent* function =
+        Unwrap(cx, JSVAL_TO_OBJECT(JS_ARGV_CALLEE(argv)));
+    if (!function)
+        return JS_FALSE;
+
+    ObjectWrapperParent* receiver = Unwrap(cx, obj);
+    if (!receiver) {
+        // Substitute child global for parent global object.
+        // TODO First make sure we're really replacing the global object?
+        ContextWrapperParent* manager =
+            static_cast<ContextWrapperParent*>(function->Manager());
+        receiver = manager->GetGlobalObjectWrapper();
+    }
+
+    nsTArray<JSVariant> in_argv(argc);
+    for (uintN i = 0; i < argc; i++)
+        if (!jsval_to_JSVariant(cx, argv[i], in_argv.AppendElement()))
+            return JS_FALSE;
+    
+    JSBool out_ok;
+    JSVariant out_rval;
+
+    return (function->CallCall(receiver, in_argv,
+                               &out_ok, &out_rval) &&
+            out_ok &&
+            jsval_from_JSVariant(cx, out_rval, rval));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Construct(JSContext *cx, JSObject *obj, uintN argc,
+                                    jsval *argv, jsval *rval)
+{
+    CPOW_LOG(("Calling CPOW_Construct..."));
+    
+    ObjectWrapperParent* constructor =
+        Unwrap(cx, JSVAL_TO_OBJECT(JS_ARGV_CALLEE(argv)));
+    if (!constructor)
+        return JS_FALSE;
+
+    nsTArray<JSVariant> in_argv(argc);
+    for (uintN i = 0; i < argc; i++)
+        if (!jsval_to_JSVariant(cx, argv[i], in_argv.AppendElement()))
+            return JS_FALSE;
+
+    JSBool out_ok;
+    PObjectWrapperParent* out_powp;
+
+    return (constructor->CallConstruct(in_argv,
+                                       &out_ok, &out_powp) &&
+            out_ok &&
+            jsval_from_PObjectWrapperParent(cx, out_powp, rval));
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_HasInstance(JSContext *cx, JSObject *obj, jsval v,
+                                      JSBool *bp)
+{
+    CPOW_LOG(("Calling CPOW_HasInstance..."));
+
+    *bp = JS_FALSE;
+
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    JSVariant in_v;
+
+    if (!jsval_to_JSVariant(cx, v, &in_v))
+        return JS_FALSE;
+
+    JSBool out_ok;
+
+    return (self->CallHasInstance(in_v,
+                                  &out_ok, bp) &&
+            out_ok);
+}
+
+/*static*/ JSBool
+ObjectWrapperParent::CPOW_Equality(JSContext *cx, JSObject *obj, jsval v,
+                                   JSBool *bp)
+{
+    CPOW_LOG(("Calling CPOW_Equality..."));
+
+    *bp = JS_FALSE;
+    
+    ObjectWrapperParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    if (JSVAL_IS_PRIMITIVE(v))
+        return JS_TRUE;
+
+    ObjectWrapperParent* other = Unwrap(cx, JSVAL_TO_OBJECT(v));
+    if (!other)
+        return JS_TRUE;
+
+    *bp = (self == other);
+    
+    return JS_TRUE;
+}
+
+}}
diff --git a/js/src/ipc/ObjectWrapperParent.h b/js/src/ipc/ObjectWrapperParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ObjectWrapperParent.h
@@ -0,0 +1,99 @@
+#ifndef mozilla_jsipc_ObjectWrapperParent_h__
+#define mozilla_jsipc_ObjectWrapperParent_h__
+
+#include "mozilla/jsipc/PObjectWrapperParent.h"
+#include "jsapi.h"
+#include "nsAutoJSValHolder.h"
+
+namespace mozilla {
+namespace jsipc {
+
+class ObjectWrapperParent
+    : public PObjectWrapperParent
+{
+public:
+
+    ObjectWrapperParent()
+        : mObj(NULL)
+        , mObjSlotContents(new ObjectWrapperParent const*(NULL))
+    {}
+
+    JSObject* GetJSObject(JSContext* cx) const;
+
+    jsval GetJSVal(JSContext* cx) const {
+        return OBJECT_TO_JSVAL(GetJSObject(cx));
+    }
+
+    static const JSExtendedClass sCPOW_JSClass;
+
+protected:
+
+    void ActorDestroy(ActorDestroyReason why);
+
+private:
+
+    mutable JSObject* mObj;
+    ObjectWrapperParent const** const mObjSlotContents;
+
+    static JSBool
+    CPOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    CPOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    CPOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+    
+    static JSBool
+    CPOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    JSBool NewEnumerateInit(JSContext* cx, jsval* statep, jsid* idp);
+    JSBool NewEnumerateNext(JSContext* cx, jsval* statep, jsid* idp);
+    JSBool NewEnumerateDestroy(JSContext* cx, jsval state);
+    static JSBool
+    CPOW_NewEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
+                      jsval *statep, jsid *idp);
+
+    static JSBool
+    CPOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
+                    JSObject **objp);
+
+    static JSBool
+    CPOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
+
+    static void
+    CPOW_Finalize(JSContext* cx, JSObject* obj);
+
+    static JSBool
+    CPOW_Call(JSContext* cx, JSObject* obj, uintN argc, jsval* argv,
+              jsval* rval);
+
+    static JSBool
+    CPOW_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                   jsval *rval);
+    
+    static JSBool
+    CPOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
+
+    static JSBool
+    CPOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
+
+    static bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+    static bool
+    JSObject_to_PObjectWrapperParent(JSContext* cx, JSObject* from,
+                                     PObjectWrapperParent** to);
+    static bool
+    JSObject_from_PObjectWrapperParent(JSContext* cx,
+                                       const PObjectWrapperParent* from,
+                                       JSObject** to);
+    static bool
+    jsval_from_PObjectWrapperParent(JSContext* cx,
+                                    const PObjectWrapperParent* from,
+                                    jsval* to);
+};
+
+}}
+  
+#endif
diff --git a/js/src/ipc/PContextWrapper.ipdl b/js/src/ipc/PContextWrapper.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PContextWrapper.ipdl
@@ -0,0 +1,16 @@
+include protocol "PContentProcess.ipdl";
+include protocol "PObjectWrapper.ipdl";
+
+namespace mozilla {
+namespace jsipc {
+
+rpc protocol PContextWrapper
+{
+    manager PContentProcess;
+    manages PObjectWrapper;
+parent:
+    __delete__();
+    sync PObjectWrapper(bool makeGlobal);
+};
+
+}}
diff --git a/js/src/ipc/PObjectWrapper.ipdl b/js/src/ipc/PObjectWrapper.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PObjectWrapper.ipdl
@@ -0,0 +1,84 @@
+include protocol "PContextWrapper.ipdl";
+
+include "mozilla/jsipc/CPOWTypes.h";
+
+using mozilla::jsipc::void_t;
+using mozilla::jsipc::null_t;
+using JSType;
+using JSBool;
+
+namespace mozilla {
+namespace jsipc {
+
+union JSVariant {
+    void_t;
+    nullable PObjectWrapper;
+    nsString;
+    int;
+    double;
+    bool; // We'd like to use JSBool here, but JSBool is really JSIntn,
+          // and IPC::ParamTraits mistakes JSIntn for int.
+    null_t;
+};
+
+rpc protocol PObjectWrapper
+{
+    manager PContextWrapper;
+
+child:
+    __delete__(); // unroot
+
+    rpc AddProperty(nsString id);
+
+    rpc GetProperty(nsString id)
+        returns (JSBool ok,
+                 JSVariant vp);
+
+    rpc SetProperty(nsString id,
+                    JSVariant v)
+        returns (JSBool ok,
+                 JSVariant vp);
+
+    rpc DelProperty(nsString id)
+        returns (JSBool ok,
+                 JSVariant vp);
+
+    rpc NewEnumerateInit()
+        returns (JSBool ok,
+                 JSVariant statep,
+                 int idp);
+
+    rpc NewEnumerateNext(JSVariant in_state)
+        returns (JSBool ok,
+                 JSVariant statep,
+                 nsString idp);
+
+    async NewEnumerateDestroy(JSVariant in_state);
+
+    rpc Iterator()
+        returns (PObjectWrapper iterator);
+
+    rpc NewResolve(nsString id,
+                   int flags)
+        returns (JSBool ok,
+                 nullable PObjectWrapper obj2);
+
+    rpc Convert(JSType type)
+        returns (JSBool ok,
+                 JSVariant vp);
+
+    rpc Call(PObjectWrapper receiver,
+             JSVariant[] argv)
+        returns (JSBool ok,
+                 JSVariant rval);
+
+    rpc Construct(JSVariant[] argv)
+        returns (JSBool ok,
+                 PObjectWrapper rval);
+
+    rpc HasInstance(JSVariant v)
+        returns (JSBool ok,
+                 JSBool bp);
+};
+
+}}
diff --git a/js/src/ipc/ipdl.mk b/js/src/ipc/ipdl.mk
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ipdl.mk
@@ -0,0 +1,4 @@
+IPDLSRCS = \
+  PContextWrapper.ipdl \
+  PObjectWrapper.ipdl \
+  $(NULL)
diff --git a/js/src/xpconnect/shell/xpcshell.cpp b/js/src/xpconnect/shell/xpcshell.cpp
--- a/js/src/xpconnect/shell/xpcshell.cpp
+++ b/js/src/xpconnect/shell/xpcshell.cpp
@@ -688,16 +688,31 @@ SendCommand(JSContext* cx,
     if (!XRE_SendTestShellCommand(cx, str, argc > 1 ? &argv[1] : nsnull)) {
         JS_ReportError(cx, "Couldn't send command!");
         return JS_FALSE;
     }
 
     return JS_TRUE;
 }
 
+static JSBool
+GetChildGlobalObject(JSContext* cx,
+                     JSObject*,
+                     uintN,
+                     jsval*,
+                     jsval* rval)
+{
+    JSObject* global;
+    if (XRE_GetChildGlobalObject(cx, &global)) {
+        *rval = OBJECT_TO_JSVAL(global);
+        return JS_TRUE;
+    }
+    return JS_FALSE;
+}
+
 #endif // MOZ_IPC
 
 /*
  * JSContext option name to flag map. The option names are in alphabetical
  * order for better reporting.
  */
 static const struct {
     const char  *name;
@@ -805,16 +820,17 @@ static JSFunctionSpec glob_functions[] =
     {"gc",              GC,             0,0,0},
     {"clear",           Clear,          1,0,0},
     {"options",         Options,        0,0,0},
 #ifdef DEBUG
     {"dumpHeap",        DumpHeap,       5,0,0},
 #endif
 #ifdef MOZ_IPC
     {"sendCommand",     SendCommand,    1,0,0},
+    {"getChildGlobalObject", GetChildGlobalObject, 0,0,0},
 #endif
 #ifdef MOZ_SHARK
     {"startShark",      js_StartShark,      0,0,0},
     {"stopShark",       js_StopShark,       0,0,0},
     {"connectShark",    js_ConnectShark,    0,0,0},
     {"disconnectShark", js_DisconnectShark, 0,0,0},
 #endif
 #ifdef MOZ_CALLGRIND
diff --git a/toolkit/library/libxul-config.mk b/toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk
+++ b/toolkit/library/libxul-config.mk
@@ -88,16 +88,17 @@ RCFLAGS += -i $(topsrcdir)/widget/src/os
 endif
 
 LOCAL_INCLUDES += -I$(topsrcdir)/widget/src/os2
 endif
 
 # dependent libraries
 ifdef MOZ_IPC
 STATIC_LIBS += \
+  jsipc_s \
   domipc_s \
   domplugins_s \
   mozipc_s \
   mozipdlgen_s \
   chromium_s \
   ipcshell_s \
   gfxipc_s \
   $(NULL)
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -201,16 +201,20 @@ MAKEFILES_xpconnect="
   js/src/xpconnect/loader/Makefile
   js/src/xpconnect/tests/Makefile
   js/src/xpconnect/tests/components/Makefile
   js/src/xpconnect/tests/idl/Makefile
   js/src/xpconnect/tools/Makefile
   js/src/xpconnect/tools/idl/Makefile
 "
 
+MAKEFILES_jsipc="
+  js/src/ipc/Makefile
+"
+
 MAKEFILES_jsdebugger="
   js/jsd/Makefile
   js/jsd/idl/Makefile
 "
 
 MAKEFILES_jsctypes="
   js/ctypes/Makefile
 "
@@ -846,16 +850,17 @@ add_makefiles "
   $MAKEFILES_db
   $MAKEFILES_dom
   $MAKEFILES_editor
   $MAKEFILES_xmlparser
   $MAKEFILES_gfx
   $MAKEFILES_htmlparser
   $MAKEFILES_intl
   $MAKEFILES_xpconnect
+  $MAKEFILES_jsipc
   $MAKEFILES_jsdebugger
   $MAKEFILES_jsctypes
   $MAKEFILES_content
   $MAKEFILES_layout
   $MAKEFILES_libimg
   $MAKEFILES_libjar
   $MAKEFILES_libreg
   $MAKEFILES_libpref
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -76,17 +76,17 @@ ifeq ($(OS_ARCH),WINCE)
 tier_external_dirs += modules/lib7z
 endif
 
 #
 # tier "gecko" - core components
 #
 
 ifdef MOZ_IPC
-tier_gecko_dirs += ipc
+tier_gecko_dirs += ipc js/src/ipc
 endif
 
 tier_gecko_dirs += \
 		$(tier_necko_dirs) \
 		js/src/xpconnect \
 		js/ctypes \
 		intl/chardet \
 		$(NULL)
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -82,16 +82,18 @@
 #include "mozilla/ipc/GeckoThread.h"
 #include "ScopedXREEmbed.h"
 
 #include "mozilla/plugins/PluginThreadChild.h"
 #include "mozilla/dom/ContentProcessThread.h"
 #include "mozilla/dom/ContentProcessParent.h"
 #include "mozilla/dom/ContentProcessChild.h"
 
+#include "mozilla/jsipc/ContextWrapperParent.h"
+
 #include "mozilla/ipc/TestShellParent.h"
 #include "mozilla/ipc/XPCShellEnvironment.h"
 #include "mozilla/Monitor.h"
 
 #ifdef MOZ_IPDL_TESTS
 #include "mozilla/_ipdltest/IPDLUnitTests.h"
 #include "mozilla/_ipdltest/IPDLUnitTestThreadChild.h"
 
@@ -102,16 +104,20 @@ using mozilla::ipc::GeckoChildProcessHos
 using mozilla::ipc::GeckoThread;
 using mozilla::ipc::BrowserProcessSubThread;
 using mozilla::ipc::ScopedXREEmbed;
 
 using mozilla::plugins::PluginThreadChild;
 using mozilla::dom::ContentProcessThread;
 using mozilla::dom::ContentProcessParent;
 using mozilla::dom::ContentProcessChild;
+
+using mozilla::jsipc::PContextWrapperParent;
+using mozilla::jsipc::ContextWrapperParent;
+
 using mozilla::ipc::TestShellParent;
 using mozilla::ipc::TestShellCommandParent;
 using mozilla::ipc::XPCShellEnvironment;
 
 using mozilla::Monitor;
 using mozilla::MonitorAutoEnter;
 
 using mozilla::startup::sChildProcessType;
@@ -502,48 +508,66 @@ XRE_ShutdownChildProcess()
     MessageLoop* ioLoop = XRE_GetIOMessageLoop();
     NS_ABORT_IF_FALSE(!!ioLoop, "Bad shutdown order");
 
     ioLoop->PostTask(FROM_HERE, new MessageLoop::QuitTask());
 }
 
 namespace {
 TestShellParent* gTestShellParent = nsnull;
+TestShellParent* GetOrCreateTestShellParent()
+{
+    if (!gTestShellParent) {
+        ContentProcessParent* parent = ContentProcessParent::GetSingleton();
+        NS_ENSURE_TRUE(parent, nsnull);
+        gTestShellParent = parent->CreateTestShell();
+        NS_ENSURE_TRUE(gTestShellParent, nsnull);
+    }
+    return gTestShellParent;
+}
 }
 
 bool
 XRE_SendTestShellCommand(JSContext* aCx,
                          JSString* aCommand,
                          void* aCallback)
 {
-    if (!gTestShellParent) {
-        ContentProcessParent* parent = ContentProcessParent::GetSingleton();
-        NS_ENSURE_TRUE(parent, false);
-
-        gTestShellParent = parent->CreateTestShell();
-        NS_ENSURE_TRUE(gTestShellParent, false);
-    }
+    TestShellParent* tsp = GetOrCreateTestShellParent();
+    NS_ENSURE_TRUE(tsp, false);
 
     nsDependentString command((PRUnichar*)JS_GetStringChars(aCommand),
                               JS_GetStringLength(aCommand));
     if (!aCallback) {
-        return gTestShellParent->SendExecuteCommand(command);
+        return tsp->SendExecuteCommand(command);
     }
 
     TestShellCommandParent* callback = static_cast<TestShellCommandParent*>(
-        gTestShellParent->SendPTestShellCommandConstructor(command));
+        tsp->SendPTestShellCommandConstructor(command));
     NS_ENSURE_TRUE(callback, false);
 
     jsval callbackVal = *reinterpret_cast<jsval*>(aCallback);
     NS_ENSURE_TRUE(callback->SetCallback(aCx, callbackVal), false);
 
     return true;
 }
 
 bool
+XRE_GetChildGlobalObject(JSContext* aCx, JSObject** aGlobalP)
+{
+    TestShellParent* tsp = GetOrCreateTestShellParent();
+    NS_ENSURE_TRUE(tsp, false);
+
+    PContextWrapperParent* pcwp = tsp->GetContextWrapper();
+    ContextWrapperParent* cwp =
+        static_cast<ContextWrapperParent*>(pcwp);
+    
+    return cwp->GetGlobalJSObject(aCx, aGlobalP);
+}
+
+bool
 XRE_ShutdownTestShell()
 {
   if (!gTestShellParent)
     return true;
   return ContentProcessParent::GetSingleton()->DestroyTestShell(gTestShellParent);
 }
 
 #endif // MOZ_IPC
diff --git a/xpcom/build/nsXULAppAPI.h b/xpcom/build/nsXULAppAPI.h
--- a/xpcom/build/nsXULAppAPI.h
+++ b/xpcom/build/nsXULAppAPI.h
@@ -498,12 +498,18 @@ XRE_API(MessageLoop*,
 
 struct JSContext;
 struct JSString;
 
 XRE_API(bool,
         XRE_SendTestShellCommand, (JSContext* aCx,
                                    JSString* aCommand,
                                    void* aCallback))
+struct JSObject;
+
+XRE_API(bool,
+        XRE_GetChildGlobalObject, (JSContext* aCx,
+                                   JSObject** globalp))
+
 XRE_API(bool,
         XRE_ShutdownTestShell, ())
 
 #endif // _nsXULAppAPI_h__
