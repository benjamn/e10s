From: Serge Gautherie <sgautherie.bz@free.fr>

Bug 493748 - update xpchell harness to work with winmo;
(AAv1) Unregress --test-path, Some rewrites, Whitespace cleanup.

diff --git a/testing/xpcshell/runxpcshelltests.py b/testing/xpcshell/runxpcshelltests.py
--- a/testing/xpcshell/runxpcshelltests.py
+++ b/testing/xpcshell/runxpcshelltests.py
@@ -88,17 +88,17 @@ class XPCShellTests(object):
     # we assume that httpd.js lives in components/ relative to xpcshell
     self.httpdJSPath = os.path.join(os.path.dirname(self.xpcshell), 'components', 'httpd.js')
     self.httpdJSPath = replaceBackSlashes(self.httpdJSPath)
 
     if self.xrePath is None:
       self.xrePath = os.path.dirname(self.xpcshell)
     else:
       self.xrePath = os.path.abspath(self.xrePath)
-            
+
   def buildEnvironment(self):
     """
       Create and returns a dictionary of self.env to include all the appropriate env variables and values.
       On a remote system, we overload this to set different values and are missing things like os.environ and PATH.
     """
     self.env = dict(os.environ)
     # Make assertions fatal
     self.env["XPCOM_DEBUG_BREAK"] = "stack-and-abort"
@@ -171,17 +171,17 @@ class XPCShellTests(object):
       if self.testPath.endswith('.js'):
         # Split into path and file.
         if self.testPath.find('/') == -1:
           # Test only.
           self.singleFile = self.testPath
           self.testPath = None
         else:
           # Both path and test.
-          # Reuse |testPath| temporarily.
+          # Reuse |self.testPath| temporarily.
           self.testPath = self.testPath.rsplit('/', 1)
           self.singleFile = self.testPath[1]
           self.testPath = self.testPath[0]
       else:
         # Path only.
         # Simply remove optional ending separator.
         self.testPath = self.testPath.rstrip("/")
 
@@ -199,82 +199,80 @@ class XPCShellTests(object):
       as in "h1-h2-h3 then t3-t2-t1".
 
       On a remote system, this is overloaded to list files in a remote directory structure.
     """
     return [f for f in reversed(sorted(glob(os.path.join(testdir, "tail_*.js")))) if os.path.isfile(f)]
 
   def getTestFiles(self, testdir):
     """
-      Ff a single test file was specified, we only want to execute that test,
+      If a single test file was specified, we only want to execute that test,
       otherwise return a list of all tests in a directory
 
       On a remote system, this is overloaded to find files in the remote directory structure.
     """
     testfiles = sorted(glob(os.path.join(testdir, "test_*.js")))
     if self.singleFile:
-      if singleFile in [os.path.basename(x) for x in testfiles]:
-        testfiles = [os.path.join(testdir, singleFile)]
+      if self.singleFile in [os.path.basename(x) for x in testfiles]:
+        testfiles = [os.path.join(testdir, self.singleFile)]
       else: # not in this dir? skip it
         return None
-            
+
     return testfiles
 
   def setupProfileDir(self):
     """
       Create a temporary folder for the profile and set appropriate environment variables.
 
       On a remote system, we overload this to use a remote path structure.
     """
-    profileDir = mkdtemp()
-    self.env["XPCSHELL_TEST_PROFILE_DIR"] = profileDir
-    return profileDir
+    self.profileDir = mkdtemp()
+    self.env["XPCSHELL_TEST_PROFILE_DIR"] = self.profileDir
 
   def setupLeakLogging(self):
     """
       Enable leaks (only) detection to its own log file and set environment variables.
 
       On a remote system, we overload this to use a remote filename and path structure
     """
     filename = "runxpcshelltests_leaks.log"
 
-    leakLogFile = os.path.join(self.profileDir,  filename)
-    self.env["XPCOM_MEM_LEAK_LOG"] = leakLogFile
-    return leakLogFile
+    self.leakLogFile = os.path.join(self.profileDir,  filename)
+    self.env["XPCOM_MEM_LEAK_LOG"] = self.leakLogFile
 
   def launchProcess(self, cmd, stdout, stderr, env, cwd):
     """
       Simple wrapper to launch a process.
       On a remote system, this is more complex and we need to overload this function.
     """
-    proc = Popen(cmd, stdout=stdout, stderr=stderr, 
+    proc = Popen(cmd, stdout=stdout, stderr=stderr,
                 env=env, cwd=cwd)
     return proc
 
   def communicate(self, proc):
     """
       Simple wrapper to communicate with a process.
       On a remote system, this is overloaded to handle remote process communication.
     """
     return proc.communicate()
-        
+
   def removeDir(self, dirname):
     """
       Simple wrapper to remove (recursively) a given directory.
       On a remote system, we need to overload this to work on the remote filesystem.
     """
     shutil.rmtree(dirname)
 
   def verifyDirPath(self, dirname):
     """
       Simple wrapper to get the absolute path for a given directory name.
       On a remote system, we need to overload this to work on the remote filesystem.
     """
     return os.path.abspath(dirname)
-        
+
   def getReturnCode(self, proc):
     """
       Simple wrapper to get the return code for a given process.
       On a remote system we overload this to work with the remote process management.
     """
     return proc.returncode
 
   def createLogFile(self, test, stdout):
@@ -330,22 +328,22 @@ class XPCShellTests(object):
     |logfiles|, if set to False, indicates not to save output to log files.
       Non-interactive only option.
     |debuggerInfo|, if set, specifies the debugger and debugger arguments
       that will be used to launch xpcshell.
     """
 
     self.xpcshell = xpcshell
     self.xrePath = xrePath
-    self.symbolsPath = symbolsPath
-    self.manifest = manifest
-    self.testdirs = testdirs
+    # self.symbolsPath = symbolsPath
+    # self.manifest = manifest
+    # self.testdirs = testdirs
     self.testPath = testPath
     self.interactive = interactive
-    self.logfiles = logfiles
+    # self.logfiles = logfiles
     self.debuggerInfo = debuggerInfo
 
     if not testdirs and not manifest:
       # nothing to test!
       print >>sys.stderr, "Error: No test dirs or test manifest specified!"
       return False
 
     passCount = 0
@@ -361,69 +359,69 @@ class XPCShellTests(object):
       testdirs = self.readManifest(os.path.abspath(manifest))
 
     self.buildTestPath()
 
     # Process each test directory individually.
     for testdir in testdirs:
       self.buildXpcsCmd(testdir)
 
-      if testPath and not testdir.endswith(testPath):
+      if self.testPath and not testdir.endswith(self.testPath):
         continue
 
       testdir = os.path.abspath(testdir)
 
       testHeadFiles = self.getHeadFiles(testdir)
       testTailFiles = self.getTailFiles(testdir)
 
       testfiles = self.getTestFiles(testdir)
       if testfiles == None:
         continue
 
       cmdH = self.buildCmdHead(testHeadFiles, testTailFiles, self.xpcsCmd)
 
       # Now execute each test individually.
       for test in testfiles:
         # create a temp dir that the JS harness can stick a profile in
-        self.profileDir = self.setupProfileDir()
-        self.leakLogFile = self.setupLeakLogging()
+        self.setupProfileDir()
+        self.setupLeakLogging()
 
         # The test file will have to be loaded after the head files.
         cmdT = ['-e', 'const _TEST_FILE = ["%s"];' %
                 replaceBackSlashes(os.path.join(testdir, test))]
 
         try:
           proc = self.launchProcess(cmdH + cmdT + self.xpcsRunArgs,
                       stdout=pStdout, stderr=pStderr, env=self.env, cwd=testdir)
 
           # allow user to kill hung subprocess with SIGINT w/o killing this script
           # - don't move this line above Popen, or child will inherit the SIG_IGN
           signal.signal(signal.SIGINT, signal.SIG_IGN)
           # |stderr == None| as |pStderr| was either |None| or redirected to |stdout|.
           stdout, stderr = self.communicate(proc)
           signal.signal(signal.SIGINT, signal.SIG_DFL)
 
-          if interactive:
+          if self.interactive:
             # Not sure what else to do here...
             return True
 
           if (self.getReturnCode(proc) != 0) or (stdout and re.search("^TEST-UNEXPECTED-FAIL", stdout, re.MULTILINE)):
             print """TEST-UNEXPECTED-FAIL | %s | test failed (with xpcshell return code: %d), see following log:
   >>>>>>>
   %s
   <<<<<<<""" % (test, self.getReturnCode(proc), stdout)
             failCount += 1
           else:
             print "TEST-PASS | %s | test passed" % test
             passCount += 1
 
-          checkForCrashes(testdir, self.symbolsPath, testName=test)
+          checkForCrashes(testdir, symbolsPath, testName=test)
           dumpLeakLog(self.leakLogFile, True)
 
-          if self.logfiles and stdout:
+          if logfiles and stdout:
             self.createLogFile(test, stdout)
         finally:
           if self.profileDir:
             self.removeDir(self.profileDir)
 
     if passCount == 0 and failCount == 0:
       print "TEST-UNEXPECTED-FAIL | runxpcshelltests.py | No tests run. Did you pass an invalid --test-path?"
       failCount = 1
@@ -470,17 +468,16 @@ def main():
   xpcsh = XPCShellTests()
   debuggerInfo = getDebuggerInfo(xpcsh.oldcwd, options.debugger, options.debuggerArgs,
     options.debuggerInteractive);
 
   if options.interactive and not options.testPath:
     print >>sys.stderr, "Error: You must specify a test filename in interactive mode!"
     sys.exit(1)
 
-    
   if not xpcsh.runTests(args[0],
                         xrePath=options.xrePath,
                         symbolsPath=options.symbolsPath,
                         manifest=options.manifest,
                         testdirs=args[1:],
                         testPath=options.testPath,
                         interactive=options.interactive,
                         logfiles=options.logfiles,
