diff --git a/ipc/ipdl/ipdl/ast.py b/ipc/ipdl/ipdl/ast.py
--- a/ipc/ipdl/ipdl/ast.py
+++ b/ipc/ipdl/ipdl/ast.py
@@ -61,29 +61,29 @@ class Visitor:
             t.accept(self)
 
     def visitUsingStmt(self, using):
         pass
 
     def visitProtocol(self, p):
         for namespace in p.namespaces:
             namespace.accept(self)
-        if p.manager is not None:
-            p.manager.accept(self)
+        for mgr in p.managers:
+            mgr.accept(self)
         for managed in p.managesStmts:
             managed.accept(self)
         for msgDecl in p.messageDecls:
             msgDecl.accept(self)
         for transitionStmt in p.transitionStmts:
             transitionStmt.accept(self)
 
     def visitNamespace(self, ns):
         pass
 
-    def visitManagerStmt(self, mgr):
+    def visitManager(self, mgr):
         pass
 
     def visitManagesStmt(self, mgs):
         pass
 
     def visitMessageDecl(self, md):
         for inParam in md.inParams:
             inParam.accept(self)
@@ -244,16 +244,17 @@ class Namespace(Node):
     def __init__(self, loc, namespace):
         Node.__init__(self, loc)
         self.name = namespace
 
 class Protocol(NamespacedNode):
     def __init__(self, loc):
         NamespacedNode.__init__(self, loc)
         self.sendSemantics = ASYNC
+        self.managers = [ ]
         self.managesStmts = [ ]
         self.messageDecls = [ ]
         self.transitionStmts = [ ]
         self.startStates = [ ]
 
     def addManagesStmts(self, managesStmts):
         self.managesStmts += managesStmts
 
@@ -263,17 +264,17 @@ class Protocol(NamespacedNode):
     def addTransitionStmts(self, transStmts):
         self.transitionStmts += transStmts
 
 class UnionDecl(NamespacedNode):
     def __init__(self, loc, name, components):
         NamespacedNode.__init__(self, loc, name)
         self.components = components
 
-class ManagerStmt(Node):
+class Manager(Node):
     def __init__(self, loc, managerName):
         Node.__init__(self, loc)
         self.name = managerName
 
 class ManagesStmt(Node):
     def __init__(self, loc, managedName):
         Node.__init__(self, loc)
         self.name = managedName
diff --git a/ipc/ipdl/ipdl/lower.py b/ipc/ipdl/ipdl/lower.py
--- a/ipc/ipdl/ipdl/lower.py
+++ b/ipc/ipdl/ipdl/lower.py
@@ -1302,17 +1302,18 @@ class Protocol(ipdl.ast.Protocol):
         return self.channelName() +'::'+ _semsToListener(self.sendSems())
 
     def managerInterfaceType(self, ptr=0):
         return Type('mozilla::ipc::IProtocolManager',
                     ptr=ptr,
                     T=Type(self.fqListenerName()))
 
     def _ipdlmgrtype(self):
-        return self.decl.type.manager
+        assert 1 == len(self.decl.type.managers)
+        for mgr in self.decl.type.managers:  return mgr
 
     def managerActorType(self, side, ptr=0):
         return Type(_actorName(self._ipdlmgrtype().name(), side),
                     ptr=ptr)
 
     def managerMethod(self, actorThis=None):
         _ = self._ipdlmgrtype()
         if actorThis is not None:
@@ -2547,17 +2548,17 @@ class _GenerateProtocolActorCode(ipdl.as
         self.cls = Class(
             self.clsname,
             inherits=[ Inherit(Type(p.fqListenerName()), viz='protected'),
                        Inherit(p.managerInterfaceType(), viz='protected') ],
             abstract=True)
 
         friends = _FindFriends().findFriends(p.decl.type)
         if p.decl.type.isManaged():
-            friends.add(p.decl.type.manager)
+            friends.update(p.decl.type.managers)
 
         # |friend| managed actors so that they can call our Dealloc*()
         friends.update(p.decl.type.manages)
 
         for friend in friends:
             self.hdrfile.addthings([
                 Whitespace.NL,
                 _makeForwardDecl(friend, self.prettyside),
@@ -2692,23 +2693,25 @@ class _GenerateProtocolActorCode(ipdl.as
 
             # Close()
             closemeth = MethodDefn(MethodDecl('Close'))
             closemeth.addstmt(StmtExpr(
                 ExprCall(ExprSelect(p.channelVar(), '.', 'Close'))))
             self.cls.addstmts([ closemeth, Whitespace.NL ])
 
         if not p.decl.type.isToplevel():
-            ## manager()
-            managertype = p.managerActorType(self.side, ptr=1)
-            managermeth = MethodDefn(MethodDecl(
-                p.managerMethod().name, ret=managertype))
-            managermeth.addstmt(StmtReturn(p.managerVar()))
-
-            self.cls.addstmts([ managermeth, Whitespace.NL ])
+            if 1 == len(p.managers):
+                ## manager()
+                managertype = p.managerActorType(self.side, ptr=1)
+                managermeth = MethodDefn(MethodDecl(
+                    p.managerMethod().name, ret=managertype))
+                managermeth.addstmt(StmtReturn(
+                    ExprCast(p.managerVar(), managertype, static=1)))
+
+                self.cls.addstmts([ managermeth, Whitespace.NL ])
 
         ## managed[T]()
         for managed in p.decl.type.manages:
             arrvar = ExprVar('aArr')
             meth = MethodDefn(MethodDecl(
                 p.managedMethod(managed, self.side).name,
                 params=[ Decl(p.managedVarType(managed, self.side, ref=1),
                               arrvar.name) ],
@@ -3010,17 +3013,17 @@ class _GenerateProtocolActorCode(ipdl.as
                               p.actorMapVar().name)),
                 StmtDecl(Decl(_actorIdType(), p.lastActorIdVar().name)),
                 StmtDecl(Decl(Type('ProcessHandle'),
                               p.otherProcessVar().name))
             ])
         elif p.decl.type.isManaged():
             self.cls.addstmts([
                 StmtDecl(Decl(_actorIdType(), p.idVar().name)),
-                StmtDecl(Decl(p.managerActorType(self.side, ptr=1),
+                StmtDecl(Decl(p.managerInterfaceType(ptr=1),
                               p.managerVar().name))
             ])
         if p.usesShmem():
             self.cls.addstmts([
                 StmtDecl(Decl(Type('IDMap', T=_rawShmemType()),
                               p.shmemMapVar().name)),
                 StmtDecl(Decl(_shmemIdType(), p.lastShmemIdVar().name))
             ])
diff --git a/ipc/ipdl/ipdl/parser.py b/ipc/ipdl/ipdl/parser.py
--- a/ipc/ipdl/ipdl/parser.py
+++ b/ipc/ipdl/ipdl/parser.py
@@ -297,42 +297,51 @@ def p_ComponentTypes(p):
                       | Type ';'"""
     if 3 == len(p):
         p[0] = [ p[1] ]
     else:
         p[1].append(p[2])
         p[0] = p[1]
 
 def p_ProtocolDefn(p):
-    """ProtocolDefn : OptionalSendSemanticsQual PROTOCOL ID '{' ManagerStmtOpt ManagesStmts OptionalMessageDecls TransitionStmts '}' ';'"""
+    """ProtocolDefn : OptionalSendSemanticsQual PROTOCOL ID '{' ManagersStmtOpt ManagesStmts OptionalMessageDecls TransitionStmts '}' ';'"""
     protocol = Protocol(locFromTok(p, 2))
     protocol.name = p[3]
     protocol.sendSemantics = p[1]
-    protocol.manager = p[5]
+    protocol.managers = p[5]   
     protocol.addManagesStmts(p[6])
     protocol.addMessageDecls(p[7])
     protocol.addTransitionStmts(p[8])
     p[0] = protocol
 
 def p_ManagesStmts(p):
     """ManagesStmts : ManagesStmts ManagesStmt
                     | """
     if 1 == len(p):
         p[0] = [ ]
     else:
         p[1].append(p[2])
         p[0] = p[1]
 
-def p_ManagerStmtOpt(p):
-    """ManagerStmtOpt : MANAGER ID ';' 
-                      | """
+def p_ManagersStmtOpt(p):
+    """ManagersStmtOpt : MANAGER ManagerList ';'
+                       | """
     if 1 == len(p):
-        p[0] = None
+        p[0] = [ ]
     else:
-        p[0] = ManagerStmt(locFromTok(p, 1), p[2])
+        p[0] = p[2]
+
+def p_ManagerList(p):
+    """ManagerList : ID
+                   | ManagerList OR ID"""
+    if 2 == len(p):
+        p[0] = [ Manager(locFromTok(p, 1), p[1]) ]
+    else:
+        p[1].append(Manager(locFromTok(p, 3), p[3]))
+        p[0] = p[1]
 
 def p_ManagesStmt(p):
     """ManagesStmt : MANAGES ID ';'"""
     p[0] = ManagesStmt(locFromTok(p, 1), p[2])
 
 def p_OptionalMessageDecls(p):
     """OptionalMessageDecls : MessageDecls
                             | """
diff --git a/ipc/ipdl/ipdl/type.py b/ipc/ipdl/ipdl/type.py
--- a/ipc/ipdl/ipdl/type.py
+++ b/ipc/ipdl/ipdl/type.py
@@ -232,43 +232,51 @@ class MessageType(IPDLType):
 
     def hasImplicitActorParam(self):
         return self.isCtor() or self.isDtor()
 
 class ProtocolType(IPDLType):
     def __init__(self, qname, sendSemantics, stateless=False):
         self.qname = qname
         self.sendSemantics = sendSemantics
-        self.manager = None
+        self.managers = set()           # ProtocolType
         self.manages = [ ]
         self.stateless = stateless
     def isProtocol(self): return True
 
     def name(self):
         return self.qname.baseid
     def fullname(self):
         return str(self.qname)
 
+    def addManager(self, mgrtype):
+        assert mgrtype.isIPDL() and mgrtype.isProtocol()
+        self.managers.add(mgrtype)
+
     def managedBy(self, mgr):
-        self.manager = mgr
+        self.managers = mgr
 
     def toplevel(self):
         if self.isToplevel():
             return self
-        return self.manager.toplevel()
+        for mgr in self.managers:
+            return mgr.toplevel()
 
     def isManagerOf(self, pt):
         for managed in self.manages:
             if pt is managed:
                 return True
         return False
+    def isManagedBy(self, pt):
+        return pt in self.managers
+    
     def isManager(self):
         return len(self.manages) > 0
     def isManaged(self):
-        return self.manager is not None
+        return 0 < len(self.managers)
     def isToplevel(self):
         return not self.isManaged()
 
 class ActorType(IPDLType):
     def __init__(self, protocol, state=None, nullable=0):
         self.protocol = protocol
         self.state = state
         self.nullable = nullable
@@ -591,41 +599,48 @@ class GatherDecls(TcheckVisitor):
             type=ipdltype,
             shortname=using.type.basename(),
             fullname=fullname)
 
     def visitProtocol(self, p):
         # protocol scope
         self.symtab.enterScope(p)
 
-        if p.manager is not None:
-            p.manager.of = p
-            p.manager.accept(self)
+        seenmgrs = set()
+        for mgr in p.managers:
+            if mgr.name in seenmgrs:
+                self.error(mgr.loc, "manager `%s' appears multiple times",
+                           mgr.name)
+                continue
+
+            seenmgrs.add(mgr.name)
+            mgr.of = p
+            mgr.accept(self)
 
         for managed in p.managesStmts:
             managed.manager = p
             managed.accept(self)
 
-        if p.manager is None and 0 == len(p.messageDecls):
+        if 0 == len(p.managers) and 0 == len(p.messageDecls):
             self.error(p.loc,
                        "top-level protocol `%s' cannot be empty",
                        p.name)
 
         setattr(self, 'currentProtocolDecl', p.decl)
         for msg in p.messageDecls:
             msg.accept(self)
         del self.currentProtocolDecl
 
         if not p.decl.type.isToplevel():
             dtordecl = self.symtab.lookup(_DELETE_MSG)
             if not dtordecl:
                 self.error(
                     p.loc,
-                    "destructor declaration `delete(...)' required for managed protocol `%s'",
-                    p.name)
+                    "destructor declaration `%s(...)' required for managed protocol `%s'",
+                    _DELETE_MSG, p.name)
 
         for managed in p.managesStmts:
             mgdname = managed.name
             ctordecl = self.symtab.lookup(mgdname +'Constructor')
 
             if not (ctordecl and ctordecl.type.isCtor()):
                 self.error(
                     managed.loc,
@@ -717,17 +732,17 @@ class GatherDecls(TcheckVisitor):
         # be generated.  they're not relevant to IPDL itself, but
         # those ("invisible") symbols can clash with others in the
         # IPDL spec, and we'd like to catch those before C++ compilers
         # are allowed to obfuscate the error
 
         self.symtab.exitScope(p)
 
 
-    def visitManagerStmt(self, mgr):
+    def visitManager(self, mgr):
         mgrdecl = self.symtab.lookup(mgr.name)
         pdecl = mgr.of.decl
         assert pdecl
 
         pname, mgrname = pdecl.shortname, mgr.name
         loc = mgr.loc
 
         if mgrdecl is None:
@@ -736,19 +751,18 @@ class GatherDecls(TcheckVisitor):
                 "protocol `%s' referenced as |manager| of `%s' has not been declared",
                 mgrname, pname)
         elif not isinstance(mgrdecl.type, ProtocolType):
             self.error(
                 loc,
                 "entity `%s' referenced as |manager| of `%s' is not of `protocol' type; instead it is of type `%s'",
                 mgrname, pname, mgrdecl.type.typename())
         else:
-            assert pdecl.type.manager is None
             mgr.decl = mgrdecl
-            pdecl.type.manager = mgrdecl.type
+            pdecl.type.addManager(mgrdecl.type)
 
 
     def visitManagesStmt(self, mgs):
         mgsdecl = self.symtab.lookup(mgs.name)
         pdecl = mgs.manager.decl
         assert pdecl
 
         pname, mgsname = pdecl.shortname, mgs.name
@@ -941,25 +955,24 @@ class CheckTypes(TcheckVisitor):
     def visitProtocolInclude(self, inc):
         if inc.tu.filename in self.visited:
             return
         self.visited.add(inc.tu.filename)
         inc.tu.protocol.accept(self)
 
 
     def visitProtocol(self, p):
-        # check that we require no more "power" than our manager protocol
+        # check that we require no more "power" than our manager protocols
         ptype, pname = p.decl.type, p.decl.shortname
-        mgrtype = ptype.manager
-        if mgrtype is not None and ptype.needsMoreJuiceThan(mgrtype):
-            mgrname = p.manager.decl.shortname
-            self.error(
-                p.decl.loc,
-                "protocol `%s' requires more powerful send semantics than its manager `%s' provides",
-                pname, mgrname)
+        for mgrtype in ptype.managers:
+            if mgrtype is not None and ptype.needsMoreJuiceThan(mgrtype):
+                self.error(
+                    p.decl.loc,
+                    "protocol `%s' requires more powerful send semantics than its manager `%s' provides",
+                    pname, mgrtype.name())
 
         # XXX currently we don't require a delete() message of top-level
         # actors.  need to let experience guide this decision
         if not p.decl.type.isToplevel():
             for md in p.messageDecls:
                 if _DELETE_MSG == md.name: break
             else:
                 self.error(
@@ -975,39 +988,37 @@ class CheckTypes(TcheckVisitor):
         ptype, pname = pdecl.type, pdecl.shortname
 
         mgsdecl = mgs.decl
         mgstype, mgsname = mgsdecl.type, mgsdecl.shortname
 
         loc = mgs.loc
 
         # we added this information; sanity check it
-        for managed in ptype.manages:
-            if managed is mgstype:
-                break
-        else:
-            assert False
+        assert ptype.isManagerOf(mgstype)
 
         # check that the "managed" protocol agrees
-        if mgstype.manager is not ptype:
+        if not mgstype.isManagedBy(ptype):
             self.error(
                 loc,
                 "|manages| declaration in protocol `%s' does not match any |manager| declaration in protocol `%s'",
                 pname, mgsname)
 
 
-    def visitManagerStmt(self, mgr):
+    def visitManager(self, mgr):
+        # FIXME/bug 541126: check that the protocol graph is acyclic
+        
         pdecl = mgr.of.decl
         ptype, pname = pdecl.type, pdecl.shortname
 
         mgrdecl = mgr.decl
         mgrtype, mgrname = mgrdecl.type, mgrdecl.shortname
 
         # we added this information; sanity check it
-        assert ptype.manager is mgrtype
+        assert ptype.isManagedBy(mgrtype)
 
         loc = mgr.loc
 
         # check that the "manager" protocol agrees
         if not mgrtype.isManagerOf(ptype):
             self.error(
                 loc,
                 "|manager| declaration in protocol `%s' does not match any |manages| declaration in protocol `%s'",
