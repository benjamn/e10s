diff --git a/ipc/ipdl/test/cxx/Makefile.in b/ipc/ipdl/test/cxx/Makefile.in
--- a/ipc/ipdl/test/cxx/Makefile.in
+++ b/ipc/ipdl/test/cxx/Makefile.in
@@ -63,16 +63,17 @@ IPDLTESTS = \
   TestRPCErrorCleanup \
   TestCrashCleanup \
   TestSyncWakeup \
   TestLatency \
   TestRPCRaces \
   TestRacyRPCReplies  \
   TestManyChildAllocs  \
   TestDesc \
+  TestMultiMgrs  \
   TestShmem \
   TestShutdown \
   TestArrays \
   $(NULL)
 
 IPDLTESTSRCS = $(addsuffix .cpp,$(IPDLTESTS))
 IPDLTESTHDRS = $(addprefix $(srcdir)/,$(addsuffix .h,$(IPDLTESTS)))
 
diff --git a/ipc/ipdl/test/cxx/PTestMultiMgrs.ipdl b/ipc/ipdl/test/cxx/PTestMultiMgrs.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/PTestMultiMgrs.ipdl
@@ -0,0 +1,34 @@
+include protocol "PTestMultiMgrsLeft.ipdl";
+include protocol "PTestMultiMgrsRight.ipdl";
+
+namespace mozilla {
+namespace _ipdltest {
+
+protocol PTestMultiMgrs {
+    manages PTestMultiMgrsLeft;
+    manages PTestMultiMgrsRight;
+
+parent:
+    OK();
+
+child:
+    PTestMultiMgrsLeft();
+    PTestMultiMgrsRight();
+    Check();
+    __delete__();
+
+state START:
+    send PTestMultiMgrsLeft goto CONSTRUCT_RIGHT;
+state CONSTRUCT_RIGHT:
+    send PTestMultiMgrsRight goto CHILD_CHECK;
+state CHILD_CHECK:
+    send Check goto CHILD_ACK;
+state CHILD_ACK:
+    recv OK goto DONE;
+
+state DONE:
+    send __delete__;
+};
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/PTestMultiMgrsBottom.ipdl b/ipc/ipdl/test/cxx/PTestMultiMgrsBottom.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/PTestMultiMgrsBottom.ipdl
@@ -0,0 +1,18 @@
+include protocol "PTestMultiMgrsLeft.ipdl";
+include protocol "PTestMultiMgrsRight.ipdl";
+
+namespace mozilla {
+namespace _ipdltest {
+
+protocol PTestMultiMgrsBottom {
+    manager PTestMultiMgrsLeft or PTestMultiMgrsRight;
+
+child:
+    __delete__();
+
+state DOA:
+    send __delete__;
+};
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/PTestMultiMgrsLeft.ipdl b/ipc/ipdl/test/cxx/PTestMultiMgrsLeft.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/PTestMultiMgrsLeft.ipdl
@@ -0,0 +1,24 @@
+include protocol "PTestMultiMgrs.ipdl";
+include protocol "PTestMultiMgrsBottom.ipdl";
+
+namespace mozilla {
+namespace _ipdltest {
+
+protocol PTestMultiMgrsLeft {
+    manager PTestMultiMgrs;
+
+    manages PTestMultiMgrsBottom;
+
+child:
+    PTestMultiMgrsBottom();
+    __delete__();
+
+state START:
+    send PTestMultiMgrsBottom goto DONE;
+
+state DONE:
+    send __delete__;
+};
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/PTestMultiMgrsRight.ipdl b/ipc/ipdl/test/cxx/PTestMultiMgrsRight.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/PTestMultiMgrsRight.ipdl
@@ -0,0 +1,24 @@
+include protocol "PTestMultiMgrs.ipdl";
+include protocol "PTestMultiMgrsBottom.ipdl";
+
+namespace mozilla {
+namespace _ipdltest {
+
+protocol PTestMultiMgrsRight {
+    manager PTestMultiMgrs;
+
+    manages PTestMultiMgrsBottom;
+
+child:
+    PTestMultiMgrsBottom();
+    __delete__();
+
+state START:
+    send PTestMultiMgrsBottom goto DONE;
+
+state DONE:
+    send __delete__;
+};
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/TestMultiMgrs.cpp b/ipc/ipdl/test/cxx/TestMultiMgrs.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestMultiMgrs.cpp
@@ -0,0 +1,106 @@
+#include "TestMultiMgrs.h"
+
+#include "IPDLUnitTests.h"      // fail etc.
+
+namespace mozilla {
+namespace _ipdltest {
+
+//-----------------------------------------------------------------------------
+// parent
+
+void
+TestMultiMgrsParent::Main()
+{
+    TestMultiMgrsLeftParent* leftie = new TestMultiMgrsLeftParent();
+    if (!SendPTestMultiMgrsLeftConstructor(leftie))
+        fail("error sending ctor");
+
+    TestMultiMgrsRightParent* rightie = new TestMultiMgrsRightParent();
+    if (!SendPTestMultiMgrsRightConstructor(rightie))
+        fail("error sending ctor");
+
+    TestMultiMgrsBottomParent* bottomL = new TestMultiMgrsBottomParent();
+    if (!leftie->SendPTestMultiMgrsBottomConstructor(bottomL))
+        fail("error sending ctor");
+
+    TestMultiMgrsBottomParent* bottomR = new TestMultiMgrsBottomParent();
+    if (!rightie->SendPTestMultiMgrsBottomConstructor(bottomR))
+        fail("error sending ctor");
+
+    if (!leftie->HasChild(bottomL))
+        fail("leftie didn't have a child it was supposed to!");
+    if (leftie->HasChild(bottomR))
+        fail("leftie had rightie's child!");
+
+    if (!rightie->HasChild(bottomR))
+        fail("rightie didn't have a child it was supposed to!");
+    if (rightie->HasChild(bottomL))
+        fail("rightie had rightie's child!");
+
+    if (!SendCheck())
+        fail("couldn't kick off the child-side check");
+}
+
+bool
+TestMultiMgrsParent::RecvOK()
+{
+    Close();
+    return true;
+}
+
+//-----------------------------------------------------------------------------
+// child
+
+bool
+TestMultiMgrsLeftChild::RecvPTestMultiMgrsBottomConstructor(
+    PTestMultiMgrsBottomChild* actor)
+{
+    static_cast<TestMultiMgrsChild*>(Manager())->mBottomL = actor;
+    return true;
+}
+
+bool
+TestMultiMgrsRightChild::RecvPTestMultiMgrsBottomConstructor(
+    PTestMultiMgrsBottomChild* actor)
+{
+    static_cast<TestMultiMgrsChild*>(Manager())->mBottomR = actor;
+    return true;
+}
+
+bool
+TestMultiMgrsChild::RecvCheck()
+{
+    nsTArray<PTestMultiMgrsLeftChild*> la;
+    ManagedPTestMultiMgrsLeftChild(la);
+    nsTArray<PTestMultiMgrsRightChild*> lr;
+    ManagedPTestMultiMgrsRightChild(lr);
+
+    if (1 != la.Length())
+        fail("where's leftie?");
+    if (1 != lr.Length())
+        fail("where's rightie?");
+
+    TestMultiMgrsLeftChild* leftie =
+        static_cast<TestMultiMgrsLeftChild*>(la[0]);
+    TestMultiMgrsRightChild* rightie =
+        static_cast<TestMultiMgrsRightChild*>(lr[0]);
+
+    if (!leftie->HasChild(mBottomL))
+        fail("leftie didn't have a child it was supposed to!");
+    if (leftie->HasChild(mBottomR))
+        fail("leftie had rightie's child!");
+
+    if (!rightie->HasChild(mBottomR))
+        fail("rightie didn't have a child it was supposed to!");
+    if (rightie->HasChild(mBottomL))
+        fail("rightie had leftie's child!");
+
+    if (!SendOK())
+        fail("couldn't send OK()");
+
+    return true;
+}
+
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/TestMultiMgrs.h b/ipc/ipdl/test/cxx/TestMultiMgrs.h
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestMultiMgrs.h
@@ -0,0 +1,272 @@
+#ifndef mozilla__ipdltest_TestMultiMgrs_h
+#define mozilla__ipdltest_TestMultiMgrs_h 1
+
+#include "mozilla/_ipdltest/IPDLUnitTests.h"
+
+#include "mozilla/_ipdltest/PTestMultiMgrsParent.h"
+#include "mozilla/_ipdltest/PTestMultiMgrsChild.h"
+#include "mozilla/_ipdltest/PTestMultiMgrsBottomParent.h"
+#include "mozilla/_ipdltest/PTestMultiMgrsBottomChild.h"
+#include "mozilla/_ipdltest/PTestMultiMgrsLeftParent.h"
+#include "mozilla/_ipdltest/PTestMultiMgrsLeftChild.h"
+#include "mozilla/_ipdltest/PTestMultiMgrsRightParent.h"
+#include "mozilla/_ipdltest/PTestMultiMgrsRightChild.h"
+
+namespace mozilla {
+namespace _ipdltest {
+
+//-----------------------------------------------------------------------------
+// Parent side
+//
+
+class TestMultiMgrsBottomParent :
+    public PTestMultiMgrsBottomParent
+{
+public:
+    TestMultiMgrsBottomParent() { }
+    virtual ~TestMultiMgrsBottomParent() { }
+};
+
+class TestMultiMgrsLeftParent :
+    public PTestMultiMgrsLeftParent
+{
+public:
+    TestMultiMgrsLeftParent() { }
+    virtual ~TestMultiMgrsLeftParent() { }
+
+    bool HasChild(TestMultiMgrsBottomParent* c)
+    {
+        // XXX this interface really sucks.  maybe a helper
+        // |const Array& ManagedPFoo() const| ?
+        nsTArray<PTestMultiMgrsBottomParent*> a;
+        ManagedPTestMultiMgrsBottomParent(a);
+        return a.Contains(c);
+    }
+
+protected:
+    NS_OVERRIDE
+    virtual PTestMultiMgrsBottomParent* AllocPTestMultiMgrsBottom()
+    {
+        return new TestMultiMgrsBottomParent();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsBottom(PTestMultiMgrsBottomParent* actor)
+    {
+        delete actor;
+        return true;
+    }
+};
+
+class TestMultiMgrsRightParent :
+    public PTestMultiMgrsRightParent
+{
+public:
+    TestMultiMgrsRightParent() { }
+    virtual ~TestMultiMgrsRightParent() { }
+
+    bool HasChild(TestMultiMgrsBottomParent* c)
+    {
+        nsTArray<PTestMultiMgrsBottomParent*> a;
+        ManagedPTestMultiMgrsBottomParent(a);
+        return a.Contains(c);
+    }
+
+protected:
+    NS_OVERRIDE
+    virtual PTestMultiMgrsBottomParent* AllocPTestMultiMgrsBottom()
+    {
+        return new TestMultiMgrsBottomParent();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsBottom(PTestMultiMgrsBottomParent* actor)
+    {
+        delete actor;
+        return true;
+    }
+};
+
+class TestMultiMgrsParent :
+    public PTestMultiMgrsParent
+{
+public:
+    TestMultiMgrsParent() { }
+    virtual ~TestMultiMgrsParent() { }
+
+    void Main();
+
+protected:
+    NS_OVERRIDE
+    virtual bool RecvOK();
+
+    NS_OVERRIDE
+    virtual PTestMultiMgrsLeftParent* AllocPTestMultiMgrsLeft()
+    {
+        return new TestMultiMgrsLeftParent();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsLeft(PTestMultiMgrsLeftParent* actor)
+    {
+        delete actor;
+        return true;
+    }
+
+    NS_OVERRIDE
+    virtual PTestMultiMgrsRightParent* AllocPTestMultiMgrsRight()
+    {
+        return new TestMultiMgrsRightParent();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsRight(PTestMultiMgrsRightParent* actor)
+    {
+        delete actor;
+        return true;
+    }
+
+    NS_OVERRIDE
+    virtual void ActorDestroy(ActorDestroyReason why)
+    {
+        if (NormalShutdown != why)
+            fail("unexpected destruction!");  
+        passed("ok");
+        QuitParent();
+    }
+};
+
+//-----------------------------------------------------------------------------
+// Child side
+//
+
+class TestMultiMgrsBottomChild :
+    public PTestMultiMgrsBottomChild
+{
+public:
+    TestMultiMgrsBottomChild() { }
+    virtual ~TestMultiMgrsBottomChild() { }
+};
+
+class TestMultiMgrsLeftChild :
+    public PTestMultiMgrsLeftChild
+{
+public:
+    TestMultiMgrsLeftChild() { }
+    virtual ~TestMultiMgrsLeftChild() { }
+
+    bool HasChild(PTestMultiMgrsBottomChild* c)
+    {
+        nsTArray<PTestMultiMgrsBottomChild*> a;
+        ManagedPTestMultiMgrsBottomChild(a);
+        return a.Contains(c);
+    }
+
+protected:
+    NS_OVERRIDE
+    virtual bool RecvPTestMultiMgrsBottomConstructor(PTestMultiMgrsBottomChild* actor);
+
+    NS_OVERRIDE
+    virtual PTestMultiMgrsBottomChild* AllocPTestMultiMgrsBottom()
+    {
+        return new TestMultiMgrsBottomChild();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsBottom(PTestMultiMgrsBottomChild* actor)
+    {
+        delete actor;
+        return true;
+    }
+};
+
+class TestMultiMgrsRightChild :
+    public PTestMultiMgrsRightChild
+{
+public:
+    TestMultiMgrsRightChild() { }
+    virtual ~TestMultiMgrsRightChild() { }
+
+    bool HasChild(PTestMultiMgrsBottomChild* c)
+    {
+        nsTArray<PTestMultiMgrsBottomChild*> a;
+        ManagedPTestMultiMgrsBottomChild(a);
+        return a.Contains(c);
+    }
+
+protected:
+    NS_OVERRIDE
+    virtual bool RecvPTestMultiMgrsBottomConstructor(PTestMultiMgrsBottomChild* actor);
+
+    NS_OVERRIDE
+    virtual PTestMultiMgrsBottomChild* AllocPTestMultiMgrsBottom()
+    {
+        return new TestMultiMgrsBottomChild();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsBottom(PTestMultiMgrsBottomChild* actor)
+    {
+        delete actor;
+        return true;
+    }
+};
+
+class TestMultiMgrsChild :
+    public PTestMultiMgrsChild
+{
+public:
+    TestMultiMgrsChild() { }
+    virtual ~TestMultiMgrsChild() { }
+
+    void Main();
+
+    PTestMultiMgrsBottomChild* mBottomL;
+    PTestMultiMgrsBottomChild* mBottomR;
+
+protected:
+    NS_OVERRIDE
+    virtual bool RecvCheck();
+
+    NS_OVERRIDE
+    virtual PTestMultiMgrsLeftChild* AllocPTestMultiMgrsLeft()
+    {
+        return new TestMultiMgrsLeftChild();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsLeft(PTestMultiMgrsLeftChild* actor)
+    {
+        delete actor;
+        return true;
+    }
+
+    NS_OVERRIDE
+    virtual PTestMultiMgrsRightChild* AllocPTestMultiMgrsRight()
+    {
+        return new TestMultiMgrsRightChild();
+    }
+
+    NS_OVERRIDE
+    virtual bool DeallocPTestMultiMgrsRight(PTestMultiMgrsRightChild* actor)
+    {
+        delete actor;
+        return true;
+    }
+
+    NS_OVERRIDE
+    virtual void ActorDestroy(ActorDestroyReason why)
+    {
+        if (NormalShutdown != why)
+            fail("unexpected destruction!");  
+        passed("ok");
+        QuitChild();
+    }
+};
+
+
+} // namespace _ipdltest
+} // namespace mozilla
+
+
+#endif // ifndef mozilla__ipdltest_TestMultiMgrs_h
diff --git a/ipc/ipdl/test/cxx/ipdl.mk b/ipc/ipdl/test/cxx/ipdl.mk
--- a/ipc/ipdl/test/cxx/ipdl.mk
+++ b/ipc/ipdl/test/cxx/ipdl.mk
@@ -3,16 +3,20 @@ IPDLSRCS =					\
   PTestArraysSub.ipdl				\
   PTestCrashCleanup.ipdl			\
   PTestDesc.ipdl				\
   PTestDescSub.ipdl				\
   PTestDescSubsub.ipdl				\
   PTestLatency.ipdl				\
   PTestManyChildAllocs.ipdl			\
   PTestManyChildAllocsSub.ipdl			\
+  PTestMultiMgrs.ipdl				\
+  PTestMultiMgrsLeft.ipdl			\
+  PTestMultiMgrsRight.ipdl			\
+  PTestMultiMgrsBottom.ipdl			\
   PTestRacyRPCReplies.ipdl			\
   PTestRPCErrorCleanup.ipdl			\
   PTestRPCRaces.ipdl				\
   PTestSanity.ipdl				\
   PTestShmem.ipdl				\
   PTestShutdown.ipdl				\
   PTestShutdownSub.ipdl				\
   PTestShutdownSubsub.ipdl			\
