Bug 562414 - Implement an opaque Handle primitive for providing context to (a)synchronous IPC calls.

diff --git a/ipc/testshell/TestShellParent.cpp b/ipc/testshell/TestShellParent.cpp
--- a/ipc/testshell/TestShellParent.cpp
+++ b/ipc/testshell/TestShellParent.cpp
@@ -32,25 +32,28 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "TestShellParent.h"
 #include "mozilla/dom/ContentProcessParent.h"
 #include "mozilla/jsipc/ContextWrapperParent.h"
+#include "mozilla/jsipc/Handle.h"
 
 #include "nsAutoPtr.h"
 
 using mozilla::ipc::TestShellParent;
 using mozilla::ipc::TestShellCommandParent;
 using mozilla::ipc::PTestShellCommandParent;
 using mozilla::dom::ContentProcessParent;
 using mozilla::jsipc::PContextWrapperParent;
 using mozilla::jsipc::ContextWrapperParent;
+using mozilla::jsipc::PHandleParent;
+using mozilla::jsipc::HandleParent;
 
 PTestShellCommandParent*
 TestShellParent::AllocPTestShellCommand(const nsString& aCommand)
 {
   return new TestShellCommandParent();
 }
 
 bool
@@ -81,27 +84,43 @@ TestShellParent::AllocPContextWrapper()
 
 bool
 TestShellParent::DeallocPContextWrapper(PContextWrapperParent* actor)
 {
     delete actor;
     return true;
 }
 
+ContextWrapperParent*
+TestShellParent::GetContextWrapper()
+{
+    nsTArray<PContextWrapperParent*> cwps(1);
+    ManagedPContextWrapperParent(cwps);
+    if (cwps.Length() < 1)
+        return nsnull;
+    NS_ASSERTION(cwps.Length() == 1, "More than one PContextWrapper?");
+    return static_cast<ContextWrapperParent*>(cwps[0]);
+}
+
 JSBool
 TestShellParent::GetGlobalJSObject(JSContext* cx, JSObject** globalp)
 {
-    // TODO Unify this code with TabParent::GetGlobalJSObject.
-    nsTArray<PContextWrapperParent*> cwps(1);
-    ManagedPContextWrapperParent(cwps);
-    if (cwps.Length() < 1)
+    ContextWrapperParent* cwp = GetContextWrapper();
+    return cwp && cwp->GetGlobalJSObject(cx, globalp);
+}
+
+JSBool
+TestShellParent::CreateHandle(JSContext* cx,
+                              JSObject** handlep)
+{
+    ContextWrapperParent* cwp = GetContextWrapper();
+    if (!cwp)
         return JS_FALSE;
-    NS_ASSERTION(cwps.Length() == 1, "More than one PContextWrapper?");
-    ContextWrapperParent* cwp = static_cast<ContextWrapperParent*>(cwps[0]);
-    return cwp->GetGlobalJSObject(cx, globalp);
+    PHandleParent* php = cwp->SendPHandleConstructor();
+    return !!(*handlep = static_cast<HandleParent*>(php)->GetJSObject(cx));
 }
 
 JSBool
 TestShellCommandParent::SetCallback(JSContext* aCx,
                                     jsval aCallback)
 {
   if (!mCallback.Hold(aCx)) {
     return JS_FALSE;
diff --git a/ipc/testshell/TestShellParent.h b/ipc/testshell/TestShellParent.h
--- a/ipc/testshell/TestShellParent.h
+++ b/ipc/testshell/TestShellParent.h
@@ -49,16 +49,17 @@
 
 struct JSContext;
 struct JSObject;
 
 namespace mozilla {
 
 namespace jsipc {
 class PContextWrapperParent;
+class ContextWrapperParent;
 }
 
 namespace ipc {
 
 class TestShellCommandParent;
 
 class TestShellParent : public PTestShellParent
 {
@@ -71,16 +72,21 @@ public:
 
   bool
   CommandDone(TestShellCommandParent* aActor, const nsString& aResponse);
 
   PContextWrapperParent* AllocPContextWrapper();
   bool DeallocPContextWrapper(PContextWrapperParent* actor);
 
   JSBool GetGlobalJSObject(JSContext* cx, JSObject** globalp);
+
+  JSBool CreateHandle(JSContext* cx, JSObject** handlep);
+
+private:
+  mozilla::jsipc::ContextWrapperParent* GetContextWrapper();
 };
 
 
 class TestShellCommandParent : public PTestShellCommandParent
 {
 public:
   TestShellCommandParent() : mCx(NULL) { }
 
diff --git a/js/src/ipc/ContextWrapperChild.h b/js/src/ipc/ContextWrapperChild.h
--- a/js/src/ipc/ContextWrapperChild.h
+++ b/js/src/ipc/ContextWrapperChild.h
@@ -38,16 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_jsipc_ContextWrapperChild_h__
 #define mozilla_jsipc_ContextWrapperChild_h__
 
 #include "mozilla/jsipc/PContextWrapperChild.h"
 #include "mozilla/jsipc/ObjectWrapperChild.h"
+#include "mozilla/jsipc/Handle.h"
 
 #include "jsapi.h"
 #include "nsClassHashtable.h"
 #include "nsHashKeys.h"
 
 namespace mozilla {
 namespace jsipc {
 
@@ -76,33 +77,41 @@ public:
             if (wrapper)
                 mResidentObjectTable.Put(obj, wrapper);
             else
                 return NULL;
         }
         return wrapper;
     }
 
-protected:
+private:
 
     PObjectWrapperChild* AllocPObjectWrapper(JSObject* obj) {
         return new ObjectWrapperChild(mContext, obj);
     }
     
     PObjectWrapperChild* AllocPObjectWrapper(const bool&) {
         return AllocPObjectWrapper(JS_GetGlobalObject(mContext));
     }
 
     bool DeallocPObjectWrapper(PObjectWrapperChild* actor) {
         ObjectWrapperChild* owc = static_cast<ObjectWrapperChild*>(actor);
         mResidentObjectTable.Remove(owc->GetJSObject());
         return true;
     }
 
-private:
+    PHandleChild* AllocPHandle() {
+        return new HandleChild();
+    }
+
+    bool DeallocPHandle(PHandleChild* actor)
+    {
+        delete actor;
+        return true;
+    }
 
     JSContext* const mContext;
 
     nsClassHashtable<nsPtrHashKey<JSObject>,
                      PObjectWrapperChild> mResidentObjectTable;
 
 };
 
diff --git a/js/src/ipc/ContextWrapperParent.h b/js/src/ipc/ContextWrapperParent.h
--- a/js/src/ipc/ContextWrapperParent.h
+++ b/js/src/ipc/ContextWrapperParent.h
@@ -38,16 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_jsipc_ContextWrapperParent_h__
 #define mozilla_jsipc_ContextWrapperParent_h__
 
 #include "mozilla/jsipc/PContextWrapperParent.h"
 #include "mozilla/jsipc/ObjectWrapperParent.h"
+#include "mozilla/jsipc/Handle.h"
 #include "mozilla/jsipc/CPOWTypes.h"
 
 #include "mozilla/dom/ContentProcessParent.h"
 
 #include "jsapi.h"
 #include "nsAutoJSValHolder.h"
 
 namespace mozilla {
@@ -107,13 +108,23 @@ private:
             mGlobal == static_cast<ObjectWrapperParent*>(actor)) {
             mGlobalHolder.Release();
             mGlobal = NULL;
         }
         delete actor;
         return true;
     }
 
+    PHandleParent* AllocPHandle() {
+        return new HandleParent();
+    }
+
+    bool DeallocPHandle(PHandleParent* actor)
+    {
+        delete actor;
+        return true;
+    }
+
 };
 
 }}
 
 #endif
diff --git a/js/src/ipc/Handle.h b/js/src/ipc/Handle.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/Handle.h
@@ -0,0 +1,275 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_HandleParent_h__
+#define mozilla_jsipc_HandleParent_h__
+
+#include "mozilla/jsipc/PHandleParent.h"
+#include "mozilla/jsipc/PHandleChild.h"
+
+#include "jsapi.h"
+#include "jsobj.h"
+#include "jscntxt.h"
+
+namespace mozilla {
+namespace jsipc {
+
+template <class BaseType>
+class Handle
+    : public BaseType
+{
+    Handle(Handle* parent)
+        : mParent(parent)
+        , mObj(NULL)
+        , mRuntime(NULL)
+    {}
+
+    BaseType* AllocPHandle() {
+        return new Handle(this);
+    }
+
+    bool DeallocPHandle(BaseType* actor) {
+        delete actor;
+        return true;
+    }
+
+public:
+
+    Handle()
+        : mParent(NULL)
+        , mObj(NULL)
+        , mRuntime(NULL)
+    {}
+
+    JSObject* GetJSObject(JSContext* cx) const {
+        if (!mObj && !mRuntime) {
+            JSClass* clasp = const_cast<JSClass*>(&sHandle_JSClass);
+            JSObject* obj = JS_NewObject(cx, clasp, NULL, NULL);
+            if (!obj)
+                return NULL;
+            js::AutoValueRooter avr(cx, obj);
+
+            JSPropertySpec* ps = const_cast<JSPropertySpec*>(sHandle_Properties);
+            JSFunctionSpec* fs = const_cast<JSFunctionSpec*>(sHandle_Functions);
+            JSRuntime* rt;
+
+            if (JS_SetPrivate(cx, obj, (void*)this) &&
+                JS_DefineProperties(cx, obj, ps) &&
+                JS_DefineFunctions(cx, obj, fs) &&
+                JS_AddNamedRootRT(rt = JS_GetRuntime(cx), (void*)&mObj,
+                                  "mozilla::jsipc::Handle<BaseType>::mObj"))
+            {
+                mObj = obj;
+                mRuntime = rt;
+            }
+        }
+        return mObj;
+    }
+
+protected:
+
+    // XXX Why not simply ActorDestroyReason?
+    void ActorDestroy(typename Handle::ActorDestroyReason why) {
+        if (mObj) {
+            mObj->setPrivate(NULL);
+            mObj = NULL;
+            // Nulling out mObj effectively unroots the object, but we still
+            // need to remove the root for good hygiene's sake.
+            NS_ASSERTION(mRuntime, "Should have a JSRuntime if we had an object");
+            JS_RemoveRootRT(mRuntime, (void*)&mObj);
+            // By not nulling out mRuntime, we prevent GetJSObject from
+            // reviving an invalidated/destroyed handle.
+        }
+    }
+
+private:
+
+    static const JSClass        sHandle_JSClass;
+    static const JSPropertySpec sHandle_Properties[];
+    static const JSFunctionSpec sHandle_Functions[];
+
+    Handle* const mParent;
+
+    // Used to cache the JSObject returned by GetJSObject, which is
+    // otherwise a const method.
+    mutable JSObject*  mObj;
+    mutable JSRuntime* mRuntime;
+
+    static Handle*
+    Unwrap(JSContext* cx, JSObject* obj) {
+        if (!obj)
+            return NULL;
+
+        while (obj->getClass() != &sHandle_JSClass)
+            if (!(obj = obj->getProto()))
+                return NULL;
+
+        Handle* self = static_cast<Handle*>(JS_GetPrivate(cx, obj));
+
+        NS_ASSERTION(!self || self->GetJSObject(cx) == obj,
+                     "Wrapper and wrapped object disagree?");
+
+        return self;
+    }
+
+    static JSBool
+    GetParent(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        JS_SET_RVAL(cx, vp, JSVAL_NULL);
+
+        Handle* self = Unwrap(cx, obj);
+        if (!self)
+            return JS_TRUE;
+
+        Handle* parent = self->mParent;
+        if (!parent)
+            return JS_TRUE;
+
+        JSObject* pobj = parent->GetJSObject(cx);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(pobj));
+
+        return JS_TRUE;
+    }
+
+    static JSBool
+    GetIsValid(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        Handle* self = Unwrap(cx, obj);
+        JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(!!self));
+        return JS_TRUE;
+    }
+
+    static JSBool
+    Invalidate(JSContext* cx, uintN argc, jsval* vp) {
+        if (argc > 0) {
+            JS_ReportError(cx, "invalidate takes zero arguments");
+            return JS_FALSE;
+        }
+
+        Handle* self = Unwrap(cx, JS_THIS_OBJECT(cx, vp));
+        if (self) {
+            JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_TRUE));
+            if (!Send__delete__(self)) {
+                JS_ReportError(cx, "Failed to send __delete__ while invalidating");
+                return JS_FALSE;
+            }
+        } else {
+            JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_FALSE));
+        }
+
+        return JS_TRUE;
+    }
+
+    static JSBool
+    CreateChild(JSContext* cx, uintN argc, jsval* vp) {
+        if (argc > 0) {
+            JS_ReportError(cx, "createChild takes zero arguments");
+            return JS_FALSE;
+        }
+
+        Handle* self = Unwrap(cx, JS_THIS_OBJECT(cx, vp));
+        if (!self) {
+            JS_ReportError(cx, "Tried to create child from invalid handle");
+            return JS_FALSE;
+        }
+
+        BaseType* child = self->SendPHandleConstructor();
+        if (!child) {
+            JS_ReportError(cx, "Failed to construct child");
+            return JS_FALSE;
+        }
+
+        JSObject* obj = static_cast<Handle*>(child)->GetJSObject(cx);
+        JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(obj));
+
+        return JS_TRUE;
+    }
+
+    static void
+    Finalize(JSContext* cx, JSObject* obj) {
+        Handle* self = Unwrap(cx, obj);
+        self && Send__delete__(self);
+    }
+
+};
+
+template <class BaseType>
+const JSClass
+Handle<BaseType>::sHandle_JSClass = {
+    "IPDL Handle", JSCLASS_HAS_PRIVATE,
+    JS_PropertyStub, JS_PropertyStub,
+    JS_PropertyStub, JS_PropertyStub,
+    JS_EnumerateStub, JS_ResolveStub,
+    JS_ConvertStub, Handle::Finalize,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+#define HANDLE_PROP_FLAGS (JSPROP_READONLY | JSPROP_PERMANENT)
+
+template <class BaseType>
+const JSPropertySpec
+Handle<BaseType>::sHandle_Properties[] = {
+    { "parent",  0, HANDLE_PROP_FLAGS, GetParent,  NULL },
+    { "isValid", 0, HANDLE_PROP_FLAGS, GetIsValid, NULL },
+    { 0, 0, 0, NULL, NULL }
+};
+
+#undef HANDLE_PROP_FLAGS
+
+#define HANDLE_FUN_FLAGS (JSFUN_FAST_NATIVE |   \
+                          JSPROP_READONLY |     \
+                          JSPROP_PERMANENT)
+
+template <class BaseType>
+const JSFunctionSpec
+Handle<BaseType>::sHandle_Functions[] = {
+    JS_FN("invalidate",  Invalidate,  0, HANDLE_FUN_FLAGS),
+    JS_FN("createChild", CreateChild, 0, HANDLE_FUN_FLAGS),
+    JS_FS_END
+};
+
+#undef HANDLE_FUN_FLAGS
+
+// The payoff for using templates is that these two implementations are
+// guaranteed to be perfectly symmetric:
+typedef Handle<PHandleParent> HandleParent;
+typedef Handle<PHandleChild> HandleChild;
+
+}}
+
+#endif
diff --git a/js/src/ipc/Makefile.in b/js/src/ipc/Makefile.in
--- a/js/src/ipc/Makefile.in
+++ b/js/src/ipc/Makefile.in
@@ -51,16 +51,17 @@ EXPORT_LIBRARY = 1
 EXPORTS_NAMESPACES = mozilla/jsipc
 
 EXPORTS_mozilla/jsipc = \
   CPOWTypes.h \
   ContextWrapperChild.h \
   ContextWrapperParent.h \
   ObjectWrapperParent.h \
   ObjectWrapperChild.h \
+  Handle.h \
   $(NULL)
 
 CPPSRCS = \
   ObjectWrapperParent.cpp \
   ObjectWrapperChild.cpp \
   $(NULL)
 
 ifdef ENABLE_TESTS
diff --git a/js/src/ipc/ObjectWrapperChild.cpp b/js/src/ipc/ObjectWrapperChild.cpp
--- a/js/src/ipc/ObjectWrapperChild.cpp
+++ b/js/src/ipc/ObjectWrapperChild.cpp
@@ -38,16 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "base/basictypes.h"
 #include "jscntxt.h"
 
 #include "mozilla/jsipc/ContextWrapperChild.h"
 #include "mozilla/jsipc/ObjectWrapperChild.h"
+#include "mozilla/jsipc/Handle.h"
 #include "mozilla/jsipc/CPOWTypes.h"
 
 #include "jsapi.h"
 #include "nsAutoPtr.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "nsIJSContextStack.h"
 
@@ -128,16 +129,21 @@ ObjectWrapperChild::CheckOperation(JSCon
                                    OperationStatus* status)
 {
     NS_PRECONDITION(status->type() != OperationStatus::T__None,
                     "Checking an uninitialized operation.");
 
     JSContext* cx = Manager()->GetContext();
     jsval thrown;
 
+#ifdef DEBUG
+    if (!cx) // Never actually do this; just force template expansion.
+        (new HandleChild())->GetJSObject(cx);
+#endif
+
     if (JS_GetPendingException(cx, &thrown)) {
         NS_ASSERTION(!(status->type() == OperationStatus::TJSBool &&
                        status->get_JSBool()),
                      "Operation succeeded but exception was thrown?");
         JSVariant exception;
         if (!jsval_to_JSVariant(cx, thrown, &exception))
             exception = void_t(); // XXX Useful?
         *status = exception;
diff --git a/js/src/ipc/ObjectWrapperParent.cpp b/js/src/ipc/ObjectWrapperParent.cpp
--- a/js/src/ipc/ObjectWrapperParent.cpp
+++ b/js/src/ipc/ObjectWrapperParent.cpp
@@ -35,16 +35,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "mozilla/jsipc/ObjectWrapperParent.h"
 #include "mozilla/jsipc/ContextWrapperParent.h"
+#include "mozilla/jsipc/Handle.h"
 #include "mozilla/jsipc/CPOWTypes.h"
 
 #include "jsobj.h"
 #include "jsfun.h"
 #include "jsutil.h"
 
 using namespace mozilla::jsipc;
 
diff --git a/js/src/ipc/PContextWrapper.ipdl b/js/src/ipc/PContextWrapper.ipdl
--- a/js/src/ipc/PContextWrapper.ipdl
+++ b/js/src/ipc/PContextWrapper.ipdl
@@ -36,22 +36,26 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol PIFrameEmbedding;
 include protocol PTestShell;
 include protocol PObjectWrapper;
+include protocol PHandle;
 
 namespace mozilla {
 namespace jsipc {
 
 rpc protocol PContextWrapper
 {
     manager PIFrameEmbedding or PTestShell;
     manages PObjectWrapper;
+    manages PHandle;
 parent:
     async __delete__();
     async PObjectWrapper(bool makeGlobal);
+both:
+    async PHandle();
 };
 
 }}
diff --git a/js/src/ipc/PHandle.ipdl b/js/src/ipc/PHandle.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PHandle.ipdl
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol PContextWrapper;
+
+namespace mozilla {
+namespace jsipc {
+
+async protocol PHandle
+{
+    manager PContextWrapper or PHandle;
+    manages PHandle;
+both:
+    PHandle();
+    __delete__();
+};
+
+}}
diff --git a/js/src/ipc/ipdl.mk b/js/src/ipc/ipdl.mk
--- a/js/src/ipc/ipdl.mk
+++ b/js/src/ipc/ipdl.mk
@@ -33,9 +33,10 @@
 # the provisions above, a recipient may use your version of this file under
 # the terms of any one of the MPL, the GPL or the LGPL.
 #
 # ***** END LICENSE BLOCK *****
 
 IPDLSRCS = \
   PContextWrapper.ipdl \
   PObjectWrapper.ipdl \
+  PHandle.ipdl \
   $(NULL)
diff --git a/js/src/ipc/tests/unit/handle_child.js b/js/src/ipc/tests/unit/handle_child.js
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/tests/unit/handle_child.js
@@ -0,0 +1,1 @@
+function run_test() {}
diff --git a/js/src/ipc/tests/unit/test_handle.js b/js/src/ipc/tests/unit/test_handle.js
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/tests/unit/test_handle.js
@@ -0,0 +1,105 @@
+function run_test() {
+  //gczeal(2);
+  run_test_in_child("handle_child.js",
+                    run_actual_tests);
+}
+
+function run_actual_tests() {
+  test_sanity();
+  test_safe_iteration();
+  test_local_invalidation();
+  test_long_parent_chain(100);
+  test_invalid_creation();
+  do_test_finished();
+}
+
+function test_sanity() {
+  var parent = createHandle(),
+      child = parent.createChild(),
+      grandchild = child.createChild();
+
+  do_check_neq(child, parent);
+  do_check_eq(child.parent, parent);
+  do_check_eq(parent.parent, null);
+  do_check_eq(grandchild.parent.parent, parent);
+
+  do_check_true(child.isValid);
+  do_check_true(parent.isValid);
+
+  parent.invalidate();
+}
+
+function test_safe_iteration() {
+  var handle = createHandle(),
+      keys = [];
+  handle.foo = 42;
+  handle.self = handle;
+  for (var k in handle)
+    keys[keys.length] = k;
+  do_check_eq(keys.sort().join("~"),
+              "foo~self");
+  handle.invalidate();
+}
+
+function test_local_invalidation() {
+  var parent = createHandle(),
+      child = parent.createChild();
+
+  do_check_true(child.invalidate());
+  do_check_false(child.isValid);
+  do_check_true(parent.isValid);
+
+  child = parent.createChild();
+  do_check_true(child.isValid);
+
+  do_check_true(parent.invalidate());
+  do_check_false(parent.invalidate());
+  do_check_false(child.isValid);
+  do_check_false(parent.isValid);
+
+  parent = createHandle();
+  child = parent.createChild();
+  child = child.createChild();
+
+  var uncle = parent.createChild(),
+      sibling = child.parent.createChild();
+
+  do_check_eq(child.parent.parent, parent);
+  do_check_true(child.parent.isValid);
+
+  do_check_true(child.parent.invalidate());
+  do_check_false(child.isValid);
+  do_check_true(parent.isValid);
+
+  do_check_false(sibling.isValid);
+  do_check_true(uncle.isValid);
+
+  parent.invalidate();
+}
+
+function test_long_parent_chain(len) {
+  for (var handle = createHandle(), i = 0; i < len; ++i)
+    handle = handle.createChild();
+
+  var ancestor = handle;
+  while (ancestor.parent)
+    ancestor = ancestor.parent;
+
+  do_check_true(handle.isValid);
+  do_check_true(ancestor.invalidate());
+  do_check_false(handle.isValid);
+}
+
+function test_invalid_creation() {
+  var parent = createHandle(),
+      child = parent.createChild();
+
+  parent.invalidate();
+
+  do_check_eq(child.parent, null);
+
+  var threw = false;
+  try { child.createChild(); }
+  catch (x) { threw = true; }
+  do_check_true(threw);
+}
diff --git a/js/src/xpconnect/shell/xpcshell.cpp b/js/src/xpconnect/shell/xpcshell.cpp
--- a/js/src/xpconnect/shell/xpcshell.cpp
+++ b/js/src/xpconnect/shell/xpcshell.cpp
@@ -704,16 +704,31 @@ GetChildGlobalObject(JSContext* cx,
     JSObject* global;
     if (XRE_GetChildGlobalObject(cx, &global)) {
         *rval = OBJECT_TO_JSVAL(global);
         return JS_TRUE;
     }
     return JS_FALSE;
 }
 
+static JSBool
+CreateHandle(JSContext* cx,
+             JSObject*,
+             uintN,
+             jsval*,
+             jsval* rval)
+{
+    JSObject* handle;
+    if (XRE_CreateHandle(cx, &handle)) {
+        *rval = OBJECT_TO_JSVAL(handle);
+        return JS_TRUE;
+    }
+    return JS_FALSE;
+}
+
 #endif // MOZ_IPC
 
 /*
  * JSContext option name to flag map. The option names are in alphabetical
  * order for better reporting.
  */
 static const struct {
     const char  *name;
@@ -825,16 +840,17 @@ static JSFunctionSpec glob_functions[] =
     {"clear",           Clear,          1,0,0},
     {"options",         Options,        0,0,0},
 #ifdef DEBUG
     {"dumpHeap",        DumpHeap,       5,0,0},
 #endif
 #ifdef MOZ_IPC
     {"sendCommand",     SendCommand,    1,0,0},
     {"getChildGlobalObject", GetChildGlobalObject, 0,0,0},
+    {"createHandle",    CreateHandle,   0,0,0},
 #endif
 #ifdef MOZ_SHARK
     {"startShark",      js_StartShark,      0,0,0},
     {"stopShark",       js_StopShark,       0,0,0},
     {"connectShark",    js_ConnectShark,    0,0,0},
     {"disconnectShark", js_DisconnectShark, 0,0,0},
 #endif
 #ifdef MOZ_CALLGRIND
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -564,16 +564,23 @@ XRE_SendTestShellCommand(JSContext* aCx,
 bool
 XRE_GetChildGlobalObject(JSContext* aCx, JSObject** aGlobalP)
 {
     TestShellParent* tsp = GetOrCreateTestShellParent();
     return tsp && tsp->GetGlobalJSObject(aCx, aGlobalP);
 }
 
 bool
+XRE_CreateHandle(JSContext* aCx, JSObject** aHandleP)
+{
+    TestShellParent* tsp = GetOrCreateTestShellParent();
+    return tsp && tsp->CreateHandle(aCx, aHandleP);
+}
+
+bool
 XRE_ShutdownTestShell()
 {
   if (!gTestShellParent)
     return true;
   return ContentProcessParent::GetSingleton()->DestroyTestShell(gTestShellParent);
 }
 
 #ifdef MOZ_X11
diff --git a/xpcom/build/nsXULAppAPI.h b/xpcom/build/nsXULAppAPI.h
--- a/xpcom/build/nsXULAppAPI.h
+++ b/xpcom/build/nsXULAppAPI.h
@@ -502,16 +502,20 @@ struct JSString;
 XRE_API(bool,
         XRE_SendTestShellCommand, (JSContext* aCx,
                                    JSString* aCommand,
                                    void* aCallback))
 struct JSObject;
 
 XRE_API(bool,
         XRE_GetChildGlobalObject, (JSContext* aCx,
-                                   JSObject** globalp))
+                                   JSObject** aGlobalP))
+
+XRE_API(bool,
+        XRE_CreateHandle, (JSContext* aCx,
+                           JSObject** aHandleP))
 
 XRE_API(bool,
         XRE_ShutdownTestShell, ())
 
 XRE_API(void,
         XRE_InstallX11ErrorHandler, ())
 #endif // _nsXULAppAPI_h__
