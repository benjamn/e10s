diff --git a/js/src/ipc/ContextWrapperChild.h b/js/src/ipc/ContextWrapperChild.h
--- a/js/src/ipc/ContextWrapperChild.h
+++ b/js/src/ipc/ContextWrapperChild.h
@@ -38,16 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_jsipc_ContextWrapperChild_h__
 #define mozilla_jsipc_ContextWrapperChild_h__
 
 #include "mozilla/jsipc/PContextWrapperChild.h"
 #include "mozilla/jsipc/ObjectWrapperChild.h"
+#include "mozilla/jsipc/Handle.h"
 
 #include "jsapi.h"
 #include "nsClassHashtable.h"
 #include "nsHashKeys.h"
 
 namespace mozilla {
 namespace jsipc {
 
@@ -76,33 +77,41 @@ public:
             if (wrapper)
                 mResidentObjectTable.Put(obj, wrapper);
             else
                 return NULL;
         }
         return wrapper;
     }
 
-protected:
+private:
 
     PObjectWrapperChild* AllocPObjectWrapper(JSObject* obj) {
         return new ObjectWrapperChild(mContext, obj);
     }
     
     PObjectWrapperChild* AllocPObjectWrapper(const bool&) {
         return AllocPObjectWrapper(JS_GetGlobalObject(mContext));
     }
 
     bool DeallocPObjectWrapper(PObjectWrapperChild* actor) {
         ObjectWrapperChild* owc = static_cast<ObjectWrapperChild*>(actor);
         mResidentObjectTable.Remove(owc->GetJSObject());
         return true;
     }
 
-private:
+    PHandleChild* AllocPHandle() {
+        return new HandleChild();
+    }
+
+    bool DeallocPHandle(PHandleChild* actor)
+    {
+        delete actor;
+        return true;
+    }
 
     JSContext* const mContext;
 
     nsClassHashtable<nsPtrHashKey<JSObject>,
                      PObjectWrapperChild> mResidentObjectTable;
 
 };
 
diff --git a/js/src/ipc/ContextWrapperParent.h b/js/src/ipc/ContextWrapperParent.h
--- a/js/src/ipc/ContextWrapperParent.h
+++ b/js/src/ipc/ContextWrapperParent.h
@@ -38,16 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_jsipc_ContextWrapperParent_h__
 #define mozilla_jsipc_ContextWrapperParent_h__
 
 #include "mozilla/jsipc/PContextWrapperParent.h"
 #include "mozilla/jsipc/ObjectWrapperParent.h"
+#include "mozilla/jsipc/Handle.h"
 #include "mozilla/jsipc/CPOWTypes.h"
 
 #include "mozilla/dom/ContentProcessParent.h"
 
 #include "jsapi.h"
 #include "nsAutoJSValHolder.h"
 
 namespace mozilla {
@@ -107,13 +108,23 @@ private:
             mGlobal == static_cast<ObjectWrapperParent*>(actor)) {
             mGlobalHolder.Release();
             mGlobal = NULL;
         }
         delete actor;
         return true;
     }
 
+    PHandleParent* AllocPHandle() {
+        return new HandleParent();
+    }
+
+    bool DeallocPHandle(PHandleParent* actor)
+    {
+        delete actor;
+        return true;
+    }
+
 };
 
 }}
 
 #endif
diff --git a/js/src/ipc/Handle.h b/js/src/ipc/Handle.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/Handle.h
@@ -0,0 +1,243 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_jsipc_HandleParent_h__
+#define mozilla_jsipc_HandleParent_h__
+
+#include "mozilla/jsipc/PHandleParent.h"
+#include "mozilla/jsipc/PHandleChild.h"
+
+#include "jsapi.h"
+#include "jsobj.h"
+#include "jscntxt.h"
+
+namespace mozilla {
+namespace jsipc {
+
+template <class BaseType>
+class Handle
+    : public BaseType
+{
+    Handle(Handle* parent)
+        : mParent(parent)
+        , mObj(NULL)
+    {}
+
+    BaseType* AllocPHandle() {
+        return new Handle(this);
+    }
+
+    bool DeallocPHandle(BaseType* actor) {
+        delete actor;
+        return true;
+    }
+
+public:
+
+    Handle()
+        : mParent(NULL)
+        , mObj(NULL)
+    {}
+
+    JSObject* GetJSObject(JSContext* cx) const {
+        if (!mObj && !mRuntime) {
+            JSClass* clasp = const_cast<JSClass*>(&sHandle_JSClass);
+            JSObject* obj = JS_NewObject(cx, clasp, NULL, NULL);
+            if (!obj)
+                return NULL;
+            js::AutoValueRooter avr(cx, obj);
+
+            JSPropertySpec* ps = const_cast<JSPropertySpec*>(sHandle_Properties);
+            JSFunctionSpec* fs = const_cast<JSFunctionSpec*>(sHandle_Functions);
+            JSRuntime* rt;
+
+            if (JS_SetPrivate(cx, obj, (void*)this) &&
+                JS_DefineProperties(cx, obj, ps) &&
+                JS_DefineFunctions(cx, obj, fs) &&
+                JS_AddNamedRootRT(rt = JS_GetRuntime(cx), (void*)&mObj,
+                                  "mozilla::jsipc::Handle<BaseType>::mObj"))
+            {
+                mObj = obj;
+                mRuntime = rt;
+            }
+        }
+        return mObj;
+    }
+
+protected:
+
+    // XXX Why not simply ActorDestroyReason?
+    void ActorDestroy(typename Handle::ActorDestroyReason why) {
+        if (mObj) {
+            mObj->setPrivate(NULL);
+            mObj = NULL;
+        }
+        // Nulling out mObj effectively unroots the object, but we still
+        // need to remove the root for good hygiene's sake.
+        if (mRuntime) {
+            JS_RemoveRootRT(mRuntime, (void*)&mObj);
+            // By not nulling out mRuntime, we prevent GetJSObject from
+            // reviving an invalidated/destroyed handle.
+        }
+    }
+
+private:
+
+    static const JSClass        sHandle_JSClass;
+    static const JSPropertySpec sHandle_Properties[];
+    static const JSFunctionSpec sHandle_Functions[];
+
+    Handle* const mParent;
+
+    // Used to cache the JSObject returned by GetJSObject, which is
+    // otherwise a const method.
+    mutable JSObject*  mObj;
+    mutable JSRuntime* mRuntime;
+
+    static Handle*
+    Unwrap(JSContext* cx, JSObject* obj) {
+        if (!obj)
+            return NULL;
+
+        while (obj->getClass() != &sHandle_JSClass)
+            if (!(obj = obj->getProto()))
+                return NULL;
+
+        Handle* self = static_cast<Handle*>(JS_GetPrivate(cx, obj));
+
+        NS_ASSERTION(!self || self->GetJSObject(cx) == obj,
+                     "Wrapper and wrapped object disagree?");
+
+        return self;
+    }
+
+    static JSBool
+    GetParent(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        Handle* self = Unwrap(cx, obj);
+        if (!self) {
+            JS_ReportError(cx, "Unwrap failed while getting parent");
+            return JS_FALSE;
+        }
+
+        Handle* parent = self->mParent;
+        *vp = parent ? OBJECT_TO_JSVAL(parent->GetJSObject(cx))
+                     : JSVAL_NULL;
+
+        return JS_TRUE;
+    }
+
+    static JSBool
+    GetIsValid(JSContext* cx, JSObject* obj, jsval, jsval* vp) {
+        *vp = Unwrap(cx, obj) ? JS_TRUE : JS_FALSE;
+        return JS_TRUE;
+    }
+
+    static JSBool
+    Invalidate(JSContext* cx, uintN argc, jsval* vp) {
+        if (argc > 0) {
+            JS_ReportError(cx, "invalidate takes zero arguments");
+            return JS_FALSE;
+        }
+
+        Handle* self = Unwrap(cx, JS_THIS_OBJECT(cx, vp));
+        if (!self) {
+            JS_ReportError(cx, "Unwrap failed while invalidating");
+            return JS_FALSE;
+        }
+
+        return Send__delete__(self);
+    }
+
+    static void
+    Finalize(JSContext* cx, JSObject* obj) {
+        Handle* self = Unwrap(cx, obj);
+        if (self)
+            Send__delete__(self);
+    }
+
+};
+
+template <class BaseType>
+const JSClass
+Handle<BaseType>::sHandle_JSClass = {
+    "IPDL Handle", JSCLASS_HAS_RESERVED_SLOTS(0),
+    JS_PropertyStub, JS_PropertyStub,
+    JS_PropertyStub, JS_PropertyStub,
+    JS_EnumerateStub, JS_ResolveStub,
+    JS_ConvertStub, Handle::Finalize,
+    JSCLASS_NO_OPTIONAL_MEMBERS
+};
+
+#define HANDLE_PROP_FLAGS (JSPROP_SHARED |           \
+                           JSPROP_READONLY |         \
+                           JSPROP_PERMANENT |        \
+                           JSPROP_GETTER)
+
+template <class BaseType>
+const JSPropertySpec
+Handle<BaseType>::sHandle_Properties[] = {
+    { "parent",  0, HANDLE_PROP_FLAGS, GetParent,  NULL },
+    { "isValid", 0, HANDLE_PROP_FLAGS, GetIsValid, NULL },
+    { 0, 0, 0, NULL, NULL }
+};
+
+#undef HANDLE_PROP_FLAGS
+
+#define HANDLE_FUN_FLAGS (JSFUN_FAST_NATIVE |   \
+                          JSPROP_READONLY |     \
+                          JSPROP_PERMANENT)
+
+template <class BaseType>
+const JSFunctionSpec
+Handle<BaseType>::sHandle_Functions[] = {
+  JS_FN("invalidate", Invalidate, 0, HANDLE_FUN_FLAGS),
+  JS_FS_END
+};
+
+#undef HANDLE_FUN_FLAGS
+
+// The payoff for using templates is that these two implementations are
+// guaranteed to be perfectly symmetric:
+typedef Handle<PHandleParent> HandleParent;
+typedef Handle<PHandleChild> HandleChild;
+
+}}
+
+#endif
diff --git a/js/src/ipc/Makefile.in b/js/src/ipc/Makefile.in
--- a/js/src/ipc/Makefile.in
+++ b/js/src/ipc/Makefile.in
@@ -51,16 +51,17 @@ EXPORT_LIBRARY = 1
 EXPORTS_NAMESPACES = mozilla/jsipc
 
 EXPORTS_mozilla/jsipc = \
   CPOWTypes.h \
   ContextWrapperChild.h \
   ContextWrapperParent.h \
   ObjectWrapperParent.h \
   ObjectWrapperChild.h \
+  Handle.h \
   $(NULL)
 
 CPPSRCS = \
   ObjectWrapperParent.cpp \
   ObjectWrapperChild.cpp \
   $(NULL)
 
 ifdef ENABLE_TESTS
diff --git a/js/src/ipc/ObjectWrapperChild.cpp b/js/src/ipc/ObjectWrapperChild.cpp
--- a/js/src/ipc/ObjectWrapperChild.cpp
+++ b/js/src/ipc/ObjectWrapperChild.cpp
@@ -38,16 +38,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "base/basictypes.h"
 #include "jscntxt.h"
 
 #include "mozilla/jsipc/ContextWrapperChild.h"
 #include "mozilla/jsipc/ObjectWrapperChild.h"
+#include "mozilla/jsipc/Handle.h"
 #include "mozilla/jsipc/CPOWTypes.h"
 
 #include "jsapi.h"
 #include "nsAutoPtr.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
 #include "nsIJSContextStack.h"
 
@@ -128,16 +129,21 @@ ObjectWrapperChild::CheckOperation(JSCon
                                    OperationStatus* status)
 {
     NS_PRECONDITION(status->type() != OperationStatus::T__None,
                     "Checking an uninitialized operation.");
 
     JSContext* cx = Manager()->GetContext();
     jsval thrown;
 
+#ifdef DEBUG
+    if (!cx) // Never actually do this; just force template expansion.
+        (new HandleChild())->GetJSObject(cx);
+#endif
+
     if (JS_GetPendingException(cx, &thrown)) {
         NS_ASSERTION(!(status->type() == OperationStatus::TJSBool &&
                        status->get_JSBool()),
                      "Operation succeeded but exception was thrown?");
         JSVariant exception;
         if (!jsval_to_JSVariant(cx, thrown, &exception))
             exception = void_t(); // XXX Useful?
         *status = exception;
diff --git a/js/src/ipc/ObjectWrapperParent.cpp b/js/src/ipc/ObjectWrapperParent.cpp
--- a/js/src/ipc/ObjectWrapperParent.cpp
+++ b/js/src/ipc/ObjectWrapperParent.cpp
@@ -35,16 +35,17 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "mozilla/jsipc/ObjectWrapperParent.h"
 #include "mozilla/jsipc/ContextWrapperParent.h"
+#include "mozilla/jsipc/Handle.h"
 #include "mozilla/jsipc/CPOWTypes.h"
 
 #include "jsobj.h"
 #include "jsfun.h"
 #include "jsutil.h"
 
 using namespace mozilla::jsipc;
 
@@ -214,16 +215,21 @@ ObjectWrapperParent::Manager()
 {
     PContextWrapperParent* pcwp = PObjectWrapperParent::Manager();
     return static_cast<ContextWrapperParent*>(pcwp);
 }
 
 JSObject*
 ObjectWrapperParent::GetJSObject(JSContext* cx) const
 {
+#ifdef DEBUG
+    if (!cx) // Never actually do this; just force template expansion.
+        (new HandleParent())->GetJSObject(cx);
+#endif
+
     JSClass* clasp = const_cast<JSClass*>(&ObjectWrapperParent::sCPOW_JSClass.base);
     if (!mObj && (mObj = JS_NewObject(cx, clasp, NULL, NULL))) {
         JS_SetPrivate(cx, mObj, (void*)this);
         JS_SetReservedSlot(cx, mObj, sFlagsSlot, JSVAL_ZERO);
     }
     return mObj;
 }
 
diff --git a/js/src/ipc/PContextWrapper.ipdl b/js/src/ipc/PContextWrapper.ipdl
--- a/js/src/ipc/PContextWrapper.ipdl
+++ b/js/src/ipc/PContextWrapper.ipdl
@@ -36,22 +36,26 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol PIFrameEmbedding;
 include protocol PTestShell;
 include protocol PObjectWrapper;
+include protocol PHandle;
 
 namespace mozilla {
 namespace jsipc {
 
 rpc protocol PContextWrapper
 {
     manager PIFrameEmbedding or PTestShell;
     manages PObjectWrapper;
+    manages PHandle;
 parent:
     async __delete__();
     async PObjectWrapper(bool makeGlobal);
+both:
+    async PHandle();
 };
 
 }}
diff --git a/js/src/ipc/PHandle.ipdl b/js/src/ipc/PHandle.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PHandle.ipdl
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sw=4 et tw=80:
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2010
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol PContextWrapper;
+
+namespace mozilla {
+namespace jsipc {
+
+protocol PHandle
+{
+    manager PContextWrapper or PHandle;
+    manages PHandle;
+both:
+    async PHandle();
+    __delete__();
+};
+
+}}
diff --git a/js/src/ipc/ipdl.mk b/js/src/ipc/ipdl.mk
--- a/js/src/ipc/ipdl.mk
+++ b/js/src/ipc/ipdl.mk
@@ -33,9 +33,10 @@
 # the provisions above, a recipient may use your version of this file under
 # the terms of any one of the MPL, the GPL or the LGPL.
 #
 # ***** END LICENSE BLOCK *****
 
 IPDLSRCS = \
   PContextWrapper.ipdl \
   PObjectWrapper.ipdl \
+  PHandle.ipdl \
   $(NULL)
diff --git a/js/src/ipc/tests/unit/handle_child.js b/js/src/ipc/tests/unit/handle_child.js
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/tests/unit/handle_child.js
@@ -0,0 +1,1 @@
+function run_test() {}
diff --git a/js/src/ipc/tests/unit/test_handle.js b/js/src/ipc/tests/unit/test_handle.js
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/tests/unit/test_handle.js
@@ -0,0 +1,9 @@
+function run_test() {
+  run_test_in_child("handle_child.js",
+                    run_actual_tests);
+}
+
+function run_actual_tests() {
+  getChildGlobalObject();
+  do_test_finished();
+}
