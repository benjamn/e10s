# HG changeset patch
# User Ben Newman <bnewman@mozilla.com>
# Date 1257540219 28800
# Node ID a82312ef8ffd49051c380264ad70c05b5948c643
# Parent  69674697dbce469745f1baaccb507cca27afd1e8
[mq]: jpw.diff

diff --git a/content/base/public/nsIFrameLoader.idl b/content/base/public/nsIFrameLoader.idl
--- a/content/base/public/nsIFrameLoader.idl
+++ b/content/base/public/nsIFrameLoader.idl
@@ -34,19 +34,29 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
+%{C++
+#include "jsapi.h"
+struct JSContext;
+struct JSObject;
+%}
+
+[ptr] native JSContextPtr(JSContext);
+[ptr] native JSObjectPtr(JSObject);
+
 interface nsIDocShell;
 interface nsIURI;
 interface nsIFrame;
+interface nsIVariant;
 
 [scriptable, uuid(8f94788d-ec69-4220-971c-0fd68d47b80f)]
 interface nsIFrameLoader : nsISupports
 {
   /**
    * Get the docshell from the frame loader.
    */
   readonly attribute nsIDocShell docShell;
@@ -99,16 +109,22 @@ interface nsIFrameLoader : nsISupports
                                   in long aClickCount,
                                   in long aModifiers,
                                   [optional] in boolean aIgnoreRootScrollFrame);
 
   /**
    * Activate event forwarding from client (remote frame) to parent.
    */
   void activateFrameEvent(in AString aType, in boolean capture);
+
+  /**
+   * Define a property on |where| named |property| whose value is a JSObject
+   * corresponding to the global object of the child frame.
+   */
+  void attachChildGlobal(in nsIVariant where, in AString property);
 };
 
 native alreadyAddRefed_nsFrameLoader(already_AddRefed<nsFrameLoader>);
 
 [scriptable, uuid(8f3b12a0-35ae-4e0d-9152-8e0d7e49d446)]
 interface nsIFrameLoaderOwner : nsISupports
 {
   /**
diff --git a/content/base/src/nsFrameLoader.cpp b/content/base/src/nsFrameLoader.cpp
--- a/content/base/src/nsFrameLoader.cpp
+++ b/content/base/src/nsFrameLoader.cpp
@@ -1,9 +1,9 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* -*- Mode: C++; tab-width: 1; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=2 sw=2 et tw=78: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
@@ -83,16 +83,17 @@
 #include "nsEventDispatcher.h"
 #include "nsISHistory.h"
 #include "nsISHistoryInternal.h"
 #include "nsIDOMNSHTMLDocument.h"
 #include "nsLayoutUtils.h"
 
 #include "nsIURI.h"
 #include "nsIURL.h"
+
 #include "nsNetUtil.h"
 
 #include "nsGkAtoms.h"
 #include "nsINameSpaceManager.h"
 
 #include "nsThreadUtils.h"
 #include "nsICSSStyleSheet.h"
 #include "nsIContentViewer.h"
@@ -108,16 +109,19 @@
 #ifdef MOZ_IPC
 #include "ContentProcessParent.h"
 #include "TabParent.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 #endif
 
+#include "nsIXPConnect.h"
+#include "nsIJSContextStack.h"
+
 class nsAsyncDocShellDestroyer : public nsRunnable
 {
 public:
   nsAsyncDocShellDestroyer(nsIDocShell* aDocShell)
     : mDocShell(aDocShell)
   {
   }
 
@@ -1508,16 +1512,42 @@ nsFrameLoader::ActivateFrameEvent(const 
   if (mChildProcess) {
     mChildProcess->SendactivateFrameEvent(nsString(aType), aCapture);
     return NS_OK;
   }
 #endif
   return NS_ERROR_FAILURE;
 }
 
+NS_IMETHODIMP
+nsFrameLoader::AttachChildGlobal(nsIVariant* where,
+                                 const nsAString& property)
+{
+  nsIXPConnect* xpc;
+  nsIThreadJSContextStack* stack;
+  JSContext* cx;
+  jsval v;
+  JSObject* obj;
+  JSString* str;
+  jsid interned_id;
+
+  if ((xpc = nsContentUtils::XPConnect()) &&
+      (stack = nsContentUtils::ThreadJSContextStack()) &&
+      NS_SUCCEEDED(stack->Peek(&cx)) && cx &&
+      NS_SUCCEEDED(xpc->VariantToJS(cx, JS_GetScopeChain(cx), where, &v)) &&
+      JS_ValueToObject(cx, v, &obj) &&
+      (str = JS_NewUCStringCopyN(cx, property.BeginReading(),
+                                 property.Length())) &&
+      JS_ValueToId(cx, STRING_TO_JSVAL(str), &interned_id) &&
+      mChildProcess->AttachGlobal(cx, obj, interned_id))
+    return NS_OK;
+
+  return NS_ERROR_FAILURE;
+}
+
 nsresult
 nsFrameLoader::CreateStaticClone(nsIFrameLoader* aDest)
 {
   nsFrameLoader* dest = static_cast<nsFrameLoader*>(aDest);
   dest->MaybeCreateDocShell();
   NS_ENSURE_STATE(dest->mDocShell);
 
   nsCOMPtr<nsIDOMDocument> dummy = do_GetInterface(dest->mDocShell);
diff --git a/dom/ipc/PContentProcess.ipdl b/dom/ipc/PContentProcess.ipdl
--- a/dom/ipc/PContentProcess.ipdl
+++ b/dom/ipc/PContentProcess.ipdl
@@ -40,17 +40,17 @@ include protocol "PIFrameEmbedding.ipdl"
 include protocol "PTestShell.ipdl";
 include protocol "PNecko.ipdl";
 
 include "mozilla/TabTypes.h";
 
 namespace mozilla {
 namespace dom {
 
-sync protocol PContentProcess
+rpc protocol PContentProcess
 {
     manages PIFrameEmbedding;
     manages PTestShell;
     manages PNecko;
 
 child:
     PIFrameEmbedding();
 
diff --git a/dom/ipc/PIFrameEmbedding.ipdl b/dom/ipc/PIFrameEmbedding.ipdl
--- a/dom/ipc/PIFrameEmbedding.ipdl
+++ b/dom/ipc/PIFrameEmbedding.ipdl
@@ -34,42 +34,49 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 include protocol "PContentProcess.ipdl";
 include protocol "PDocumentRenderer.ipdl";
+include protocol "PScriptProxy.ipdl";
+include protocol "PJSObject.ipdl";
 
 include "mozilla/TabTypes.h";
 include "TabMessageUtils.h";
+include "mozilla/js/ipc/ScriptProxyTypes.h";
 
 using MagicWindowHandle;
 using RemoteDOMEvent;
 
 namespace mozilla {
 namespace dom {
 
-async protocol PIFrameEmbedding
+rpc protocol PIFrameEmbedding
 {
     manager PContentProcess;
     manages PDocumentRenderer;
+    manages PScriptProxy;
 
 child:
     __delete__();
 
 parent:
     /**
      * When child sends this message, parent should move focus to
      * the next or previous focusable element.
      */
     moveFocus(bool forward);
 
     sendEvent(RemoteDOMEvent aEvent);
+
+    PScriptProxy();
+
 child:
     createWidget(MagicWindowHandle parentWidget);
 
     loadURL(nsCString uri);
 
     move(PRUint32 x,
          PRUint32 y,
          PRUint32 width,
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -50,16 +50,22 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMWindowUtils.h"
 #include "nsISupportsImpl.h"
 #include "nsIWebBrowserFocus.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 
+#include "mozilla/js/ipc/ScriptProxyChild.h"
+#include "nsIDocument.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIScriptContext.h"
+#include "jscntxt.h"
+
 #ifdef MOZ_WIDGET_GTK2
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 #endif
 
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS1(ContentListener, nsIDOMEventListener)
@@ -94,16 +100,17 @@ TabChild::Init()
 
   webBrowser->SetContainerWindow(this);
 
   mWebNav = do_QueryInterface(webBrowser);
   NS_ASSERTION(mWebNav, "nsWebBrowser doesn't implement nsIWebNavigation?");
 
   nsCOMPtr<nsIDocShellTreeItem> docShellItem(do_QueryInterface(mWebNav));
   docShellItem->SetItemType(nsIDocShellTreeItem::typeContentWrapper);
+
   return NS_OK;
 }
 
 NS_IMPL_ISUPPORTS5(TabChild, nsIWebBrowserChrome, nsIWebBrowserChrome2,
                    nsIEmbeddingSiteWindow, nsIEmbeddingSiteWindow2,
                    nsIWebBrowserChromeFocus)
 
 NS_IMETHODIMP
@@ -300,16 +307,19 @@ TabChild::RecvloadURL(const nsCString& u
     printf("loading %s, %d\n", uri.get(), NS_IsMainThread());
 
     nsresult rv = mWebNav->LoadURI(NS_ConvertUTF8toUTF16(uri).get(),
                                    nsIWebNavigation::LOAD_FLAGS_NONE,
                                    NULL, NULL, NULL);
     if (NS_FAILED(rv)) {
         NS_WARNING("mWebNav->LoadURI failed. Eating exception, what else can I do?");
     }
+
+    SendPScriptProxyConstructor()->SendPJSObjectConstructor(true);
+    
     return true;
 }
 
 bool
 TabChild::Recvmove(const PRUint32& x,
                      const PRUint32& y,
                      const PRUint32& width,
                      const PRUint32& height)
@@ -342,16 +352,94 @@ TabChild::RecvsendMouseEvent(const nsStr
   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(mWebNav);
   nsCOMPtr<nsIDOMWindowUtils> utils = do_GetInterface(window);
   NS_ENSURE_TRUE(utils, true);
   utils->SendMouseEvent(aType, aX, aY, aButton, aClickCount, aModifiers,
                         aIgnoreRootScrollFrame);
   return true;
 }
 
+#include "nsIScriptGlobalObjectOwner.h"
+
+mozilla::js::ipc::PScriptProxyChild*
+TabChild::AllocPScriptProxy()
+{
+#if 0
+    nsCOMPtr<nsIDocShell> docShell;
+    nsCOMPtr<nsIScriptGlobalObjectOwner> owner;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+    JSContext* cx;
+
+    if ((docShell = do_QueryInterface(mWebNav)) &&
+        (owner = do_QueryInterface(mWebNav)) &&
+        (global = owner->GetScriptGlobalObject()) &&
+        (context = do_QueryInterface(global->GetContext())) &&
+        (cx = static_cast<JSContext*>(context->GetNativeContext())))
+        return mScriptProxy = new mozilla::js::ipc::ScriptProxyChild(cx);
+
+    return NULL;
+#endif
+    
+#if 0
+    nsCOMPtr<nsIJSRuntimeService>
+        rtsvc(do_GetService("@mozilla.org/js/xpc/RuntimeService;1"));
+    JSRuntime* rt;
+    JSContext* cx;
+    if (NS_SUCCEEDED(rtsvc->GetRuntime(&rt)) &&
+        (cx = JS_NewContext(rt, 1<<10)))
+        return mScriptProxy = new mozilla::js::ipc::ScriptProxyChild(cx);
+    return NULL;
+#endif
+    
+#if 1
+    nsCOMPtr<nsIDOMDocument> domDocument;
+    nsCOMPtr<nsIDocument> document;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+    JSContext* cx;
+
+    if (NS_SUCCEEDED(mWebNav->GetDocument(getter_AddRefs(domDocument))) &&
+        (document = do_QueryInterface(domDocument)) &&
+        (global = do_QueryInterface(document->GetScriptGlobalObject())) &&
+        (context = do_QueryInterface(global->GetContext())) &&
+        (cx = static_cast<JSContext*>(context->GetNativeContext())))
+        return mScriptProxy = new mozilla::js::ipc::ScriptProxyChild(cx);
+
+    return NULL;
+#endif
+
+#if 0
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    nsCOMPtr<nsIDOMWindow> domWindow;
+    nsCOMPtr<nsIDOMDocument> domDocument;
+    nsCOMPtr<nsIDocument> document;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+    JSContext* cx;
+    if ((webBrowser = do_QueryInterface(mWebNav)) &&
+        (NS_SUCCEEDED(webBrowser->GetContentDOMWindow(getter_AddRefs(domWindow)))) &&
+        (NS_SUCCEEDED(domWindow->GetDocument(getter_AddRefs(domDocument)))) &&
+        (document = do_QueryInterface(domDocument)) &&
+        (global = do_QueryInterface(document->GetScriptGlobalObject())) &&
+        (context = do_QueryInterface(global->GetContext())) &&
+        (cx = static_cast<JSContext*>(context->GetNativeContext()))) {
+        return mScriptProxy = new mozilla::js::ipc::ScriptProxyChild(cx);
+    }
+    return NULL;
+#endif
+}
+
+bool
+TabChild::DeallocPScriptProxy(mozilla::js::ipc::PScriptProxyChild* actor)
+{
+    delete actor;
+    return true;
+}
+
 mozilla::ipc::PDocumentRendererChild*
 TabChild::AllocPDocumentRenderer(
         const PRInt32& x,
         const PRInt32& y,
         const PRInt32& w,
         const PRInt32& h,
         const nsString& bgcolor,
         const PRUint32& flags,
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -44,16 +44,19 @@
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 #include "nsIWebBrowserChrome2.h"
 #include "nsIEmbeddingSiteWindow2.h"
 #include "nsIWebBrowserChromeFocus.h"
 #include "nsIDOMEventListener.h"
 #include "nsIDOMEventTarget.h"
 
+#include "mozilla/js/ipc/ScriptProxyChild.h"
+#include "mozilla/js/ipc/PScriptProxyChild.h"
+
 namespace mozilla {
 namespace dom {
 
 class TabChild;
 
 class ContentListener : public nsIDOMEventListener
 {
 public:
@@ -111,18 +114,23 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
 
+protected:
+    mozilla::js::ipc::PScriptProxyChild* AllocPScriptProxy();
+    bool DeallocPScriptProxy(mozilla::js::ipc::PScriptProxyChild*);
+    
 private:
     nsCOMPtr<nsIWebNavigation> mWebNav;
+    mozilla::js::ipc::ScriptProxyChild* mScriptProxy;
 
     DISALLOW_EVIL_CONSTRUCTORS(TabChild);
 };
 
 }
 }
 
 #endif // mozilla_tabs_TabChild_h
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -46,30 +46,44 @@
 #include "nsCOMPtr.h"
 #include "nsServiceManagerUtils.h"
 #include "nsIDOMElement.h"
 #include "nsEventDispatcher.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMEvent.h"
 #include "nsIPrivateDOMEvent.h"
 
+#include "mozilla/js/ipc/ScriptProxyParent.h"
+#include "nsIDOMDocument.h"
+#include "nsIDocument.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIScriptContext.h"
+#include "jscntxt.h"
+
 using mozilla::ipc::BrowserProcessSubThread;
 using mozilla::ipc::DocumentRendererParent;
 
 namespace mozilla {
 namespace dom {
 
 TabParent::TabParent()
 {
 }
 
 TabParent::~TabParent()
 {
 }
 
+void
+TabParent::SetOwnerElement(nsIDOMElement* aElement)
+{
+    if (mFrameElement != aElement)
+        mFrameElement = aElement;
+}
+
 bool
 TabParent::RecvmoveFocus(const bool& aForward)
 {
   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
   if (fm) {
     nsCOMPtr<nsIDOMElement> dummy;
     PRUint32 type = aForward ? nsIFocusManager::MOVEFOCUS_FORWARD
                              : nsIFocusManager::MOVEFOCUS_BACKWARD;
@@ -109,16 +123,45 @@ TabParent::Move(PRUint32 x, PRUint32 y, 
 }
 
 void
 TabParent::Activate()
 {
     Sendactivate();
 }
 
+mozilla::js::ipc::PScriptProxyParent*
+TabParent::AllocPScriptProxy()
+{
+    return mScriptProxy = new mozilla::js::ipc::ScriptProxyParent();
+#if 0    
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    nsCOMPtr<nsIDocument> doc;
+    nsCOMPtr<nsIScriptGlobalObject> global;
+    nsCOMPtr<nsIScriptContext> context;
+    JSContext* cx;
+    if (mFrameElement &&
+        NS_SUCCEEDED(mFrameElement->GetOwnerDocument(getter_AddRefs(domDoc))) &&
+        (doc = do_QueryInterface(domDoc)) &&
+        (global = do_QueryInterface(doc->GetScriptGlobalObject())) &&
+        (context = do_QueryInterface(global->GetContext())) &&
+        (cx = static_cast<JSContext*>(context->GetNativeContext()))) {
+        mScriptProxy = new mozilla::js::ipc::ScriptProxyParent(cx);
+    }
+    return mScriptProxy;
+#endif
+}
+
+bool
+TabParent::DeallocPScriptProxy(mozilla::js::ipc::PScriptProxyParent* actor)
+{
+    delete actor;
+    return true;
+}
+
 mozilla::ipc::PDocumentRendererParent*
 TabParent::AllocPDocumentRenderer(const PRInt32& x,
         const PRInt32& y, const PRInt32& w, const PRInt32& h, const nsString& bgcolor,
         const PRUint32& flags, const bool& flush)
 {
     return new DocumentRendererParent();
 }
 
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -37,29 +37,32 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_tabs_TabParent_h
 #define mozilla_tabs_TabParent_h
 
 #include "mozilla/dom/PIFrameEmbeddingParent.h"
 
 #include "mozilla/ipc/GeckoChildProcessHost.h"
+#include "mozilla/js/ipc/ScriptProxyParent.h"
+
+#include "jsapi.h"
 
 class nsIURI;
 class nsIDOMElement;
 
 namespace mozilla {
 namespace dom {
 
 class TabParent : public PIFrameEmbeddingParent
 {
 public:
     TabParent();
     virtual ~TabParent();
-    void SetOwnerElement(nsIDOMElement* aElement) { mFrameElement = aElement; }
+    void SetOwnerElement(nsIDOMElement* aElement);
 
     virtual bool RecvmoveFocus(const bool& aForward);
     virtual bool RecvsendEvent(const RemoteDOMEvent& aEvent);
 
     void LoadURL(nsIURI* aURI);
     void Move(PRUint32 x, PRUint32 y, PRUint32 width, PRUint32 height);
     void Activate();
     void SendMouseEvent(const nsAString& aType, float aX, float aY,
@@ -70,16 +73,26 @@ public:
             const PRInt32& x,
             const PRInt32& y,
             const PRInt32& w,
             const PRInt32& h,
             const nsString& bgcolor,
             const PRUint32& flags,
             const bool& flush);
     virtual bool DeallocPDocumentRenderer(PDocumentRendererParent* actor);
+
+    mozilla::js::ipc::PScriptProxyParent* AllocPScriptProxy();
+    bool DeallocPScriptProxy(mozilla::js::ipc::PScriptProxyParent*);
+
+    bool AttachGlobal(JSContext* cx, JSObject* to, jsid id) {
+        return (mScriptProxy &&
+                mScriptProxy->AttachGlobal(cx, to, id));
+    }       
+
 protected:
     nsIDOMElement* mFrameElement;
+    mozilla::js::ipc::ScriptProxyParent* mScriptProxy;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif
diff --git a/dom/ipc/test.xul b/dom/ipc/test.xul
--- a/dom/ipc/test.xul
+++ b/dom/ipc/test.xul
@@ -72,23 +72,41 @@
 
     function openWindow() {
       window.open('chrome://global/content/test-ipc.xul', '_blank', 'chrome,resizable,width=800,height=800');
     }
     
     function closeWindow() {
       window.close();
     }
+
+    function getChildGlobal() {
+      var page = document.getElementById("page");
+      if (!("contentGlobalObject" in page))
+        page.QueryInterface(Components.interfaces.nsIFrameLoaderOwner)
+            .frameLoader.attachChildGlobal(page, "contentGlobalObject");
+      return page.contentGlobalObject;
+    }
+    
+    function show() {
+      var child = getChildGlobal();
+      alert(child.location.href);
+      child.location = prompt("Where to?");
+      setTimeout(function() {
+        alert(child.location.href);
+      }, 2000);
+    }
   </script>
 
   <toolbar id="controls">
     <toolbarbutton label="Back"/>
     <toolbarbutton label="Forward"/>
     <textbox onchange="loadURL(this.value)" flex="1" id="URL"/>
     <toolbarbutton onclick="restart()" label="Recover"/>
     <toolbarbutton onclick="randomClick()" label="random click"/>
     <toolbarbutton onclick="openWindow()" label="open new window"/>
     <toolbarbutton onclick="closeWindow()" label="close this window"/>
+    <toolbarbutton onclick="show()" label="JPW"/>
   </toolbar>
 
   <browser type="content" src="http://www.google.com/" flex="1" id="page" remote="true"
            onfocus="this.QueryInterface(Components.interfaces.nsIFrameLoaderOwner).frameLoader.activateRemoteFrame();"/>
 </window>
diff --git a/ipc/ipdl/Makefile.in b/ipc/ipdl/Makefile.in
--- a/ipc/ipdl/Makefile.in
+++ b/ipc/ipdl/Makefile.in
@@ -55,16 +55,17 @@ EXPORT_LIBRARY = 1
 ##
 IPDLDIRS =  \
   dom/plugins  \
   dom/ipc  \
   netwerk/ipc  \
   netwerk/protocol/http/src  \
   ipc/ipdl/test/cxx  \
   ipc/testshell  \
+  js/src/ipc  \
   $(NULL)
 ##-----------------------------------------------------------------------------
 
 ifdef MOZ_IPDL_TESTS
 DIRS += test
 endif
 
 vpath %.ipdl $(topsrcdir)
diff --git a/ipc/ipdl/test/cxx/Makefile.in b/ipc/ipdl/test/cxx/Makefile.in
--- a/ipc/ipdl/test/cxx/Makefile.in
+++ b/ipc/ipdl/test/cxx/Makefile.in
@@ -54,16 +54,17 @@ EXPORTS_mozilla/_ipdltest =  \
 
 LIBRARY_NAME = $(MODULE)_s
 LIBXUL_LIBRARY = 1
 FORCE_STATIC_LIB = 1
 EXPORT_LIBRARY = 1
 
 # Please keep these organized in the order "easy"-to-"hard"
 IPDLTESTS = \
+  TestScriptProxy \
   TestSanity  \
   TestLatency \
   TestRPCRaces \
   TestManyChildAllocs  \
   TestDesc \
   TestShmem \
   TestShutdown \
   TestArrays \
diff --git a/ipc/ipdl/test/cxx/PTestScriptProxy.ipdl b/ipc/ipdl/test/cxx/PTestScriptProxy.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/PTestScriptProxy.ipdl
@@ -0,0 +1,31 @@
+
+namespace mozilla {
+namespace _ipdltest {
+
+
+protocol PTestScriptProxy {
+
+child:
+    Ping(int zero, float zeroPtFive);
+
+parent:
+    Pong(int one, float zeroPtTwoFive);
+
+both:
+    UNREACHED();
+
+
+state PING:
+    send Ping goto PONG;
+
+state PONG:
+    recv Pong goto DEAD;
+
+    // hmm ... maybe support this idiom natively?
+state DEAD:
+    send UNREACHED goto DEAD;
+};
+
+
+} // namespace mozilla
+} // namespace _ipdltest
diff --git a/ipc/ipdl/test/cxx/TestScriptProxy.cpp b/ipc/ipdl/test/cxx/TestScriptProxy.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestScriptProxy.cpp
@@ -0,0 +1,97 @@
+#include "TestScriptProxy.h"
+
+#include "nsIAppShell.h"
+
+#include "nsCOMPtr.h"
+#include "nsServiceManagerUtils.h" // do_GetService()
+#include "nsWidgetsCID.h"       // NS_APPSHELL_CID
+
+#include "IPDLUnitTests.h"      // fail etc.
+
+namespace mozilla {
+namespace _ipdltest {
+
+//-----------------------------------------------------------------------------
+// parent
+
+TestScriptProxyParent::TestScriptProxyParent()
+{
+    MOZ_COUNT_CTOR(TestScriptProxyParent);
+}
+
+TestScriptProxyParent::~TestScriptProxyParent()
+{
+    MOZ_COUNT_DTOR(TestScriptProxyParent);
+}
+
+void
+TestScriptProxyParent::Main()
+{
+    if (!SendPing(0, 0.5f))
+        fail("sending Ping");
+}
+
+
+bool
+TestScriptProxyParent::RecvPong(const int& one, const float& zeroPtTwoFive)
+{
+    if (1 != one)
+        fail("invalid argument `%d', should have been `1'", one);
+
+    if (0.25f != zeroPtTwoFive)
+        fail("invalid argument `%g', should have been `0.25'", zeroPtTwoFive);
+
+    passed("sent ping/received pong");
+
+    static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
+    nsCOMPtr<nsIAppShell> appShell (do_GetService(kAppShellCID));
+    appShell->Exit();
+
+    return true;
+}
+
+bool
+TestScriptProxyParent::RecvUNREACHED()
+{
+    fail("unreached");
+    return false;               // not reached
+}
+
+
+//-----------------------------------------------------------------------------
+// child
+
+TestScriptProxyChild::TestScriptProxyChild()
+{
+    MOZ_COUNT_CTOR(TestScriptProxyChild);
+}
+
+TestScriptProxyChild::~TestScriptProxyChild()
+{
+    MOZ_COUNT_DTOR(TestScriptProxyChild);
+}
+
+bool
+TestScriptProxyChild::RecvPing(const int& zero, const float& zeroPtFive)
+{
+    if (0 != zero)
+        fail("invalid argument `%d', should have been `0'", zero);
+
+    if (0.5f != zeroPtFive)
+        fail("invalid argument `%g', should have been `0.5'", zeroPtFive);
+
+    if (!SendPong(1, 0.25f))
+        fail("sending Pong");
+    return true;
+}
+
+bool
+TestScriptProxyChild::RecvUNREACHED()
+{
+    fail("unreached");
+    return false;               // not reached
+}
+
+
+} // namespace _ipdltest
+} // namespace mozilla
diff --git a/ipc/ipdl/test/cxx/TestScriptProxy.h b/ipc/ipdl/test/cxx/TestScriptProxy.h
new file mode 100644
--- /dev/null
+++ b/ipc/ipdl/test/cxx/TestScriptProxy.h
@@ -0,0 +1,44 @@
+#ifndef mozilla__ipdltest_TestScriptProxy_h
+#define mozilla__ipdltest_TestScriptProxy_h 1
+
+
+#include "mozilla/_ipdltest/PTestScriptProxyParent.h"
+#include "mozilla/_ipdltest/PTestScriptProxyChild.h"
+
+namespace mozilla {
+namespace _ipdltest {
+
+
+class TestScriptProxyParent :
+    public PTestScriptProxyParent
+{
+public:
+    TestScriptProxyParent();
+    virtual ~TestScriptProxyParent();
+
+    void Main();
+
+protected:    
+    virtual bool RecvPong(const int& one, const float& zeroPtTwoFive);
+    virtual bool RecvUNREACHED();
+};
+
+
+class TestScriptProxyChild :
+    public PTestScriptProxyChild
+{
+public:
+    TestScriptProxyChild();
+    virtual ~TestScriptProxyChild();
+
+protected:
+    virtual bool RecvPing(const int& zero, const float& zeroPtFive);
+    virtual bool RecvUNREACHED();
+};
+
+
+} // namespace _ipdltest
+} // namespace mozilla
+
+
+#endif // ifndef mozilla__ipdltest_TestScriptProxy_h
diff --git a/ipc/ipdl/test/cxx/ipdl.mk b/ipc/ipdl/test/cxx/ipdl.mk
--- a/ipc/ipdl/test/cxx/ipdl.mk
+++ b/ipc/ipdl/test/cxx/ipdl.mk
@@ -8,9 +8,10 @@ IPDLSRCS =					\
   PTestManyChildAllocs.ipdl			\
   PTestManyChildAllocsSub.ipdl			\
   PTestRPCRaces.ipdl				\
   PTestSanity.ipdl				\
   PTestShmem.ipdl				\
   PTestShutdown.ipdl				\
   PTestShutdownSub.ipdl				\
   PTestShutdownSubsub.ipdl			\
+  PTestScriptProxy.ipdl				\
   $(NULL)
diff --git a/js/src/ipc/JSObjectChild.cpp b/js/src/ipc/JSObjectChild.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/JSObjectChild.cpp
@@ -0,0 +1,223 @@
+#include "mozilla/js/ipc/ScriptProxyChild.h"
+#include "mozilla/js/ipc/JSObjectChild.h"
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+JSObjectChild::JSObjectChild(JSContext* cx, JSObject* obj)
+    : mContext(cx)
+    , mObj(obj)
+{
+    JS_AddNamedRoot(mContext, (void*)&mObj,
+                    "mozilla::js::ipc::JSObjectChild-rooted JSObject*");
+}
+
+JSObjectChild::~JSObjectChild()
+{
+    JS_RemoveRoot(mContext, (void*)&mObj);
+}
+
+bool
+JSObjectChild::jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_OBJECT:
+        // fall through
+    case JSTYPE_FUNCTION:
+        {
+            JSObject* obj;
+            if (JS_ValueToObject(cx, from, &obj)) {
+                // TODO get-or-create-ify this:
+                *to = Manager()->SendPJSObjectConstructor(Manager()->AllocPJSObject(obj),
+                                                          false);
+                return true;
+            }
+            return false;
+        }
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+        return true;
+    case JSTYPE_XML:
+        // fall through
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+JSObjectChild::jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                    jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPJSObjectChild:
+        {
+            const JSObjectChild* jsoc =
+                static_cast<const JSObjectChild*>(from.get_PJSObjectChild());
+            *to = jsoc ? OBJECT_TO_JSVAL(jsoc->mObj) : JSVAL_NULL;
+            return true;
+        }
+    case JSVariant::TnsString:
+        *to = STRING_TO_JSVAL(JS_NewUCStringCopyN(cx,
+                                                  from.get_nsString().BeginReading(),
+                                                  from.get_nsString().Length()));
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+
+ScriptProxyChild*
+JSObjectChild::Manager()
+{
+    return static_cast<ScriptProxyChild*>(PJSObjectChild::Manager());
+}
+    
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    JSString* str = JS_NewUCStringCopyN(cx, from.BeginReading(), from.Length());
+    return ::JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+bool
+JSObjectChild::RecvAddProperty(const nsString& id)
+{
+    jsid interned_id;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+    
+    JS_DefinePropertyById(mContext, mObj, interned_id,
+                          JSVAL_ZERO, NULL, NULL, 0);
+    return true;
+}
+
+bool
+JSObjectChild::AnswerGetProperty(const nsString& id,
+                                 bool* ok,
+                                 JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = false;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    *ok = JS_GetPropertyById(mContext, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(mContext, val, vp);
+}
+
+bool
+JSObjectChild::AnswerSetProperty(const nsString& id,
+                                 const JSVariant& v,
+                                 bool* ok,
+                                 JSVariant* vp)
+{
+    jsid interned_id;
+    jsval val;
+
+    *ok = false;
+    *vp = v;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id) ||
+        !jsval_from_JSVariant(mContext, v, &val))
+        return false;
+
+    *ok = JS_SetPropertyById(mContext, mObj, interned_id, &val);
+
+    return jsval_to_JSVariant(mContext, val, vp);
+}
+
+bool
+JSObjectChild::AnswerDelProperty(const nsString& id,
+                                 bool* ok)
+{
+    jsid interned_id;
+
+    *ok = false;
+
+    JSAutoRequest request(mContext);
+
+    if (!jsid_from_nsString(mContext, id, &interned_id))
+        return false;
+
+    *ok = JS_DeletePropertyById(mContext, mObj, interned_id);
+    
+    return true;
+}
+
+bool
+JSObjectChild::AnswerNewEnumerateInit(bool* ok,
+                                      JSVariant* statep,
+                                      int* idp)
+{
+    return false;
+}
+
+bool
+JSObjectChild::AnswerNewEnumerateNext(const JSVariant& in_state,
+                                      bool* ok,
+                                      JSVariant* statep,
+                                      nsString* idp)
+{
+    return false;
+}
+    
+bool
+JSObjectChild::RecvNewEnumerateDestroy(const JSVariant& in_state)
+{
+    return false;
+}
+    
+bool
+JSObjectChild::AnswerNewResolve(const nsString& id,
+                                const int& flags,
+                                bool* ok,
+                                PJSObjectChild** obj2)
+{
+    *ok = true;
+    *obj2 = this;
+    return true;
+}
+    
+}}}
diff --git a/js/src/ipc/JSObjectChild.h b/js/src/ipc/JSObjectChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/JSObjectChild.h
@@ -0,0 +1,68 @@
+#ifndef mozilla_js_ipc_JSObjectChild_h__
+#define mozilla_js_ipc_JSObjectChild_h__
+
+#include "mozilla/js/ipc/PJSObjectChild.h"
+
+using mozilla::js::ipc::JSVariant;
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+class ScriptProxyChild;
+  
+class JSObjectChild
+    : public PJSObjectChild
+{
+public:
+
+    JSObjectChild(JSContext* cx, JSObject* obj);
+
+    ~JSObjectChild();
+    
+private:
+
+    JSContext* const mContext;
+    JSObject* const mObj;
+
+    bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+    ScriptProxyChild* Manager();
+
+protected:
+
+    bool RecvAddProperty(const nsString& id);
+
+    bool AnswerGetProperty(const nsString& id,
+                           bool* ok,
+                           JSVariant* vp);
+
+    bool AnswerSetProperty(const nsString& id,
+                           const JSVariant& v,
+                           bool* ok,
+                           JSVariant* vp);
+
+    bool AnswerDelProperty(const nsString& id,
+                           bool* ok);
+
+    bool AnswerNewEnumerateInit(bool* ok,
+                                JSVariant* statep,
+                                int* idp);
+
+    bool AnswerNewEnumerateNext(const JSVariant& in_state,
+                                bool* ok,
+                                JSVariant* statep,
+                                nsString* idp);
+
+    bool RecvNewEnumerateDestroy(const JSVariant& in_state);
+
+    bool AnswerNewResolve(const nsString& id,
+                          const int& flags,
+                          bool* ok,
+                          PJSObjectChild** obj2);
+};
+
+}}}
+  
+#endif
diff --git a/js/src/ipc/JSObjectParent.cpp b/js/src/ipc/JSObjectParent.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/JSObjectParent.cpp
@@ -0,0 +1,331 @@
+#include "mozilla/js/ipc/JSObjectParent.h"
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+namespace {
+    static const PRUint32 sFlagsSlot = 0, sWrappedObjSlot = 1;
+    static const PRUint32 sNumSlots = 2;
+    typedef JSObjectParent _;
+}
+
+const JSExtendedClass _::sJPW_JSClass = {
+    // JSClass (JSExtendedClass.base) initialization
+    { "JSInterProcessWrapper",
+      JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE |
+      JSCLASS_IS_EXTENDED | JSCLASS_HAS_RESERVED_SLOTS(sNumSlots),
+      _::JPW_AddProperty, _::JPW_DelProperty,
+      _::JPW_GetProperty, _::JPW_SetProperty,
+      (JSEnumerateOp)_::JPW_NewEnumerate,
+      (JSResolveOp)_::JPW_NewResolve,
+      _::JPW_Convert,     _::JPW_Finalize,
+      nsnull,             _::JPW_CheckAccess,
+      nsnull,             nsnull,
+      nsnull,             _::JPW_HasInstance,
+      nsnull,             nsnull
+    },
+
+    // JSExtendedClass initialization
+    _::JPW_Equality,
+    nsnull,             // outerObject
+    nsnull,             // innerObject
+    _::JPW_Iterator,
+    nsnull,             // wrappedObject
+    JSCLASS_NO_RESERVED_MEMBERS
+};
+
+JSObject*
+JSObjectParent::GetJSObject(JSContext* cx) const
+{
+    JSClass* clasp = const_cast<JSClass*>(&_::sJPW_JSClass.base);
+    if (!mObj) {
+        JSAutoRequest request(cx);
+        mObj = JS_NewObjectWithGivenProto(cx, clasp, NULL, NULL);
+        JS_SetReservedSlot(cx, mObj, sWrappedObjSlot, PRIVATE_TO_JSVAL(this));
+        JS_SetReservedSlot(cx, mObj, sFlagsSlot, JSVAL_ZERO);
+    }
+    return mObj;
+}
+
+static JSObjectParent*
+Unwrap(JSContext* cx, JSObject* obj)
+{
+    jsval info;
+    if (!JS_GetReservedSlot(cx, obj, sWrappedObjSlot, &info))
+        return NULL;
+    return static_cast<JSObjectParent*>(JSVAL_TO_PRIVATE(info));
+}
+
+/*static*/ bool
+JSObjectParent::jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to)
+{
+    switch (JS_TypeOfValue(cx, from)) {
+    case JSTYPE_VOID:
+        *to = void_t();
+        return true;
+    case JSTYPE_OBJECT:
+    case JSTYPE_FUNCTION:
+        return false; // TODO allow iff JPW
+    case JSTYPE_STRING:
+        *to = nsString(JS_GetStringChars(JSVAL_TO_STRING(from)));
+        return true;
+    case JSTYPE_NUMBER:
+        if (JSVAL_IS_INT(from))
+            *to = JSVAL_TO_INT(from);
+        else if (JSVAL_IS_DOUBLE(from))
+            *to = JSVAL_TO_DOUBLE(from);
+        else return false;
+        return true;
+    case JSTYPE_BOOLEAN:
+        *to = JSVAL_TO_BOOLEAN(from);
+        return true;
+    case JSTYPE_NULL:
+        *to = null_t();
+    case JSTYPE_XML:
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+JSObjectParent::jsval_from_JSVariant(JSContext* cx, const JSVariant& from, jsval* to)
+{
+    switch (from.type()) {
+    case JSVariant::Tvoid_t:
+        *to = JSVAL_VOID;
+        return true;
+    case JSVariant::TPJSObjectParent:
+        {
+            JSObject* obj;
+            if (!JSObject_from_PJSObjectParent(cx, from.get_PJSObjectParent(), &obj))
+                return false;
+            *to = OBJECT_TO_JSVAL(obj);
+            return true;
+        }
+    case JSVariant::TnsString:
+        *to = STRING_TO_JSVAL(JS_NewUCStringCopyZ(cx, from.get_nsString().BeginReading()));
+        return true;
+    case JSVariant::Tint:
+        *to = INT_TO_JSVAL(from.get_int());
+        return true;
+    case JSVariant::Tdouble:
+        return !!JS_NewDoubleValue(cx, from.get_double(), to);
+    case JSVariant::Tbool:
+        *to = BOOLEAN_TO_JSVAL(from.get_bool());
+        return true;
+    case JSVariant::Tnull_t:
+        *to = JSVAL_NULL;
+        return true;
+    default:
+        return false;
+    }
+}
+
+/*static*/ bool
+JSObjectParent::JSObject_from_PJSObjectParent(JSContext* cx,
+                                              const PJSObjectParent* from,
+                                              JSObject** to)
+{
+    const JSObjectParent* jsop =
+        static_cast<const JSObjectParent*>(from);
+    *to = jsop
+        ? jsop->GetJSObject(cx)
+        : JSVAL_TO_OBJECT(JSVAL_NULL);
+    return true;
+}
+    
+static bool
+jsid_from_int(JSContext* cx, int from, jsid* to)
+{
+    jsval v = INT_TO_JSVAL(from);
+    return JS_ValueToId(cx, v, to);
+}
+
+static bool
+jsid_from_nsString(JSContext* cx, const nsString& from, jsid* to)
+{
+    JSString* str = JS_NewUCStringCopyZ(cx, from.BeginReading());
+    return JS_ValueToId(cx, STRING_TO_JSVAL(str), to);
+}
+
+static bool
+jsval_to_nsString(JSContext* cx, jsval from, nsString* to)
+{
+    JSString* str;
+    if (JSVAL_IS_STRING(from) &&
+        (str = JS_ValueToString(cx, from))) {
+        *to = JS_GetStringChars(str);
+        return true;
+    }
+    return false;
+}
+
+/*static*/ JSBool
+JSObjectParent::JPW_AddProperty(JSContext *cx, JSObject *obj, jsval id,
+                                jsval *vp)
+{
+    printf("Calling JPW_AddProperty...\n"); fflush(0);
+
+    JSObjectParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;    
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    return self->SendAddProperty(in_id);
+}    
+
+/*static*/ JSBool
+JSObjectParent::JPW_GetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                jsval *vp)
+{
+    printf("Calling JPW_GetProperty...\n"); fflush(0);
+
+    JSObjectParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_v;
+    
+    return (self->CallGetProperty(in_id,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}
+
+/*static*/ JSBool
+JSObjectParent::JPW_SetProperty(JSContext *cx, JSObject *obj, jsval id,
+                                jsval *vp)
+{
+    printf("Calling JPW_SetProperty...\n"); fflush(0);
+
+    JSObjectParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+    JSVariant in_v;
+
+    if (!jsval_to_nsString(cx, id, &in_id) ||
+        !self->jsval_to_JSVariant(cx, *vp, &in_v))
+        return JS_FALSE;
+    
+    bool out_ok;
+    JSVariant out_v;
+
+    return (self->CallSetProperty(in_id, in_v,
+                                  &out_ok, &out_v) &&
+            out_ok &&
+            self->jsval_from_JSVariant(cx, out_v, vp));
+}    
+    
+/*static*/ JSBool
+JSObjectParent::JPW_DelProperty(JSContext *cx, JSObject *obj, jsval id,
+                                jsval *vp)
+{
+    printf("Calling JPW_DelProperty...\n"); fflush(0);
+
+    JSObjectParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    
+    return (self->CallDelProperty(in_id,
+                                  &out_ok) &&
+            out_ok);
+}
+
+/*static*/ JSBool
+JSObjectParent::JPW_NewEnumerate(JSContext *cx, JSObject *obj,
+                                 JSIterateOp enum_op, jsval *statep, jsid *idp)
+{
+    printf("Calling JPW_NewEnumerate...\n"); fflush(0);
+
+    JSObjectParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;    
+    
+    JSVariant in_state;
+
+    if ((enum_op == JSENUMERATE_NEXT ||
+         enum_op == JSENUMERATE_DESTROY) &&
+        !self->jsval_to_JSVariant(cx, *statep, &in_state))
+        return JS_FALSE;
+
+    bool out_ok;
+    JSVariant out_state;
+
+    switch (enum_op) {
+    case JSENUMERATE_INIT: {
+        int out_id;
+        return (self->CallNewEnumerateInit(&out_ok, &out_state, &out_id) &&
+                out_ok &&
+                self->jsval_from_JSVariant(cx, out_state, statep) &&
+                jsid_from_int(cx, out_id, idp));
+    }
+    case JSENUMERATE_NEXT: {
+        nsString out_id;
+        return (self->CallNewEnumerateNext(in_state,
+                                           &out_ok, &out_state, &out_id) &&
+                out_ok,
+                self->jsval_from_JSVariant(cx, out_state, statep) &&
+                jsid_from_nsString(cx, out_id, idp));
+    }
+    case JSENUMERATE_DESTROY:
+        return self->SendNewEnumerateDestroy(in_state);
+    }
+
+    return JS_FALSE;
+}
+    
+/*static*/ JSBool
+JSObjectParent::JPW_NewResolve(JSContext *cx, JSObject *obj, jsval id,
+                               uintN flags, JSObject **objp)
+{
+    printf("Calling JPW_NewResolve (%s)...\n",
+           JS_GetTypeName(cx, JS_TypeOfValue(cx, id)));
+    fflush(0);
+
+    JSObjectParent* self = Unwrap(cx, obj);
+    if (!self)
+        return JS_FALSE;
+
+    nsString in_id;
+
+    if (!jsval_to_nsString(cx, id, &in_id))
+        return JS_FALSE;
+
+    bool out_ok;
+    PJSObjectParent* out_obj;
+    
+    return (self->CallNewResolve(in_id, flags,
+                                 &out_ok, &out_obj) &&
+            out_ok &&
+            JSObject_from_PJSObjectParent(cx, out_obj, objp));
+}
+
+/*static*/ void
+JSObjectParent::JPW_Finalize(JSContext* cx, JSObject* obj)
+{
+    JSObjectParent* self = Unwrap(cx, obj);
+    if (self)
+        self->Send__delete__(self);
+}
+
+}}}
diff --git a/js/src/ipc/JSObjectParent.h b/js/src/ipc/JSObjectParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/JSObjectParent.h
@@ -0,0 +1,114 @@
+#ifndef mozilla_js_ipc_JSObjectParent_h__
+#define mozilla_js_ipc_JSObjectParent_h__
+
+#include "mozilla/js/ipc/PJSObjectParent.h"
+#include "jsapi.h"
+#include "nsAutoJSValHolder.h"
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+class JSObjectParent
+    : public PJSObjectParent
+{
+public:
+
+    JSObject* GetJSObject(JSContext* cx) const;
+
+    jsval GetJSVal(JSContext* cx) const {
+        return OBJECT_TO_JSVAL(GetJSObject(cx));
+    }
+    
+private:
+
+    mutable JSObject* mObj;
+
+    static const JSExtendedClass sJPW_JSClass;
+    
+    static JSBool
+    JPW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    JPW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    JPW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+    
+    static JSBool
+    JPW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
+    static JSBool
+    JPW_NewEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
+                     jsval *statep, jsid *idp);
+
+    static JSBool
+    JPW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
+                   JSObject **objp);
+
+    static JSBool
+    JPW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
+    {
+        printf("Calling JPW_Convert...\n"); fflush(0);
+        if (type == JSTYPE_STRING) {
+            *vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, "oyez"));
+            return JS_TRUE;
+        }
+        return JS_FALSE;
+    }
+
+    static void
+    JPW_Finalize(JSContext* cx, JSObject* obj);
+
+    static JSBool
+    JPW_CheckAccess(JSContext *cx, JSObject *obj, jsval id,
+                    JSAccessMode mode, jsval *vp)
+    {
+        printf("Calling JPW_CheckAccess...\n"); fflush(0);
+        return JS_TRUE;
+    }
+
+    static JSBool
+    JPW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
+    {
+        printf("Calling JPW_HasInstance...\n"); fflush(0);
+        return JS_TRUE;
+    }
+
+    static JSBool
+    JPW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
+    {
+        printf("Calling JPW_Equality...\n"); fflush(0);
+        return JS_TRUE;
+    }
+
+    static JSObject*
+    JPW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
+    {
+        printf("Calling JPW_Iterator...\n"); fflush(0);
+        return JSVAL_NULL;
+    }
+    
+    static JSBool
+    JPW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+                 jsval *rval)
+    {
+        printf("Calling JPW_toString...\n"); fflush(0);
+        JSString *str = JS_NewStringCopyZ(cx, "[object JPW]");
+        if (!str)
+            return JS_FALSE;
+        *rval = STRING_TO_JSVAL(str);
+        return JS_TRUE;
+    }
+
+    static bool jsval_to_JSVariant(JSContext* cx, jsval from, JSVariant* to);
+    static bool jsval_from_JSVariant(JSContext* cx, const JSVariant& from,
+                                     jsval* to);
+    static bool JSObject_from_PJSObjectParent(JSContext* cx,
+                                              const PJSObjectParent* from,
+                                              JSObject** to);
+};
+
+}}}
+  
+#endif
diff --git a/js/src/ipc/Makefile.in b/js/src/ipc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/Makefile.in
@@ -0,0 +1,70 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#   The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = js
+LIBRARY_NAME = jsipc_s
+LIBXUL_LIBRARY = 1
+FORCE_STATIC_LIB = 1
+EXPORT_LIBRARY = 1
+
+EXPORTS_NAMESPACES = mozilla/js/ipc
+
+EXPORTS_mozilla/js/ipc = \
+  ScriptProxyTypes.h \
+  ScriptProxyChild.h \
+  ScriptProxyParent.h \
+  JSObjectParent.h \
+  JSObjectChild.h \
+  $(NULL)
+
+CPPSRCS = \
+  JSObjectParent.cpp \
+  JSObjectChild.cpp \
+  $(NULL)
+
+include $(topsrcdir)/config/config.mk
+include $(topsrcdir)/ipc/chromium/chromium-config.mk
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DBIN_SUFFIX='"$(BIN_SUFFIX)"'
diff --git a/js/src/ipc/PJSObject.ipdl b/js/src/ipc/PJSObject.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PJSObject.ipdl
@@ -0,0 +1,50 @@
+include protocol "PScriptProxy.ipdl";
+
+include "PScriptProxy.h"; // XXX why is this needed?
+
+using mozilla::js::ipc::JSVariant;
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+rpc protocol PJSObject
+{
+    manager PScriptProxy;
+    
+child:
+    __delete__(); // unroot
+
+    async AddProperty(nsString id);
+
+    rpc GetProperty(nsString id)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc SetProperty(nsString id,
+                    JSVariant v)
+        returns (bool ok,
+                 JSVariant vp);
+
+    rpc DelProperty(nsString id)
+        returns (bool ok);
+
+    rpc NewEnumerateInit()
+        returns (bool ok,
+                 JSVariant statep,
+                 int idp);
+
+    rpc NewEnumerateNext(JSVariant in_state)
+        returns (bool ok,
+                 JSVariant statep,
+                 nsString idp);
+
+    async NewEnumerateDestroy(JSVariant in_state);
+
+    rpc NewResolve(nsString id,
+                   int flags)
+        returns (bool ok,
+                 PJSObject obj2);
+};
+
+}}}
diff --git a/js/src/ipc/PScriptProxy.ipdl b/js/src/ipc/PScriptProxy.ipdl
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/PScriptProxy.ipdl
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 8 -*- */
+/* vim: set sw=4 ts=8 et tw=80 ft=cpp : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+include protocol "PIFrameEmbedding.ipdl";
+include protocol "PJSObject.ipdl";
+
+include "mozilla/js/ipc/ScriptProxyTypes.h";
+
+using mozilla::js::ipc::void_t;
+using mozilla::js::ipc::null_t;
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+union JSVariant {
+    void_t;
+    nullable PJSObject;
+    nsString;
+    int;
+    double;
+    bool;
+    null_t;
+};
+
+rpc protocol PScriptProxy
+{
+    manager PIFrameEmbedding;
+    manages PJSObject;
+parent:
+    __delete__();
+    sync PJSObject(bool global);
+};
+
+} // namespace ipc
+} // namespace js
+} // mozilla
diff --git a/js/src/ipc/ScriptProxyChild.h b/js/src/ipc/ScriptProxyChild.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ScriptProxyChild.h
@@ -0,0 +1,88 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set sw=4 ts=8 et tw=80 : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_js_ipc_ScriptProxyChild_h__
+#define mozilla_js_ipc_ScriptProxyChild_h__
+
+#include "mozilla/js/ipc/PScriptProxyChild.h"
+#include "mozilla/js/ipc/JSObjectChild.h"
+
+#include "jsapi.h"
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+class ScriptProxyChild
+    : public PScriptProxyChild
+{
+public:
+
+    ScriptProxyChild(JSContext* cx) : mContext(cx) {}
+
+    PJSObjectChild* AllocPJSObject(JSObject* obj) {
+        JSAutoRequest request(mContext);
+        return new JSObjectChild(mContext, obj);
+    }
+    
+private:
+    
+    JSContext* const mContext;
+    
+protected:
+
+    PJSObjectChild* AllocPJSObject(const bool& global) {
+        NS_ASSERTION(global, "Telling lies to parent?");
+        JSAutoRequest request(mContext);
+        return new JSObjectChild(mContext, JS_GetGlobalObject(mContext));
+    }
+
+    bool DeallocPJSObject(PJSObjectChild* actor)
+    {
+        delete actor;
+        return true;
+    }
+
+};
+
+} // namespace ipc
+} // namespace js
+} // namespace mozilla
+
+#endif
diff --git a/js/src/ipc/ScriptProxyParent.h b/js/src/ipc/ScriptProxyParent.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ScriptProxyParent.h
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set sw=4 ts=8 et tw=80 : */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Newman <b{enjam,newma}n@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef mozilla_js_ipc_ScriptProxyParent_h__
+#define mozilla_js_ipc_ScriptProxyParent_h__
+
+#include "mozilla/js/ipc/PScriptProxyParent.h"
+#include "mozilla/js/ipc/JSObjectParent.h"
+
+#include "jsapi.h"
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+    
+class ScriptProxyParent
+    : public PScriptProxyParent
+{   
+public:
+
+    bool AttachGlobal(JSContext* cx, JSObject* to, jsid id) {
+        return (mGlobal &&
+                JS_DefinePropertyById(cx, to, id, mGlobal->GetJSVal(cx), NULL,
+                                      NULL, 0));
+    }
+    
+private:
+
+    JSObjectParent* mGlobal;
+
+    PJSObjectParent* AllocPJSObject(const bool& global)
+    {
+        JSObjectParent* jsop = new JSObjectParent();
+        if (global)
+            mGlobal = jsop;
+        return jsop;
+    }
+
+    bool DeallocPJSObject(PJSObjectParent* actor) {
+        // TODO what if actor == mGlobal?
+        delete actor;
+        return true;
+    }
+
+};
+
+} // namespace ipc
+} // namespace js
+} // namespace mozilla
+
+#endif
diff --git a/js/src/ipc/ScriptProxyTypes.h b/js/src/ipc/ScriptProxyTypes.h
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ScriptProxyTypes.h
@@ -0,0 +1,35 @@
+#ifndef mozilla_js_ipc_ScriptProxyTypes_h__
+#define mozilla_js_ipc_ScriptProxyTypes_h__
+
+#include "jsapi.h"
+
+namespace mozilla {
+namespace js {
+namespace ipc {
+
+struct void_t {};
+struct null_t {};
+    
+template <typename P>
+struct JPWSingleton
+{
+    static void Write(IPC::Message*, const P&) {}
+    static bool Read(const IPC::Message*, void**, P*) { return true; }
+};
+    
+} // namespace ipc
+} // namespace js
+} // namespace mozilla
+
+namespace IPC {
+
+using mozilla::js::ipc::JPWSingleton;
+using mozilla::js::ipc::null_t;
+using mozilla::js::ipc::void_t;
+
+template <> struct ParamTraits<void_t> : public JPWSingleton<void_t> {};
+template <> struct ParamTraits<null_t> : public JPWSingleton<null_t> {};
+ 
+}
+
+#endif
diff --git a/js/src/ipc/ipdl.mk b/js/src/ipc/ipdl.mk
new file mode 100644
--- /dev/null
+++ b/js/src/ipc/ipdl.mk
@@ -0,0 +1,41 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+#   The Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2009
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Newman <b{enjam,newma}n@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+IPDLSRCS = \
+  PScriptProxy.ipdl \
+  PJSObject.ipdl \
+  $(NULL)
diff --git a/toolkit/library/libxul-config.mk b/toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk
+++ b/toolkit/library/libxul-config.mk
@@ -88,16 +88,17 @@ RCFLAGS += -i $(topsrcdir)/widget/src/os
 endif
 
 LOCAL_INCLUDES += -I$(topsrcdir)/widget/src/os2
 endif
 
 # dependent libraries
 ifdef MOZ_IPC
 STATIC_LIBS += \
+  jsipc_s \
   domipc_s \
   domplugins_s \
   mozipc_s \
   mozipdlgen_s \
   chromium_s \
   ipcshell_s \
   gfxipc_s \
   $(NULL)
diff --git a/toolkit/toolkit-makefiles.sh b/toolkit/toolkit-makefiles.sh
--- a/toolkit/toolkit-makefiles.sh
+++ b/toolkit/toolkit-makefiles.sh
@@ -203,16 +203,20 @@ MAKEFILES_xpconnect="
   js/src/xpconnect/loader/Makefile
   js/src/xpconnect/tests/Makefile
   js/src/xpconnect/tests/components/Makefile
   js/src/xpconnect/tests/idl/Makefile
   js/src/xpconnect/tools/Makefile
   js/src/xpconnect/tools/idl/Makefile
 "
 
+MAKEFILES_jsipc="
+  js/src/ipc/Makefile
+"
+
 MAKEFILES_jsdebugger="
   js/jsd/Makefile
   js/jsd/idl/Makefile
 "
 
 MAKEFILES_jsctypes="
   js/ctypes/Makefile
 "
@@ -852,16 +856,17 @@ add_makefiles "
   $MAKEFILES_db
   $MAKEFILES_dom
   $MAKEFILES_editor
   $MAKEFILES_xmlparser
   $MAKEFILES_gfx
   $MAKEFILES_htmlparser
   $MAKEFILES_intl
   $MAKEFILES_xpconnect
+  $MAKEFILES_jsipc
   $MAKEFILES_jsdebugger
   $MAKEFILES_jsctypes
   $MAKEFILES_content
   $MAKEFILES_layout
   $MAKEFILES_libimg
   $MAKEFILES_libjar
   $MAKEFILES_libreg
   $MAKEFILES_libpref
diff --git a/toolkit/toolkit-tiers.mk b/toolkit/toolkit-tiers.mk
--- a/toolkit/toolkit-tiers.mk
+++ b/toolkit/toolkit-tiers.mk
@@ -76,17 +76,17 @@ ifeq ($(OS_ARCH),WINCE)
 tier_external_dirs += modules/lib7z
 endif
 
 #
 # tier "gecko" - core components
 #
 
 ifdef MOZ_IPC
-tier_gecko_dirs += ipc
+tier_gecko_dirs += ipc js/src/ipc
 endif
 
 tier_gecko_dirs += \
 		$(tier_necko_dirs) \
 		js/src/xpconnect \
 		js/ctypes \
 		intl/chardet \
 		$(NULL)
